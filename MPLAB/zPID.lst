CCS PCH C Compiler, Version 4.106, 34123               12-jun.-13 16:08

               Filename: C:\X\school\projects\zPID\z\zPID\MPLAB\zPID.lst

               ROM used: 29270 bytes (89%)
                         Largest free fragment is 3494
               RAM used: 457 (22%) at main() level
                         918 (45%) worst case
               Stack:    17 worst case (6 in main + 11 for interrupts)

*
0000:  GOTO   7184
*
0008:  GOTO   00CE
000C:  NOP   
000E:  NOP   
0010:  NOP   
0012:  NOP   
0014:  NOP   
0016:  NOP   
0018:  MOVWF  04
001A:  MOVFF  FD8,05
001E:  MOVFF  FE0,06
0022:  MOVLB  0
0024:  MOVFF  FE9,0C
0028:  MOVFF  FEA,07
002C:  MOVFF  FE1,08
0030:  MOVFF  FE2,09
0034:  MOVFF  FD9,0A
0038:  MOVFF  FDA,0B
003C:  MOVFF  FF3,12
0040:  MOVFF  FF4,13
0044:  MOVFF  FFA,14
0048:  MOVFF  FF5,15
004C:  MOVFF  FF6,16
0050:  MOVFF  FF7,17
0054:  MOVFF  00,0E
0058:  MOVFF  01,0F
005C:  MOVFF  02,10
0060:  MOVFF  03,11
0064:  BTFSS  FF2.5
0066:  GOTO   0070
006A:  BTFSC  FF2.2
006C:  GOTO   0D3E
0070:  BTFSS  F9D.0
0072:  GOTO   007C
0076:  BTFSC  F9E.0
0078:  GOTO   34E8
007C:  GOTO   01E8
0080:  MOVFF  0E,00
0084:  MOVFF  0F,01
0088:  MOVFF  10,02
008C:  MOVFF  11,03
0090:  MOVFF  0C,FE9
0094:  MOVFF  07,FEA
0098:  BSF    07.7
009A:  MOVFF  08,FE1
009E:  MOVFF  09,FE2
00A2:  MOVFF  0A,FD9
00A6:  MOVFF  0B,FDA
00AA:  MOVFF  12,FF3
00AE:  MOVFF  13,FF4
00B2:  MOVFF  14,FFA
00B6:  MOVFF  15,FF5
00BA:  MOVFF  16,FF6
00BE:  MOVFF  17,FF7
00C2:  MOVF   04,W
00C4:  MOVFF  06,FE0
00C8:  MOVFF  05,FD8
00CC:  RETFIE 0
00CE:  MOVWF  1A
00D0:  MOVFF  FD8,1B
00D4:  MOVFF  FE0,1C
00D8:  MOVLB  0
00DA:  MOVFF  FE9,22
00DE:  MOVFF  FEA,1D
00E2:  MOVFF  FE1,1E
00E6:  MOVFF  FE2,1F
00EA:  MOVFF  FD9,20
00EE:  MOVFF  FDA,21
00F2:  MOVFF  FF3,28
00F6:  MOVFF  FF4,29
00FA:  MOVFF  FFA,2A
00FE:  MOVFF  FF5,2B
0102:  MOVFF  FF6,2C
0106:  MOVFF  FF7,2D
010A:  MOVFF  00,24
010E:  MOVFF  01,25
0112:  MOVFF  02,26
0116:  MOVFF  03,27
011A:  BTFSS  F9D.5
011C:  GOTO   0126
0120:  BTFSC  F9E.5
0122:  GOTO   0190
0126:  GOTO   01E8
012A:  MOVFF  24,00
012E:  MOVFF  25,01
0132:  MOVFF  26,02
0136:  MOVFF  27,03
013A:  MOVFF  22,FE9
013E:  MOVFF  1D,FEA
0142:  BSF    1D.7
0144:  MOVFF  1E,FE1
0148:  MOVFF  1F,FE2
014C:  MOVFF  20,FD9
0150:  MOVFF  21,FDA
0154:  MOVFF  28,FF3
0158:  MOVFF  29,FF4
015C:  MOVFF  2A,FFA
0160:  MOVFF  2B,FF5
0164:  MOVFF  2C,FF6
0168:  MOVFF  2D,FF7
016C:  MOVF   1A,W
016E:  MOVFF  1C,FE0
0172:  MOVFF  1B,FD8
0176:  RETFIE 0
.................... #include "SerialPort.c" 
.................... #include "GLOBAL.c" 
.................... /////////////////////////////*DIRECTIVES*/////////////////////////////////////// 
*
3E32:  MOVFF  00,1EF
3E36:  MOVFF  01,1F0
3E3A:  MOVFF  02,1F1
3E3E:  MOVFF  03,1F2
3E42:  CLRF   19
3E44:  BTFSC  FF2.6
3E46:  BSF    19.6
3E48:  BCF    FF2.6
3E4A:  BTFSC  FF2.7
3E4C:  BSF    19.7
3E4E:  BCF    FF2.7
3E50:  MOVFF  03,386
3E54:  MOVFF  02,385
3E58:  MOVFF  01,384
3E5C:  MOVFF  00,383
3E60:  MOVLB  3
3E62:  CLRF   x8A
3E64:  CLRF   x89
3E66:  CLRF   x88
3E68:  MOVLW  81
3E6A:  MOVWF  x87
3E6C:  MOVLB  0
3E6E:  CALL   0376
3E72:  BTFSC  19.6
3E74:  BSF    FF2.6
3E76:  BTFSC  19.7
3E78:  BSF    FF2.7
*
40B0:  MOVFF  00,1EF
40B4:  MOVFF  01,1F0
40B8:  MOVFF  02,1F1
40BC:  MOVFF  03,1F2
40C0:  CLRF   19
40C2:  BTFSC  FF2.6
40C4:  BSF    19.6
40C6:  BCF    FF2.6
40C8:  BTFSC  FF2.7
40CA:  BSF    19.7
40CC:  BCF    FF2.7
40CE:  MOVFF  03,386
40D2:  MOVFF  02,385
40D6:  MOVFF  01,384
40DA:  MOVFF  00,383
40DE:  MOVLB  3
40E0:  CLRF   x8A
40E2:  CLRF   x89
40E4:  CLRF   x88
40E6:  MOVLW  81
40E8:  MOVWF  x87
40EA:  MOVLB  0
40EC:  CALL   0376
40F0:  BTFSC  19.6
40F2:  BSF    FF2.6
40F4:  BTFSC  19.7
40F6:  BSF    FF2.7
*
42B6:  MOVFF  00,1EF
42BA:  MOVFF  01,1F0
42BE:  MOVFF  02,1F1
42C2:  MOVFF  03,1F2
42C6:  CLRF   19
42C8:  BTFSC  FF2.6
42CA:  BSF    19.6
42CC:  BCF    FF2.6
42CE:  BTFSC  FF2.7
42D0:  BSF    19.7
42D2:  BCF    FF2.7
42D4:  MOVFF  03,386
42D8:  MOVFF  02,385
42DC:  MOVFF  01,384
42E0:  MOVFF  00,383
42E4:  MOVLB  3
42E6:  CLRF   x8A
42E8:  CLRF   x89
42EA:  CLRF   x88
42EC:  MOVLW  81
42EE:  MOVWF  x87
42F0:  MOVLB  0
42F2:  CALL   0376
42F6:  BTFSC  19.6
42F8:  BSF    FF2.6
42FA:  BTFSC  19.7
42FC:  BSF    FF2.7
*
44BC:  MOVFF  00,1EF
44C0:  MOVFF  01,1F0
44C4:  MOVFF  02,1F1
44C8:  MOVFF  03,1F2
44CC:  CLRF   19
44CE:  BTFSC  FF2.6
44D0:  BSF    19.6
44D2:  BCF    FF2.6
44D4:  BTFSC  FF2.7
44D6:  BSF    19.7
44D8:  BCF    FF2.7
44DA:  MOVFF  03,386
44DE:  MOVFF  02,385
44E2:  MOVFF  01,384
44E6:  MOVFF  00,383
44EA:  MOVLB  3
44EC:  CLRF   x8A
44EE:  CLRF   x89
44F0:  CLRF   x88
44F2:  MOVLW  81
44F4:  MOVWF  x87
44F6:  MOVLB  0
44F8:  CALL   0376
44FC:  BTFSC  19.6
44FE:  BSF    FF2.6
4500:  BTFSC  19.7
4502:  BSF    FF2.7
*
46C2:  MOVFF  00,1EF
46C6:  MOVFF  01,1F0
46CA:  MOVFF  02,1F1
46CE:  MOVFF  03,1F2
46D2:  CLRF   19
46D4:  BTFSC  FF2.6
46D6:  BSF    19.6
46D8:  BCF    FF2.6
46DA:  BTFSC  FF2.7
46DC:  BSF    19.7
46DE:  BCF    FF2.7
46E0:  MOVFF  03,386
46E4:  MOVFF  02,385
46E8:  MOVFF  01,384
46EC:  MOVFF  00,383
46F0:  MOVLB  3
46F2:  CLRF   x8A
46F4:  CLRF   x89
46F6:  CLRF   x88
46F8:  MOVLW  81
46FA:  MOVWF  x87
46FC:  MOVLB  0
46FE:  CALL   0376
4702:  BTFSC  19.6
4704:  BSF    FF2.6
4706:  BTFSC  19.7
4708:  BSF    FF2.7
.................... #include "18f4550.h" 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOBROWNOUT,NOPUT,NOLVP,PLL5,CPUDIV1 
.................... #device ADC=10 //number of bits the ADC should return 
.................... #device WRITE_EEPROM=ASYNC//DON't use write_eeprom from both ISR and outside ISR 
.................... #device HIGH_INTS=TRUE 
.................... #use delay(clock=20000000) 
.................... #use rs232(UART1,BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7,ERRORS)//,DISABLE_INTS)//,TIMEOUT=100) 
*
0178:  BTFSS  F9E.5
017A:  BRA    0178
017C:  MOVFF  FAB,2F
0180:  MOVFF  FAE,01
0184:  BTFSS  2F.1
0186:  BRA    018C
0188:  BCF    FAB.4
018A:  BSF    FAB.4
018C:  GOTO   0192 (RETURN)
*
4F82:  BTFSS  F9E.4
4F84:  BRA    4F82
4F86:  MOVWF  FAD
4F88:  RETLW  00
....................  
.................... //Inicializando ROM  
.................... #ROM 0x00F00000={0x7A87,0x0000, 0x1686,0x0000, 0x3081,0x0000, 0x0001, 0x01F4,\ 
.................... 								0x0003, 0x0000, 0x0007, 0x0003, 0x2E7C,0x7B14, 0x007C,0x0000,\ 
.................... 								0x0C7E,0xCDCC, 0x0258, 0x0014, 0x0006, 0x1687,0x0000,\ 
.................... 								0x2082,0x0000, 0x0C7E,0xCDCC, 0x0000, 0x0000, 0x0000} //inicializando 0-57 de la EEPROM  
.................... /* 
....................   							{Kp:LSB,MSB,    Ki:LSB,MSB,    Kd:LSB,MSB,    Tc,     rf,\ 
.................... 								cantM,  BR,     PWMf,   TP,     Kp_F:LSB,MSB,  Ki_F:LSB,MSB,\ 
.................... 								Kd_F:LSB,MSB,  univ_PD, univ_PI, Tc_F, stepPD:LSB,MSB,\ 
.................... 								stepPI:LSB,MSB, Kpi_F:LSB,MSB, fPWM1, ADselected, TipoAccion} 
.................... */ 
....................  
.................... //RDA es de alta prioridad								 
.................... #priority RDA,TIMER0,TIMER1 
....................  
.................... #include "myEEPROM.c"  
.................... /* 
.................... EXPLICACION: 
....................   float data; 
....................   int8 x; 
....................   x = *(((int8*)&data + i)); 
....................   1-Cuando se referencia 'data' (&) se accede a la direccion donde esta almacenado ese float 
....................   2-Se castea como (int8*), accediendo a solo 8 bits de esa direccion 
....................   3-Se realiza un desplazamiento de 8 bits en 8 bits en dependencia de la i 
....................   4-Se castea la direccion completa como *, es decir, se apunta a esa direccion 
....................   5-El resultado 'x' sera el valor almacenado en esa direccion de memoria  
.................... */ 
....................  
.................... void write_float_eeprom(int8 address, float data)  
.................... { 
....................    int i; 
....................     
....................    for(i=0;i<4;i++) 
*
5E34:  MOVLB  1
5E36:  CLRF   xCE
5E38:  MOVF   xCE,W
5E3A:  SUBLW  03
5E3C:  BNC   5E96
....................      write_eeprom(i + address, *(((int8*)&data + i))); 
5E3E:  MOVF   xC9,W
5E40:  ADDWF  xCE,W
5E42:  MOVWF  xCF
5E44:  MOVLW  01
5E46:  MOVWF  xD1
5E48:  MOVLW  CA
5E4A:  MOVWF  xD0
5E4C:  MOVF   xCE,W
5E4E:  ADDWF  xD0,W
5E50:  MOVWF  01
5E52:  MOVLW  00
5E54:  ADDWFC xD1,W
5E56:  MOVWF  03
5E58:  MOVF   01,W
5E5A:  MOVWF  FE9
5E5C:  MOVFF  03,FEA
5E60:  MOVFF  FEF,1D0
5E64:  BTFSC  FA6.1
5E66:  BRA    5E64
5E68:  BCF    FA6.2
5E6A:  MOVFF  1CF,FA9
5E6E:  MOVFF  1D0,FA8
5E72:  BCF    FA6.6
5E74:  BCF    FA6.7
5E76:  BSF    FA6.2
5E78:  MOVF   FF2,W
5E7A:  MOVWF  00
5E7C:  BCF    FF2.6
5E7E:  BCF    FF2.7
5E80:  MOVLB  F
5E82:  MOVLW  55
5E84:  MOVWF  FA7
5E86:  MOVLW  AA
5E88:  MOVWF  FA7
5E8A:  BSF    FA6.1
5E8C:  MOVF   00,W
5E8E:  IORWF  FF2,F
5E90:  MOVLB  1
5E92:  INCF   xCE,F
5E94:  BRA    5E38
.................... } 
5E96:  MOVLB  0
5E98:  RETLW  00
....................  
.................... float read_float_eeprom(int8 address)         
.................... { 
....................    int i; 
....................    float data; 
....................  
....................    for(i=0;i<4;i++) 
*
37AE:  MOVLB  1
37B0:  CLRF   xCA
37B2:  MOVF   xCA,W
37B4:  SUBLW  03
37B6:  BNC   37FC
....................      *(((int8*)&data) + i) = read_eeprom(i + address); 
37B8:  MOVLW  01
37BA:  MOVWF  xD0
37BC:  MOVLW  CB
37BE:  MOVWF  xCF
37C0:  MOVF   xCA,W
37C2:  ADDWF  xCF,W
37C4:  MOVWF  01
37C6:  MOVLW  00
37C8:  ADDWFC xD0,W
37CA:  MOVWF  03
37CC:  MOVF   01,W
37CE:  MOVWF  FE9
37D0:  MOVFF  03,FEA
37D4:  MOVF   xC9,W
37D6:  ADDWF  xCA,W
37D8:  MOVWF  xD1
37DA:  MOVFF  FF2,1D2
37DE:  BCF    FF2.6
37E0:  BCF    FF2.7
37E2:  MOVFF  1D1,FA9
37E6:  BCF    FA6.6
37E8:  BCF    FA6.7
37EA:  BSF    FA6.0
37EC:  MOVF   FA8,W
37EE:  BTFSC  xD2.6
37F0:  BSF    FF2.6
37F2:  BTFSC  xD2.7
37F4:  BSF    FF2.7
37F6:  MOVWF  FEF
37F8:  INCF   xCA,F
37FA:  BRA    37B2
....................  
....................    return data; 
37FC:  MOVFF  1CB,00
3800:  MOVFF  1CC,01
3804:  MOVFF  1CD,02
3808:  MOVFF  1CE,03
.................... } 
380C:  MOVLB  0
380E:  RETLW  00
....................  
.................... void write_int16_eeprom(int8 address, int16 data) 
.................... { 
....................   write_eeprom(address,data); 
*
5DCA:  BTFSC  FA6.1
5DCC:  BRA    5DCA
5DCE:  BCF    FA6.2
5DD0:  MOVFF  1C9,FA9
5DD4:  MOVFF  1CA,FA8
5DD8:  BCF    FA6.6
5DDA:  BCF    FA6.7
5DDC:  BSF    FA6.2
5DDE:  MOVF   FF2,W
5DE0:  MOVWF  00
5DE2:  BCF    FF2.6
5DE4:  BCF    FF2.7
5DE6:  MOVLB  F
5DE8:  MOVLW  55
5DEA:  MOVWF  FA7
5DEC:  MOVLW  AA
5DEE:  MOVWF  FA7
5DF0:  BSF    FA6.1
5DF2:  MOVF   00,W
5DF4:  IORWF  FF2,F
....................   write_eeprom(address+1,data/0x100); 
5DF6:  MOVLW  01
5DF8:  MOVLB  1
5DFA:  ADDWF  xC9,W
5DFC:  MOVWF  xCC
5DFE:  MOVFF  1CB,1CD
5E02:  CLRF   xCE
5E04:  BTFSC  FA6.1
5E06:  BRA    5E04
5E08:  BCF    FA6.2
5E0A:  MOVFF  1CC,FA9
5E0E:  MOVFF  1CD,FA8
5E12:  BCF    FA6.6
5E14:  BCF    FA6.7
5E16:  BSF    FA6.2
5E18:  MOVF   FF2,W
5E1A:  MOVWF  00
5E1C:  BCF    FF2.6
5E1E:  BCF    FF2.7
5E20:  MOVLB  F
5E22:  MOVLW  55
5E24:  MOVWF  FA7
5E26:  MOVLW  AA
5E28:  MOVWF  FA7
5E2A:  BSF    FA6.1
5E2C:  MOVF   00,W
5E2E:  IORWF  FF2,F
.................... } 
5E30:  MOVLB  0
5E32:  RETLW  00
....................  
.................... signed int16 read_int16_eeprom(int8 address) 
.................... { 
....................   return read_eeprom(address+1)*0x100 + read_eeprom(address); 
*
3810:  MOVLW  01
3812:  MOVLB  1
3814:  ADDWF  xC9,W
3816:  MOVWF  xCA
3818:  MOVFF  FF2,1CB
381C:  BCF    FF2.6
381E:  BCF    FF2.7
3820:  MOVFF  1CA,FA9
3824:  BCF    FA6.6
3826:  BCF    FA6.7
3828:  BSF    FA6.0
382A:  MOVF   FA8,W
382C:  BTFSC  xCB.6
382E:  BSF    FF2.6
3830:  BTFSC  xCB.7
3832:  BSF    FF2.7
3834:  MOVWF  xCC
3836:  CLRF   19
3838:  BTFSC  FF2.6
383A:  BSF    19.6
383C:  BCF    FF2.6
383E:  BTFSC  FF2.7
3840:  BSF    19.7
3842:  BCF    FF2.7
3844:  MOVLB  2
3846:  CLRF   x16
3848:  MOVFF  1CC,215
384C:  MOVLW  01
384E:  MOVWF  x18
3850:  CLRF   x17
3852:  MOVLB  0
3854:  RCALL  3406
3856:  BTFSC  19.6
3858:  BSF    FF2.6
385A:  BTFSC  19.7
385C:  BSF    FF2.7
385E:  MOVFF  02,1CD
3862:  MOVFF  01,1CC
3866:  MOVFF  FF2,1CA
386A:  BCF    FF2.6
386C:  BCF    FF2.7
386E:  MOVFF  1C9,FA9
3872:  BCF    FA6.6
3874:  BCF    FA6.7
3876:  BSF    FA6.0
3878:  MOVF   FA8,W
387A:  MOVLB  1
387C:  BTFSC  xCA.6
387E:  BSF    FF2.6
3880:  BTFSC  xCA.7
3882:  BSF    FF2.7
3884:  ADDWF  xCC,W
3886:  MOVWF  01
3888:  MOVLW  00
388A:  ADDWFC xCD,W
388C:  MOVWF  03
388E:  MOVF   01,W
3890:  MOVWF  01
3892:  MOVF   03,W
3894:  MOVWF  02
.................... } 
3896:  MOVLB  0
3898:  RETLW  00
....................  
....................  
.................... #include "stdlib.h"  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
*
61EA:  MOVLB  1
61EC:  CLRF   xD1
61EE:  CLRF   xD0
61F0:  CLRF   xCF
61F2:  MOVLW  7F
61F4:  MOVWF  xCE
61F6:  CLRF   xD5
61F8:  CLRF   xD4
61FA:  CLRF   xD3
61FC:  CLRF   xD2
61FE:  BSF    xD6.0
6200:  BCF    xD6.1
6202:  BCF    xD6.2
6204:  CLRF   xD8
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
6206:  MOVF   xCA,W
6208:  IORWF  xCB,W
620A:  BNZ   6216
....................       return 0; 
620C:  CLRF   00
620E:  CLRF   01
6210:  CLRF   02
6212:  CLRF   03
6214:  BRA    64FA
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
6216:  MOVF   xD8,W
6218:  INCF   xD8,F
621A:  CLRF   03
621C:  ADDWF  xCA,W
621E:  MOVWF  FE9
6220:  MOVF   xCB,W
6222:  ADDWFC 03,W
6224:  MOVWF  FEA
6226:  MOVFF  FEF,1D7
622A:  MOVF   xD7,F
622C:  BTFSC  FD8.2
622E:  BRA    6466
....................    { 
....................       if (skip && !isspace(c)) 
6230:  BTFSS  xD6.0
6232:  BRA    6252
6234:  MOVF   xD7,W
6236:  SUBLW  20
6238:  BZ    6252
....................       { 
....................          skip = 0; 
623A:  BCF    xD6.0
....................          if (c == '+') 
623C:  MOVF   xD7,W
623E:  SUBLW  2B
6240:  BNZ   6248
....................          { 
....................             sign = 0; 
6242:  BCF    xD6.1
....................             continue; 
6244:  BRA    644C
....................          }             
....................          else if (c == '-') 
6246:  BRA    6252
6248:  MOVF   xD7,W
624A:  SUBLW  2D
624C:  BNZ   6252
....................          { 
....................             sign = 1; 
624E:  BSF    xD6.1
....................             continue; 
6250:  BRA    644C
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
6252:  BTFSC  xD6.0
6254:  BRA    6264
6256:  MOVF   xD7,W
6258:  SUBLW  2E
625A:  BNZ   6264
625C:  BTFSC  xD6.2
625E:  BRA    6264
....................          point = 1; 
6260:  BSF    xD6.2
....................       else if (!skip && isdigit(c)) 
6262:  BRA    644C
6264:  BTFSC  xD6.0
6266:  BRA    6446
6268:  MOVF   xD7,W
626A:  SUBLW  2F
626C:  BTFSC  FD8.0
626E:  BRA    6446
6270:  MOVF   xD7,W
6272:  SUBLW  39
6274:  BTFSS  FD8.0
6276:  BRA    6446
....................       { 
....................          c -= '0'; 
6278:  MOVLW  30
627A:  SUBWF  xD7,F
....................          if (point) 
627C:  BTFSS  xD6.2
627E:  BRA    6388
6280:  CLRF   19
6282:  BTFSC  FF2.6
6284:  BSF    19.6
6286:  BCF    FF2.6
6288:  BTFSC  FF2.7
628A:  BSF    19.7
628C:  BCF    FF2.7
....................          { 
....................             pow10 = pow10 * 10.0; 
628E:  MOVFF  1D1,331
6292:  MOVFF  1D0,330
6296:  MOVFF  1CF,32F
629A:  MOVFF  1CE,32E
629E:  MOVLB  3
62A0:  CLRF   x35
62A2:  CLRF   x34
62A4:  MOVLW  20
62A6:  MOVWF  x33
62A8:  MOVLW  82
62AA:  MOVWF  x32
62AC:  MOVLB  0
62AE:  CALL   050A
62B2:  BTFSC  19.6
62B4:  BSF    FF2.6
62B6:  BTFSC  19.7
62B8:  BSF    FF2.7
62BA:  MOVFF  03,1D1
62BE:  MOVFF  02,1D0
62C2:  MOVFF  01,1CF
62C6:  MOVFF  00,1CE
62CA:  CLRF   19
62CC:  BTFSC  FF2.6
62CE:  BSF    19.6
62D0:  BCF    FF2.6
62D2:  BTFSC  FF2.7
62D4:  BSF    19.7
62D6:  BCF    FF2.7
....................             result += (float)c / pow10;    
62D8:  MOVLB  2
62DA:  CLRF   x16
62DC:  MOVFF  1D7,215
62E0:  MOVLB  0
62E2:  CALL   04D4
62E6:  BTFSC  19.6
62E8:  BSF    FF2.6
62EA:  BTFSC  19.7
62EC:  BSF    FF2.7
62EE:  MOVFF  00,1D9
62F2:  MOVFF  01,1DA
62F6:  MOVFF  02,1DB
62FA:  MOVFF  03,1DC
62FE:  CLRF   19
6300:  BTFSC  FF2.6
6302:  BSF    19.6
6304:  BCF    FF2.6
6306:  BTFSC  FF2.7
6308:  BSF    19.7
630A:  BCF    FF2.7
630C:  MOVFF  03,386
6310:  MOVFF  02,385
6314:  MOVFF  01,384
6318:  MOVFF  00,383
631C:  MOVFF  1D1,38A
6320:  MOVFF  1D0,389
6324:  MOVFF  1CF,388
6328:  MOVFF  1CE,387
632C:  CALL   0376
6330:  BTFSC  19.6
6332:  BSF    FF2.6
6334:  BTFSC  19.7
6336:  BSF    FF2.7
6338:  BCF    FD8.1
633A:  CLRF   19
633C:  BTFSC  FF2.6
633E:  BSF    19.6
6340:  BCF    FF2.6
6342:  BTFSC  FF2.7
6344:  BSF    19.7
6346:  BCF    FF2.7
6348:  MOVFF  1D5,386
634C:  MOVFF  1D4,385
6350:  MOVFF  1D3,384
6354:  MOVFF  1D2,383
6358:  MOVFF  03,38A
635C:  MOVFF  02,389
6360:  MOVFF  01,388
6364:  MOVFF  00,387
6368:  CALL   0600
636C:  BTFSC  19.6
636E:  BSF    FF2.6
6370:  BTFSC  19.7
6372:  BSF    FF2.7
6374:  MOVFF  03,1D5
6378:  MOVFF  02,1D4
637C:  MOVFF  01,1D3
6380:  MOVFF  00,1D2
....................          } 
....................          else 
6384:  BRA    6442
6386:  MOVLB  1
6388:  CLRF   19
638A:  BTFSC  FF2.6
638C:  BSF    19.6
638E:  BCF    FF2.6
6390:  BTFSC  FF2.7
6392:  BSF    19.7
6394:  BCF    FF2.7
....................          { 
....................             result = 10.0 * result + (float)c; 
6396:  MOVLB  3
6398:  CLRF   x31
639A:  CLRF   x30
639C:  MOVLW  20
639E:  MOVWF  x2F
63A0:  MOVLW  82
63A2:  MOVWF  x2E
63A4:  MOVFF  1D5,335
63A8:  MOVFF  1D4,334
63AC:  MOVFF  1D3,333
63B0:  MOVFF  1D2,332
63B4:  MOVLB  0
63B6:  CALL   050A
63BA:  BTFSC  19.6
63BC:  BSF    FF2.6
63BE:  BTFSC  19.7
63C0:  BSF    FF2.7
63C2:  MOVFF  00,1D9
63C6:  MOVFF  01,1DA
63CA:  MOVFF  02,1DB
63CE:  MOVFF  03,1DC
63D2:  CLRF   19
63D4:  BTFSC  FF2.6
63D6:  BSF    19.6
63D8:  BCF    FF2.6
63DA:  BTFSC  FF2.7
63DC:  BSF    19.7
63DE:  BCF    FF2.7
63E0:  MOVLB  2
63E2:  CLRF   x16
63E4:  MOVFF  1D7,215
63E8:  MOVLB  0
63EA:  CALL   04D4
63EE:  BTFSC  19.6
63F0:  BSF    FF2.6
63F2:  BTFSC  19.7
63F4:  BSF    FF2.7
63F6:  BCF    FD8.1
63F8:  CLRF   19
63FA:  BTFSC  FF2.6
63FC:  BSF    19.6
63FE:  BCF    FF2.6
6400:  BTFSC  FF2.7
6402:  BSF    19.7
6404:  BCF    FF2.7
6406:  MOVFF  1DC,386
640A:  MOVFF  1DB,385
640E:  MOVFF  1DA,384
6412:  MOVFF  1D9,383
6416:  MOVFF  03,38A
641A:  MOVFF  02,389
641E:  MOVFF  01,388
6422:  MOVFF  00,387
6426:  CALL   0600
642A:  BTFSC  19.6
642C:  BSF    FF2.6
642E:  BTFSC  19.7
6430:  BSF    FF2.7
6432:  MOVFF  03,1D5
6436:  MOVFF  02,1D4
643A:  MOVFF  01,1D3
643E:  MOVFF  00,1D2
....................          } 
....................       } 
....................       else if (!skip) 
6442:  BRA    644E
6444:  MOVLB  1
6446:  BTFSC  xD6.0
6448:  BRA    644C
....................          break; 
644A:  BRA    6466
644C:  MOVLB  0
....................    } 
644E:  MOVLB  1
6450:  MOVF   xD8,W
6452:  INCF   xD8,F
6454:  CLRF   03
6456:  ADDWF  xCA,W
6458:  MOVWF  FE9
645A:  MOVF   xCB,W
645C:  ADDWFC 03,W
645E:  MOVWF  FEA
6460:  MOVFF  FEF,1D7
6464:  BRA    622A
....................  
....................    if (sign) 
6466:  BTFSS  xD6.1
6468:  BRA    64B6
646A:  CLRF   19
646C:  BTFSC  FF2.6
646E:  BSF    19.6
6470:  BCF    FF2.6
6472:  BTFSC  FF2.7
6474:  BSF    19.7
6476:  BCF    FF2.7
....................       result = -1*result; 
6478:  MOVLB  3
647A:  CLRF   x31
647C:  CLRF   x30
647E:  MOVLW  80
6480:  MOVWF  x2F
6482:  MOVLW  7F
6484:  MOVWF  x2E
6486:  MOVFF  1D5,335
648A:  MOVFF  1D4,334
648E:  MOVFF  1D3,333
6492:  MOVFF  1D2,332
6496:  MOVLB  0
6498:  CALL   050A
649C:  BTFSC  19.6
649E:  BSF    FF2.6
64A0:  BTFSC  19.7
64A2:  BSF    FF2.7
64A4:  MOVFF  03,1D5
64A8:  MOVFF  02,1D4
64AC:  MOVFF  01,1D3
64B0:  MOVFF  00,1D2
64B4:  MOVLB  1
....................        
....................    if(endptr) 
64B6:  MOVF   xCC,W
64B8:  IORWF  xCD,W
64BA:  BZ    64EA
....................    { 
....................       if (ptr) { 
64BC:  MOVF   xD8,F
64BE:  BZ    64D8
....................          ptr--; 
64C0:  DECF   xD8,F
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
64C2:  MOVFF  1CC,FE9
64C6:  MOVFF  1CD,FEA
64CA:  MOVF   xD8,W
64CC:  ADDWF  xCA,W
64CE:  MOVWF  FEF
64D0:  MOVLW  00
64D2:  ADDWFC xCB,W
64D4:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
64D6:  BRA    64EA
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
64D8:  MOVFF  1CC,FE9
64DC:  MOVFF  1CD,FEA
64E0:  MOVFF  1CB,FEC
64E4:  MOVF   FED,F
64E6:  MOVFF  1CA,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
64EA:  MOVFF  1D2,00
64EE:  MOVFF  1D3,01
64F2:  MOVFF  1D4,02
64F6:  MOVFF  1D5,03
.................... } 
64FA:  MOVLB  0
64FC:  RETLW  00
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................   
....................  
.................... #endif 
....................  
.................... #include "input.c"  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1() { 
....................    char digit; 
....................  
....................    digit = getc(); 
....................  
....................    putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           putc(c); 
....................           putc(' '); 
....................           putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... #if !defined(__PCD__) 
.................... signed int8 get_int() { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, 5); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int16 get_int() { 
....................   char s[5]; 
....................   signed int16 i; 
....................  
....................   get_string(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... signed int16 get_long() { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, 7); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int32 get_long() { 
....................   char s[7]; 
....................   signed int32 l; 
....................  
....................   get_string(s, 10); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... //Mi libreria del controlador Fuzzy 
.................... #include "PID.c" 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "PID.h" 
.................... #define PI FALSE 
.................... #define PD TRUE 
....................  
.................... BOOLEAN selected;  //true PD, false PI 
....................  
.................... #ifndef XFUZZY 
.................... #define XFUZZY 
.................... /*------------------------------------------------------*/ 
.................... /* Fuzzy Number                                         */ 
.................... /*------------------------------------------------------*/ 
....................  
....................  typedef struct { 
....................    double min; 
....................    double max; 
....................    double step; 
....................    double imp; 
....................    double also; 
....................    int length; 
....................    double* degree; 
....................    int inputlength; 
....................    double* input; 
....................  } FuzzyNumber; 
....................  
.................... #endif /* XFUZZY */ 
....................  
.................... #include "MFU.c" 
.................... /* 
.................... 					"Membership_Functions_and_Universe" 
.................... 			PARA CREAR EL UNIVERSO DE LA VARIABLE DE salida 
.................... 			Y LAS 5 FUNCIONES DE MEMBRESIA. 
.................... */ 
....................  
.................... typedef struct {double min,max,step;} Universo; 
....................  
.................... typedef struct {double a,b,c;} Conjunto; 
....................  
.................... #case 
.................... Universo PD_salida,PI_salida; 
.................... Conjunto NBu,NSu,Zu,PSu,PBu; 
.................... Conjunto NBdu,NSdu,Zdu,PSdu,PBdu; 
....................  
.................... /* 
.................... 	Para seleccionar la variante 'por defecto' llamar a la funcion 
.................... 	enviandole todos los parametros en 0. 
.................... */ 
....................  
.................... void guardar_cambios(Universo salida, BOOLEAN select) 
.................... { 
.................... 	if(select==PD) 
*
38EE:  MOVLB  2
38F0:  DECFSZ x03,W
38F2:  BRA    3926
.................... 	{ 
.................... 		PD_salida.min = salida.min; 
38F4:  MOVFF  1FA,3A
38F8:  MOVFF  1F9,39
38FC:  MOVFF  1F8,38
3900:  MOVFF  1F7,37
.................... 		PD_salida.max = salida.max; 
3904:  MOVFF  1FE,3E
3908:  MOVFF  1FD,3D
390C:  MOVFF  1FC,3C
3910:  MOVFF  1FB,3B
.................... 		PD_salida.step = salida.step; 
3914:  MOVFF  202,42
3918:  MOVFF  201,41
391C:  MOVFF  200,40
3920:  MOVFF  1FF,3F
.................... 	} 
.................... 	else 
3924:  BRA    3956
.................... 	{ 
.................... 		PI_salida.min = salida.min; 
3926:  MOVFF  1FA,46
392A:  MOVFF  1F9,45
392E:  MOVFF  1F8,44
3932:  MOVFF  1F7,43
.................... 		PI_salida.max = salida.max; 
3936:  MOVFF  1FE,4A
393A:  MOVFF  1FD,49
393E:  MOVFF  1FC,48
3942:  MOVFF  1FB,47
.................... 		PI_salida.step = salida.step; 
3946:  MOVFF  202,4E
394A:  MOVFF  201,4D
394E:  MOVFF  200,4C
3952:  MOVFF  1FF,4B
.................... 	} 
.................... } 
3956:  MOVLB  0
3958:  GOTO   3DE2 (RETURN)
....................  
.................... void definir_universo_salida(double min, double max, double step, BOOLEAN select)  
.................... { 
395C:  CLRF   19
395E:  BTFSC  FF2.6
3960:  BSF    19.6
3962:  BCF    FF2.6
3964:  BTFSC  FF2.7
3966:  BSF    19.7
3968:  BCF    FF2.7
.................... 	Universo salida; 
....................  
.................... 	if(min < max) 
396A:  MOVFF  1E1,382
396E:  MOVFF  1E0,381
3972:  MOVFF  1DF,380
3976:  MOVFF  1DE,37F
397A:  MOVFF  1E5,386
397E:  MOVFF  1E4,385
3982:  MOVFF  1E3,384
3986:  MOVFF  1E2,383
398A:  CALL   0878
398E:  BTFSC  19.6
3990:  BSF    FF2.6
3992:  BTFSC  19.7
3994:  BSF    FF2.7
3996:  BTFSS  FD8.0
3998:  BRA    3D5A
399A:  CLRF   19
399C:  BTFSC  FF2.6
399E:  BSF    19.6
39A0:  BCF    FF2.6
39A2:  BTFSC  FF2.7
39A4:  BSF    19.7
39A6:  BCF    FF2.7
.................... 	{ 
.................... 		salida.min = (min > 0 ? 0 : (min < -1023 ? -1023 : min)); 
39A8:  MOVLB  3
39AA:  CLRF   x82
39AC:  CLRF   x81
39AE:  CLRF   x80
39B0:  CLRF   x7F
39B2:  MOVFF  1E1,386
39B6:  MOVFF  1E0,385
39BA:  MOVFF  1DF,384
39BE:  MOVFF  1DE,383
39C2:  MOVLB  0
39C4:  CALL   0878
39C8:  BTFSC  19.6
39CA:  BSF    FF2.6
39CC:  BTFSC  19.7
39CE:  BSF    FF2.7
39D0:  BNC   39DC
39D2:  CLRF   00
39D4:  CLRF   01
39D6:  CLRF   02
39D8:  CLRF   03
39DA:  BRA    3A3A
39DC:  CLRF   19
39DE:  BTFSC  FF2.6
39E0:  BSF    19.6
39E2:  BCF    FF2.6
39E4:  BTFSC  FF2.7
39E6:  BSF    19.7
39E8:  BCF    FF2.7
39EA:  MOVFF  1E1,382
39EE:  MOVFF  1E0,381
39F2:  MOVFF  1DF,380
39F6:  MOVFF  1DE,37F
39FA:  MOVLB  3
39FC:  CLRF   x86
39FE:  MOVLW  C0
3A00:  MOVWF  x85
3A02:  MOVLW  FF
3A04:  MOVWF  x84
3A06:  MOVLW  88
3A08:  MOVWF  x83
3A0A:  MOVLB  0
3A0C:  CALL   0878
3A10:  BTFSC  19.6
3A12:  BSF    FF2.6
3A14:  BTFSC  19.7
3A16:  BSF    FF2.7
3A18:  BNC   3A2A
3A1A:  MOVLW  88
3A1C:  MOVWF  00
3A1E:  MOVLW  FF
3A20:  MOVWF  01
3A22:  MOVLW  C0
3A24:  MOVWF  02
3A26:  CLRF   03
3A28:  BRA    3A3A
3A2A:  MOVFF  1DE,00
3A2E:  MOVFF  1DF,01
3A32:  MOVFF  1E0,02
3A36:  MOVFF  1E1,03
3A3A:  MOVFF  03,1EE
3A3E:  MOVFF  02,1ED
3A42:  MOVFF  01,1EC
3A46:  MOVFF  00,1EB
3A4A:  CLRF   19
3A4C:  BTFSC  FF2.6
3A4E:  BSF    19.6
3A50:  BCF    FF2.6
3A52:  BTFSC  FF2.7
3A54:  BSF    19.7
3A56:  BCF    FF2.7
.................... 		salida.max = (max < 0 ? 0 : (max > 1023 ? 1023 : max)); 
3A58:  MOVFF  1E5,382
3A5C:  MOVFF  1E4,381
3A60:  MOVFF  1E3,380
3A64:  MOVFF  1E2,37F
3A68:  MOVLB  3
3A6A:  CLRF   x86
3A6C:  CLRF   x85
3A6E:  CLRF   x84
3A70:  CLRF   x83
3A72:  MOVLB  0
3A74:  CALL   0878
3A78:  BTFSC  19.6
3A7A:  BSF    FF2.6
3A7C:  BTFSC  19.7
3A7E:  BSF    FF2.7
3A80:  BNC   3A8C
3A82:  CLRF   00
3A84:  CLRF   01
3A86:  CLRF   02
3A88:  CLRF   03
3A8A:  BRA    3AEA
3A8C:  CLRF   19
3A8E:  BTFSC  FF2.6
3A90:  BSF    19.6
3A92:  BCF    FF2.6
3A94:  BTFSC  FF2.7
3A96:  BSF    19.7
3A98:  BCF    FF2.7
3A9A:  MOVLB  3
3A9C:  CLRF   x82
3A9E:  MOVLW  C0
3AA0:  MOVWF  x81
3AA2:  MOVLW  7F
3AA4:  MOVWF  x80
3AA6:  MOVLW  88
3AA8:  MOVWF  x7F
3AAA:  MOVFF  1E5,386
3AAE:  MOVFF  1E4,385
3AB2:  MOVFF  1E3,384
3AB6:  MOVFF  1E2,383
3ABA:  MOVLB  0
3ABC:  CALL   0878
3AC0:  BTFSC  19.6
3AC2:  BSF    FF2.6
3AC4:  BTFSC  19.7
3AC6:  BSF    FF2.7
3AC8:  BNC   3ADA
3ACA:  MOVLW  88
3ACC:  MOVWF  00
3ACE:  MOVLW  7F
3AD0:  MOVWF  01
3AD2:  MOVLW  C0
3AD4:  MOVWF  02
3AD6:  CLRF   03
3AD8:  BRA    3AEA
3ADA:  MOVFF  1E2,00
3ADE:  MOVFF  1E3,01
3AE2:  MOVFF  1E4,02
3AE6:  MOVFF  1E5,03
3AEA:  MOVFF  03,1F2
3AEE:  MOVFF  02,1F1
3AF2:  MOVFF  01,1F0
3AF6:  MOVFF  00,1EF
3AFA:  CLRF   19
3AFC:  BTFSC  FF2.6
3AFE:  BSF    19.6
3B00:  BCF    FF2.6
3B02:  BTFSC  FF2.7
3B04:  BSF    19.7
3B06:  BCF    FF2.7
.................... 		salida.step = (step < 2 ? (max + fabs(min))/9  
.................... 											: (step > (max + fabs(min))/2 ?  
.................... 											(max + fabs(min))/2 : step)); 
3B08:  MOVFF  1E9,382
3B0C:  MOVFF  1E8,381
3B10:  MOVFF  1E7,380
3B14:  MOVFF  1E6,37F
3B18:  MOVLB  3
3B1A:  CLRF   x86
3B1C:  CLRF   x85
3B1E:  CLRF   x84
3B20:  MOVLW  80
3B22:  MOVWF  x83
3B24:  MOVLB  0
3B26:  CALL   0878
3B2A:  BTFSC  19.6
3B2C:  BSF    FF2.6
3B2E:  BTFSC  19.7
3B30:  BSF    FF2.7
3B32:  BNC   3BCE
3B34:  MOVFF  1DE,00
3B38:  MOVFF  1DF,01
3B3C:  MOVFF  1E0,02
3B40:  MOVFF  1E1,03
3B44:  BCF    01.7
3B46:  BCF    FD8.1
3B48:  CLRF   19
3B4A:  BTFSC  FF2.6
3B4C:  BSF    19.6
3B4E:  BCF    FF2.6
3B50:  BTFSC  FF2.7
3B52:  BSF    19.7
3B54:  BCF    FF2.7
3B56:  MOVFF  1E5,386
3B5A:  MOVFF  1E4,385
3B5E:  MOVFF  1E3,384
3B62:  MOVFF  1E2,383
3B66:  MOVFF  1E1,38A
3B6A:  MOVFF  1E0,389
3B6E:  MOVFF  01,388
3B72:  MOVFF  1DE,387
3B76:  CALL   0600
3B7A:  BTFSC  19.6
3B7C:  BSF    FF2.6
3B7E:  BTFSC  19.7
3B80:  BSF    FF2.7
3B82:  MOVFF  00,1F7
3B86:  MOVFF  01,1F8
3B8A:  MOVFF  02,1F9
3B8E:  MOVFF  03,1FA
3B92:  CLRF   19
3B94:  BTFSC  FF2.6
3B96:  BSF    19.6
3B98:  BCF    FF2.6
3B9A:  BTFSC  FF2.7
3B9C:  BSF    19.7
3B9E:  BCF    FF2.7
3BA0:  MOVFF  03,386
3BA4:  MOVFF  02,385
3BA8:  MOVFF  01,384
3BAC:  MOVFF  00,383
3BB0:  MOVLB  3
3BB2:  CLRF   x8A
3BB4:  CLRF   x89
3BB6:  MOVLW  10
3BB8:  MOVWF  x88
3BBA:  MOVLW  82
3BBC:  MOVWF  x87
3BBE:  MOVLB  0
3BC0:  CALL   0376
3BC4:  BTFSC  19.6
3BC6:  BSF    FF2.6
3BC8:  BTFSC  19.7
3BCA:  BSF    FF2.7
3BCC:  BRA    3D48
3BCE:  MOVFF  1DE,00
3BD2:  MOVFF  1DF,01
3BD6:  MOVFF  1E0,02
3BDA:  MOVFF  1E1,03
3BDE:  BCF    01.7
3BE0:  BCF    FD8.1
3BE2:  CLRF   19
3BE4:  BTFSC  FF2.6
3BE6:  BSF    19.6
3BE8:  BCF    FF2.6
3BEA:  BTFSC  FF2.7
3BEC:  BSF    19.7
3BEE:  BCF    FF2.7
3BF0:  MOVFF  1E5,386
3BF4:  MOVFF  1E4,385
3BF8:  MOVFF  1E3,384
3BFC:  MOVFF  1E2,383
3C00:  MOVFF  1E1,38A
3C04:  MOVFF  1E0,389
3C08:  MOVFF  01,388
3C0C:  MOVFF  1DE,387
3C10:  CALL   0600
3C14:  BTFSC  19.6
3C16:  BSF    FF2.6
3C18:  BTFSC  19.7
3C1A:  BSF    FF2.7
3C1C:  MOVFF  00,1F7
3C20:  MOVFF  01,1F8
3C24:  MOVFF  02,1F9
3C28:  MOVFF  03,1FA
3C2C:  CLRF   19
3C2E:  BTFSC  FF2.6
3C30:  BSF    19.6
3C32:  BCF    FF2.6
3C34:  BTFSC  FF2.7
3C36:  BSF    19.7
3C38:  BCF    FF2.7
3C3A:  MOVFF  03,386
3C3E:  MOVFF  02,385
3C42:  MOVFF  01,384
3C46:  MOVFF  00,383
3C4A:  MOVLB  3
3C4C:  CLRF   x8A
3C4E:  CLRF   x89
3C50:  CLRF   x88
3C52:  MOVLW  80
3C54:  MOVWF  x87
3C56:  MOVLB  0
3C58:  CALL   0376
3C5C:  BTFSC  19.6
3C5E:  BSF    FF2.6
3C60:  BTFSC  19.7
3C62:  BSF    FF2.7
3C64:  CLRF   19
3C66:  BTFSC  FF2.6
3C68:  BSF    19.6
3C6A:  BCF    FF2.6
3C6C:  BTFSC  FF2.7
3C6E:  BSF    19.7
3C70:  BCF    FF2.7
3C72:  MOVFF  03,382
3C76:  MOVFF  02,381
3C7A:  MOVFF  01,380
3C7E:  MOVFF  00,37F
3C82:  MOVFF  1E9,386
3C86:  MOVFF  1E8,385
3C8A:  MOVFF  1E7,384
3C8E:  MOVFF  1E6,383
3C92:  CALL   0878
3C96:  BTFSC  19.6
3C98:  BSF    FF2.6
3C9A:  BTFSC  19.7
3C9C:  BSF    FF2.7
3C9E:  BNC   3D38
3CA0:  MOVFF  1DE,00
3CA4:  MOVFF  1DF,01
3CA8:  MOVFF  1E0,02
3CAC:  MOVFF  1E1,03
3CB0:  BCF    01.7
3CB2:  BCF    FD8.1
3CB4:  CLRF   19
3CB6:  BTFSC  FF2.6
3CB8:  BSF    19.6
3CBA:  BCF    FF2.6
3CBC:  BTFSC  FF2.7
3CBE:  BSF    19.7
3CC0:  BCF    FF2.7
3CC2:  MOVFF  1E5,386
3CC6:  MOVFF  1E4,385
3CCA:  MOVFF  1E3,384
3CCE:  MOVFF  1E2,383
3CD2:  MOVFF  1E1,38A
3CD6:  MOVFF  1E0,389
3CDA:  MOVFF  01,388
3CDE:  MOVFF  1DE,387
3CE2:  CALL   0600
3CE6:  BTFSC  19.6
3CE8:  BSF    FF2.6
3CEA:  BTFSC  19.7
3CEC:  BSF    FF2.7
3CEE:  MOVFF  00,1F7
3CF2:  MOVFF  01,1F8
3CF6:  MOVFF  02,1F9
3CFA:  MOVFF  03,1FA
3CFE:  CLRF   19
3D00:  BTFSC  FF2.6
3D02:  BSF    19.6
3D04:  BCF    FF2.6
3D06:  BTFSC  FF2.7
3D08:  BSF    19.7
3D0A:  BCF    FF2.7
3D0C:  MOVFF  03,386
3D10:  MOVFF  02,385
3D14:  MOVFF  01,384
3D18:  MOVFF  00,383
3D1C:  MOVLB  3
3D1E:  CLRF   x8A
3D20:  CLRF   x89
3D22:  CLRF   x88
3D24:  MOVLW  80
3D26:  MOVWF  x87
3D28:  MOVLB  0
3D2A:  CALL   0376
3D2E:  BTFSC  19.6
3D30:  BSF    FF2.6
3D32:  BTFSC  19.7
3D34:  BSF    FF2.7
3D36:  BRA    3D48
3D38:  MOVFF  1E6,00
3D3C:  MOVFF  1E7,01
3D40:  MOVFF  1E8,02
3D44:  MOVFF  1E9,03
3D48:  MOVFF  03,1F6
3D4C:  MOVFF  02,1F5
3D50:  MOVFF  01,1F4
3D54:  MOVFF  00,1F3
.................... 	} 
.................... 	else  //por defecto 
3D58:  BRA    3DAC
.................... 	{ 
.................... 		if(select==PD) 
3D5A:  MOVLB  1
3D5C:  DECFSZ xEA,W
3D5E:  BRA    3D86
.................... 		{ 
.................... 			salida.min = -600; //-100 
3D60:  CLRF   xEE
3D62:  CLRF   xED
3D64:  MOVLW  96
3D66:  MOVWF  xEC
3D68:  MOVLW  88
3D6A:  MOVWF  xEB
.................... 			salida.max = 600; //100 
3D6C:  CLRF   xF2
3D6E:  CLRF   xF1
3D70:  MOVLW  16
3D72:  MOVWF  xF0
3D74:  MOVLW  88
3D76:  MOVWF  xEF
.................... 			salida.step = 300; // 200/9=22.22222222222 (cardinality=10) 
3D78:  CLRF   xF6
3D7A:  CLRF   xF5
3D7C:  MOVLW  16
3D7E:  MOVWF  xF4
3D80:  MOVLW  87
3D82:  MOVWF  xF3
.................... 		} 
.................... 		else 
3D84:  BRA    3DAA
.................... 		{ 
.................... 			salida.min = -20; 
3D86:  CLRF   xEE
3D88:  CLRF   xED
3D8A:  MOVLW  A0
3D8C:  MOVWF  xEC
3D8E:  MOVLW  83
3D90:  MOVWF  xEB
.................... 			salida.max = 20; 
3D92:  CLRF   xF2
3D94:  CLRF   xF1
3D96:  MOVLW  20
3D98:  MOVWF  xF0
3D9A:  MOVLW  83
3D9C:  MOVWF  xEF
.................... 			salida.step = 10; // 40/9=4.444444444444445 (cardinality=10) 
3D9E:  CLRF   xF6
3DA0:  CLRF   xF5
3DA2:  MOVLW  20
3DA4:  MOVWF  xF4
3DA6:  MOVLW  82
3DA8:  MOVWF  xF3
3DAA:  MOVLB  0
.................... 		} 
.................... 	} 
.................... 	 
.................... 	guardar_cambios(salida, select); 
3DAC:  MOVFF  1EB,1F7
3DB0:  MOVFF  1EC,1F8
3DB4:  MOVFF  1ED,1F9
3DB8:  MOVFF  1EE,1FA
3DBC:  MOVFF  1EF,1FB
3DC0:  MOVFF  1F0,1FC
3DC4:  MOVFF  1F1,1FD
3DC8:  MOVFF  1F2,1FE
3DCC:  MOVFF  1F3,1FF
3DD0:  MOVFF  1F4,200
3DD4:  MOVFF  1F5,201
3DD8:  MOVFF  1F6,202
3DDC:  MOVFF  1EA,203
3DE0:  BRA    38EE
.................... } 
3DE2:  RETLW  00
....................  
.................... /* 
.................... 	Si se desean todos los conjuntos iguales y que corten en 0.5 
.................... 	llamar a las funciones con los parametros en 0. 
.................... */ 
....................  
.................... void definir_rango_salida_NBu_NBdu(double a, double b, double c, Universo salida, BOOLEAN select) 
.................... { 
3DE4:  MOVFF  1DE,00
3DE8:  MOVFF  1DF,01
3DEC:  MOVFF  1E0,02
3DF0:  MOVFF  1E1,03
3DF4:  BCF    01.7
3DF6:  BCF    FD8.1
3DF8:  CLRF   19
3DFA:  BTFSC  FF2.6
3DFC:  BSF    19.6
3DFE:  BCF    FF2.6
3E00:  BTFSC  FF2.7
3E02:  BSF    19.7
3E04:  BCF    FF2.7
3E06:  MOVFF  1E5,386
3E0A:  MOVFF  1E4,385
3E0E:  MOVFF  1E3,384
3E12:  MOVFF  1E2,383
3E16:  MOVFF  1E1,38A
3E1A:  MOVFF  1E0,389
3E1E:  MOVFF  01,388
3E22:  MOVFF  1DE,387
3E26:  CALL   0600
3E2A:  BTFSC  19.6
3E2C:  BSF    FF2.6
3E2E:  BTFSC  19.7
3E30:  BSF    FF2.7
*
3E7A:  MOVFF  03,1EE
3E7E:  MOVFF  02,1ED
3E82:  MOVFF  01,1EC
3E86:  MOVFF  00,1EB
.................... 	double intervalo = (salida.max + fabs(salida.min))/4;  //4 porque son 5 conjuntos 
....................  
.................... /*	if(a < b && b < c) 
.................... 	{ 
.................... 		NBu.a = a; 
.................... 		NBu.b = b; 
.................... 		NBu.c = c; 
.................... 	} 
.................... 	else //por defecto 
.................... 	{*/ 
.................... 	if(select==PD) 
3E8A:  MOVLB  1
3E8C:  DECFSZ xEA,W
3E8E:  BRA    3F7A
.................... 	{ 
.................... 		NBu.a = salida.min - intervalo; 
3E90:  BSF    FD8.1
3E92:  CLRF   19
3E94:  BTFSC  FF2.6
3E96:  BSF    19.6
3E98:  BCF    FF2.6
3E9A:  BTFSC  FF2.7
3E9C:  BSF    19.7
3E9E:  BCF    FF2.7
3EA0:  MOVFF  1E1,386
3EA4:  MOVFF  1E0,385
3EA8:  MOVFF  1DF,384
3EAC:  MOVFF  1DE,383
3EB0:  MOVFF  1EE,38A
3EB4:  MOVFF  1ED,389
3EB8:  MOVFF  1EC,388
3EBC:  MOVFF  1EB,387
3EC0:  MOVLB  0
3EC2:  CALL   0600
3EC6:  BTFSC  19.6
3EC8:  BSF    FF2.6
3ECA:  BTFSC  19.7
3ECC:  BSF    FF2.7
3ECE:  MOVFF  03,52
3ED2:  MOVFF  02,51
3ED6:  MOVFF  01,50
3EDA:  MOVFF  00,4F
.................... 		NBu.b = NBu.a + intervalo; 
3EDE:  BCF    FD8.1
3EE0:  CLRF   19
3EE2:  BTFSC  FF2.6
3EE4:  BSF    19.6
3EE6:  BCF    FF2.6
3EE8:  BTFSC  FF2.7
3EEA:  BSF    19.7
3EEC:  BCF    FF2.7
3EEE:  MOVFF  52,386
3EF2:  MOVFF  51,385
3EF6:  MOVFF  50,384
3EFA:  MOVFF  4F,383
3EFE:  MOVFF  1EE,38A
3F02:  MOVFF  1ED,389
3F06:  MOVFF  1EC,388
3F0A:  MOVFF  1EB,387
3F0E:  CALL   0600
3F12:  BTFSC  19.6
3F14:  BSF    FF2.6
3F16:  BTFSC  19.7
3F18:  BSF    FF2.7
3F1A:  MOVFF  03,56
3F1E:  MOVFF  02,55
3F22:  MOVFF  01,54
3F26:  MOVFF  00,53
.................... 		NBu.c = NBu.b + intervalo; 
3F2A:  BCF    FD8.1
3F2C:  CLRF   19
3F2E:  BTFSC  FF2.6
3F30:  BSF    19.6
3F32:  BCF    FF2.6
3F34:  BTFSC  FF2.7
3F36:  BSF    19.7
3F38:  BCF    FF2.7
3F3A:  MOVFF  56,386
3F3E:  MOVFF  55,385
3F42:  MOVFF  54,384
3F46:  MOVFF  53,383
3F4A:  MOVFF  1EE,38A
3F4E:  MOVFF  1ED,389
3F52:  MOVFF  1EC,388
3F56:  MOVFF  1EB,387
3F5A:  CALL   0600
3F5E:  BTFSC  19.6
3F60:  BSF    FF2.6
3F62:  BTFSC  19.7
3F64:  BSF    FF2.7
3F66:  MOVFF  03,5A
3F6A:  MOVFF  02,59
3F6E:  MOVFF  01,58
3F72:  MOVFF  00,57
.................... 	} 
.................... 	else 
3F76:  BRA    4060
3F78:  MOVLB  1
.................... 	{ 
.................... 		NBdu.a = salida.min - intervalo; 
3F7A:  BSF    FD8.1
3F7C:  CLRF   19
3F7E:  BTFSC  FF2.6
3F80:  BSF    19.6
3F82:  BCF    FF2.6
3F84:  BTFSC  FF2.7
3F86:  BSF    19.7
3F88:  BCF    FF2.7
3F8A:  MOVFF  1E1,386
3F8E:  MOVFF  1E0,385
3F92:  MOVFF  1DF,384
3F96:  MOVFF  1DE,383
3F9A:  MOVFF  1EE,38A
3F9E:  MOVFF  1ED,389
3FA2:  MOVFF  1EC,388
3FA6:  MOVFF  1EB,387
3FAA:  MOVLB  0
3FAC:  CALL   0600
3FB0:  BTFSC  19.6
3FB2:  BSF    FF2.6
3FB4:  BTFSC  19.7
3FB6:  BSF    FF2.7
3FB8:  MOVFF  03,8E
3FBC:  MOVFF  02,8D
3FC0:  MOVFF  01,8C
3FC4:  MOVFF  00,8B
.................... 		NBdu.b = NBdu.a + intervalo; 
3FC8:  BCF    FD8.1
3FCA:  CLRF   19
3FCC:  BTFSC  FF2.6
3FCE:  BSF    19.6
3FD0:  BCF    FF2.6
3FD2:  BTFSC  FF2.7
3FD4:  BSF    19.7
3FD6:  BCF    FF2.7
3FD8:  MOVFF  8E,386
3FDC:  MOVFF  8D,385
3FE0:  MOVFF  8C,384
3FE4:  MOVFF  8B,383
3FE8:  MOVFF  1EE,38A
3FEC:  MOVFF  1ED,389
3FF0:  MOVFF  1EC,388
3FF4:  MOVFF  1EB,387
3FF8:  CALL   0600
3FFC:  BTFSC  19.6
3FFE:  BSF    FF2.6
4000:  BTFSC  19.7
4002:  BSF    FF2.7
4004:  MOVFF  03,92
4008:  MOVFF  02,91
400C:  MOVFF  01,90
4010:  MOVFF  00,8F
.................... 		NBdu.c = NBdu.b + intervalo; 
4014:  BCF    FD8.1
4016:  CLRF   19
4018:  BTFSC  FF2.6
401A:  BSF    19.6
401C:  BCF    FF2.6
401E:  BTFSC  FF2.7
4020:  BSF    19.7
4022:  BCF    FF2.7
4024:  MOVFF  92,386
4028:  MOVFF  91,385
402C:  MOVFF  90,384
4030:  MOVFF  8F,383
4034:  MOVFF  1EE,38A
4038:  MOVFF  1ED,389
403C:  MOVFF  1EC,388
4040:  MOVFF  1EB,387
4044:  CALL   0600
4048:  BTFSC  19.6
404A:  BSF    FF2.6
404C:  BTFSC  19.7
404E:  BSF    FF2.7
4050:  MOVFF  03,96
4054:  MOVFF  02,95
4058:  MOVFF  01,94
405C:  MOVFF  00,93
.................... 	} 
.................... //	} 
.................... } 
4060:  RETLW  00
....................  
.................... void definir_rango_salida_NSu_NSdu(double a, double b, double c, Universo salida, BOOLEAN select) 
.................... { 
4062:  MOVFF  1DE,00
4066:  MOVFF  1DF,01
406A:  MOVFF  1E0,02
406E:  MOVFF  1E1,03
4072:  BCF    01.7
4074:  BCF    FD8.1
4076:  CLRF   19
4078:  BTFSC  FF2.6
407A:  BSF    19.6
407C:  BCF    FF2.6
407E:  BTFSC  FF2.7
4080:  BSF    19.7
4082:  BCF    FF2.7
4084:  MOVFF  1E5,386
4088:  MOVFF  1E4,385
408C:  MOVFF  1E3,384
4090:  MOVFF  1E2,383
4094:  MOVFF  1E1,38A
4098:  MOVFF  1E0,389
409C:  MOVFF  01,388
40A0:  MOVFF  1DE,387
40A4:  CALL   0600
40A8:  BTFSC  19.6
40AA:  BSF    FF2.6
40AC:  BTFSC  19.7
40AE:  BSF    FF2.7
*
40F8:  MOVFF  03,1EE
40FC:  MOVFF  02,1ED
4100:  MOVFF  01,1EC
4104:  MOVFF  00,1EB
.................... 	double intervalo = (salida.max + fabs(salida.min))/4;  //4 porque son 5 conjuntos 
....................  
.................... /*	if(a < b && b < c) 
.................... 	{ 
.................... 		NSu.a = a; 
.................... 		NSu.b = b; 
.................... 		NSu.c = c; 
.................... 	} 
.................... 	else //por defecto 
.................... 	{*/ 
.................... 	if(select==PD) 
4108:  MOVLB  1
410A:  DECFSZ xEA,W
410C:  BRA    41BC
.................... 	{ 
.................... 		NSu.a = NBu.b; 
410E:  MOVFF  56,5E
4112:  MOVFF  55,5D
4116:  MOVFF  54,5C
411A:  MOVFF  53,5B
.................... 		NSu.b = NSu.a + intervalo; 
411E:  BCF    FD8.1
4120:  CLRF   19
4122:  BTFSC  FF2.6
4124:  BSF    19.6
4126:  BCF    FF2.6
4128:  BTFSC  FF2.7
412A:  BSF    19.7
412C:  BCF    FF2.7
412E:  MOVFF  5E,386
4132:  MOVFF  5D,385
4136:  MOVFF  5C,384
413A:  MOVFF  5B,383
413E:  MOVFF  1EE,38A
4142:  MOVFF  1ED,389
4146:  MOVFF  1EC,388
414A:  MOVFF  1EB,387
414E:  MOVLB  0
4150:  CALL   0600
4154:  BTFSC  19.6
4156:  BSF    FF2.6
4158:  BTFSC  19.7
415A:  BSF    FF2.7
415C:  MOVFF  03,62
4160:  MOVFF  02,61
4164:  MOVFF  01,60
4168:  MOVFF  00,5F
.................... 		NSu.c = NSu.b + intervalo; 
416C:  BCF    FD8.1
416E:  CLRF   19
4170:  BTFSC  FF2.6
4172:  BSF    19.6
4174:  BCF    FF2.6
4176:  BTFSC  FF2.7
4178:  BSF    19.7
417A:  BCF    FF2.7
417C:  MOVFF  62,386
4180:  MOVFF  61,385
4184:  MOVFF  60,384
4188:  MOVFF  5F,383
418C:  MOVFF  1EE,38A
4190:  MOVFF  1ED,389
4194:  MOVFF  1EC,388
4198:  MOVFF  1EB,387
419C:  CALL   0600
41A0:  BTFSC  19.6
41A2:  BSF    FF2.6
41A4:  BTFSC  19.7
41A6:  BSF    FF2.7
41A8:  MOVFF  03,66
41AC:  MOVFF  02,65
41B0:  MOVFF  01,64
41B4:  MOVFF  00,63
.................... 	} 
.................... 	else 
41B8:  BRA    4266
41BA:  MOVLB  1
.................... 	{ 
.................... 		NSdu.a = NBdu.b; 
41BC:  MOVFF  92,9A
41C0:  MOVFF  91,99
41C4:  MOVFF  90,98
41C8:  MOVFF  8F,97
.................... 		NSdu.b = NSdu.a + intervalo; 
41CC:  BCF    FD8.1
41CE:  CLRF   19
41D0:  BTFSC  FF2.6
41D2:  BSF    19.6
41D4:  BCF    FF2.6
41D6:  BTFSC  FF2.7
41D8:  BSF    19.7
41DA:  BCF    FF2.7
41DC:  MOVFF  9A,386
41E0:  MOVFF  99,385
41E4:  MOVFF  98,384
41E8:  MOVFF  97,383
41EC:  MOVFF  1EE,38A
41F0:  MOVFF  1ED,389
41F4:  MOVFF  1EC,388
41F8:  MOVFF  1EB,387
41FC:  MOVLB  0
41FE:  CALL   0600
4202:  BTFSC  19.6
4204:  BSF    FF2.6
4206:  BTFSC  19.7
4208:  BSF    FF2.7
420A:  MOVFF  03,9E
420E:  MOVFF  02,9D
4212:  MOVFF  01,9C
4216:  MOVFF  00,9B
.................... 		NSdu.c = NSdu.b + intervalo; 
421A:  BCF    FD8.1
421C:  CLRF   19
421E:  BTFSC  FF2.6
4220:  BSF    19.6
4222:  BCF    FF2.6
4224:  BTFSC  FF2.7
4226:  BSF    19.7
4228:  BCF    FF2.7
422A:  MOVFF  9E,386
422E:  MOVFF  9D,385
4232:  MOVFF  9C,384
4236:  MOVFF  9B,383
423A:  MOVFF  1EE,38A
423E:  MOVFF  1ED,389
4242:  MOVFF  1EC,388
4246:  MOVFF  1EB,387
424A:  CALL   0600
424E:  BTFSC  19.6
4250:  BSF    FF2.6
4252:  BTFSC  19.7
4254:  BSF    FF2.7
4256:  MOVFF  03,A2
425A:  MOVFF  02,A1
425E:  MOVFF  01,A0
4262:  MOVFF  00,9F
.................... 	} 
.................... //	} 
.................... } 
4266:  RETLW  00
....................  
.................... void definir_rango_salida_Zu_Zdu(double a, double b, double c, Universo salida, BOOLEAN select) 
.................... { 
4268:  MOVFF  1DE,00
426C:  MOVFF  1DF,01
4270:  MOVFF  1E0,02
4274:  MOVFF  1E1,03
4278:  BCF    01.7
427A:  BCF    FD8.1
427C:  CLRF   19
427E:  BTFSC  FF2.6
4280:  BSF    19.6
4282:  BCF    FF2.6
4284:  BTFSC  FF2.7
4286:  BSF    19.7
4288:  BCF    FF2.7
428A:  MOVFF  1E5,386
428E:  MOVFF  1E4,385
4292:  MOVFF  1E3,384
4296:  MOVFF  1E2,383
429A:  MOVFF  1E1,38A
429E:  MOVFF  1E0,389
42A2:  MOVFF  01,388
42A6:  MOVFF  1DE,387
42AA:  CALL   0600
42AE:  BTFSC  19.6
42B0:  BSF    FF2.6
42B2:  BTFSC  19.7
42B4:  BSF    FF2.7
*
42FE:  MOVFF  03,1EE
4302:  MOVFF  02,1ED
4306:  MOVFF  01,1EC
430A:  MOVFF  00,1EB
.................... 	double intervalo = (salida.max + fabs(salida.min))/4;  //4 porque son 5 conjuntos 
....................  
.................... /*	if(a < b && b < c) 
.................... 	{ 
.................... 		Zu.a = a; 
.................... 		Zu.b = b; 
.................... 		Zu.c = c; 
.................... 	} 
.................... 	else //por defecto 
.................... 	{*/ 
.................... 	if(select==PD) 
430E:  MOVLB  1
4310:  DECFSZ xEA,W
4312:  BRA    43C2
.................... 	{ 
.................... 		Zu.a = NSu.b; 
4314:  MOVFF  62,6A
4318:  MOVFF  61,69
431C:  MOVFF  60,68
4320:  MOVFF  5F,67
.................... 		Zu.b = Zu.a + intervalo; 
4324:  BCF    FD8.1
4326:  CLRF   19
4328:  BTFSC  FF2.6
432A:  BSF    19.6
432C:  BCF    FF2.6
432E:  BTFSC  FF2.7
4330:  BSF    19.7
4332:  BCF    FF2.7
4334:  MOVFF  6A,386
4338:  MOVFF  69,385
433C:  MOVFF  68,384
4340:  MOVFF  67,383
4344:  MOVFF  1EE,38A
4348:  MOVFF  1ED,389
434C:  MOVFF  1EC,388
4350:  MOVFF  1EB,387
4354:  MOVLB  0
4356:  CALL   0600
435A:  BTFSC  19.6
435C:  BSF    FF2.6
435E:  BTFSC  19.7
4360:  BSF    FF2.7
4362:  MOVFF  03,6E
4366:  MOVFF  02,6D
436A:  MOVFF  01,6C
436E:  MOVFF  00,6B
.................... 		Zu.c = Zu.b + intervalo; 
4372:  BCF    FD8.1
4374:  CLRF   19
4376:  BTFSC  FF2.6
4378:  BSF    19.6
437A:  BCF    FF2.6
437C:  BTFSC  FF2.7
437E:  BSF    19.7
4380:  BCF    FF2.7
4382:  MOVFF  6E,386
4386:  MOVFF  6D,385
438A:  MOVFF  6C,384
438E:  MOVFF  6B,383
4392:  MOVFF  1EE,38A
4396:  MOVFF  1ED,389
439A:  MOVFF  1EC,388
439E:  MOVFF  1EB,387
43A2:  CALL   0600
43A6:  BTFSC  19.6
43A8:  BSF    FF2.6
43AA:  BTFSC  19.7
43AC:  BSF    FF2.7
43AE:  MOVFF  03,72
43B2:  MOVFF  02,71
43B6:  MOVFF  01,70
43BA:  MOVFF  00,6F
.................... 	} 
.................... 	else 
43BE:  BRA    446C
43C0:  MOVLB  1
.................... 	{ 
.................... 		Zdu.a = NSdu.b; 
43C2:  MOVFF  9E,A6
43C6:  MOVFF  9D,A5
43CA:  MOVFF  9C,A4
43CE:  MOVFF  9B,A3
.................... 		Zdu.b = Zdu.a + intervalo; 
43D2:  BCF    FD8.1
43D4:  CLRF   19
43D6:  BTFSC  FF2.6
43D8:  BSF    19.6
43DA:  BCF    FF2.6
43DC:  BTFSC  FF2.7
43DE:  BSF    19.7
43E0:  BCF    FF2.7
43E2:  MOVFF  A6,386
43E6:  MOVFF  A5,385
43EA:  MOVFF  A4,384
43EE:  MOVFF  A3,383
43F2:  MOVFF  1EE,38A
43F6:  MOVFF  1ED,389
43FA:  MOVFF  1EC,388
43FE:  MOVFF  1EB,387
4402:  MOVLB  0
4404:  CALL   0600
4408:  BTFSC  19.6
440A:  BSF    FF2.6
440C:  BTFSC  19.7
440E:  BSF    FF2.7
4410:  MOVFF  03,AA
4414:  MOVFF  02,A9
4418:  MOVFF  01,A8
441C:  MOVFF  00,A7
.................... 		Zdu.c = Zdu.b + intervalo; 
4420:  BCF    FD8.1
4422:  CLRF   19
4424:  BTFSC  FF2.6
4426:  BSF    19.6
4428:  BCF    FF2.6
442A:  BTFSC  FF2.7
442C:  BSF    19.7
442E:  BCF    FF2.7
4430:  MOVFF  AA,386
4434:  MOVFF  A9,385
4438:  MOVFF  A8,384
443C:  MOVFF  A7,383
4440:  MOVFF  1EE,38A
4444:  MOVFF  1ED,389
4448:  MOVFF  1EC,388
444C:  MOVFF  1EB,387
4450:  CALL   0600
4454:  BTFSC  19.6
4456:  BSF    FF2.6
4458:  BTFSC  19.7
445A:  BSF    FF2.7
445C:  MOVFF  03,AE
4460:  MOVFF  02,AD
4464:  MOVFF  01,AC
4468:  MOVFF  00,AB
.................... 	} 
.................... //	} 
.................... } 
446C:  RETLW  00
....................  
.................... void definir_rango_salida_PSu_PSdu(double a, double b, double c, Universo salida, BOOLEAN select) 
.................... { 
446E:  MOVFF  1DE,00
4472:  MOVFF  1DF,01
4476:  MOVFF  1E0,02
447A:  MOVFF  1E1,03
447E:  BCF    01.7
4480:  BCF    FD8.1
4482:  CLRF   19
4484:  BTFSC  FF2.6
4486:  BSF    19.6
4488:  BCF    FF2.6
448A:  BTFSC  FF2.7
448C:  BSF    19.7
448E:  BCF    FF2.7
4490:  MOVFF  1E5,386
4494:  MOVFF  1E4,385
4498:  MOVFF  1E3,384
449C:  MOVFF  1E2,383
44A0:  MOVFF  1E1,38A
44A4:  MOVFF  1E0,389
44A8:  MOVFF  01,388
44AC:  MOVFF  1DE,387
44B0:  CALL   0600
44B4:  BTFSC  19.6
44B6:  BSF    FF2.6
44B8:  BTFSC  19.7
44BA:  BSF    FF2.7
*
4504:  MOVFF  03,1EE
4508:  MOVFF  02,1ED
450C:  MOVFF  01,1EC
4510:  MOVFF  00,1EB
.................... 	double intervalo = (salida.max + fabs(salida.min))/4;  //4 porque son 5 conjuntos 
....................  
.................... /*	if(a < b && b < c) 
.................... 	{ 
.................... 		PSu.a = a; 
.................... 		PSu.b = b; 
.................... 		PSu.c = c; 
.................... 	} 
.................... 	else //por defecto 
.................... 	{*/ 
.................... 	if(select==PD) 
4514:  MOVLB  1
4516:  DECFSZ xEA,W
4518:  BRA    45C8
.................... 	{ 
.................... 		PSu.a = Zu.b; 
451A:  MOVFF  6E,76
451E:  MOVFF  6D,75
4522:  MOVFF  6C,74
4526:  MOVFF  6B,73
.................... 		PSu.b = PSu.a + intervalo; 
452A:  BCF    FD8.1
452C:  CLRF   19
452E:  BTFSC  FF2.6
4530:  BSF    19.6
4532:  BCF    FF2.6
4534:  BTFSC  FF2.7
4536:  BSF    19.7
4538:  BCF    FF2.7
453A:  MOVFF  76,386
453E:  MOVFF  75,385
4542:  MOVFF  74,384
4546:  MOVFF  73,383
454A:  MOVFF  1EE,38A
454E:  MOVFF  1ED,389
4552:  MOVFF  1EC,388
4556:  MOVFF  1EB,387
455A:  MOVLB  0
455C:  CALL   0600
4560:  BTFSC  19.6
4562:  BSF    FF2.6
4564:  BTFSC  19.7
4566:  BSF    FF2.7
4568:  MOVFF  03,7A
456C:  MOVFF  02,79
4570:  MOVFF  01,78
4574:  MOVFF  00,77
.................... 		PSu.c = PSu.b + intervalo; 
4578:  BCF    FD8.1
457A:  CLRF   19
457C:  BTFSC  FF2.6
457E:  BSF    19.6
4580:  BCF    FF2.6
4582:  BTFSC  FF2.7
4584:  BSF    19.7
4586:  BCF    FF2.7
4588:  MOVFF  7A,386
458C:  MOVFF  79,385
4590:  MOVFF  78,384
4594:  MOVFF  77,383
4598:  MOVFF  1EE,38A
459C:  MOVFF  1ED,389
45A0:  MOVFF  1EC,388
45A4:  MOVFF  1EB,387
45A8:  CALL   0600
45AC:  BTFSC  19.6
45AE:  BSF    FF2.6
45B0:  BTFSC  19.7
45B2:  BSF    FF2.7
45B4:  MOVFF  03,7E
45B8:  MOVFF  02,7D
45BC:  MOVFF  01,7C
45C0:  MOVFF  00,7B
.................... 	} 
.................... 	else 
45C4:  BRA    4672
45C6:  MOVLB  1
.................... 	{ 
.................... 		PSdu.a = Zdu.b; 
45C8:  MOVFF  AA,B2
45CC:  MOVFF  A9,B1
45D0:  MOVFF  A8,B0
45D4:  MOVFF  A7,AF
.................... 		PSdu.b = PSdu.a + intervalo; 
45D8:  BCF    FD8.1
45DA:  CLRF   19
45DC:  BTFSC  FF2.6
45DE:  BSF    19.6
45E0:  BCF    FF2.6
45E2:  BTFSC  FF2.7
45E4:  BSF    19.7
45E6:  BCF    FF2.7
45E8:  MOVFF  B2,386
45EC:  MOVFF  B1,385
45F0:  MOVFF  B0,384
45F4:  MOVFF  AF,383
45F8:  MOVFF  1EE,38A
45FC:  MOVFF  1ED,389
4600:  MOVFF  1EC,388
4604:  MOVFF  1EB,387
4608:  MOVLB  0
460A:  CALL   0600
460E:  BTFSC  19.6
4610:  BSF    FF2.6
4612:  BTFSC  19.7
4614:  BSF    FF2.7
4616:  MOVFF  03,B6
461A:  MOVFF  02,B5
461E:  MOVFF  01,B4
4622:  MOVFF  00,B3
.................... 		PSdu.c = PSdu.b + intervalo; 
4626:  BCF    FD8.1
4628:  CLRF   19
462A:  BTFSC  FF2.6
462C:  BSF    19.6
462E:  BCF    FF2.6
4630:  BTFSC  FF2.7
4632:  BSF    19.7
4634:  BCF    FF2.7
4636:  MOVFF  B6,386
463A:  MOVFF  B5,385
463E:  MOVFF  B4,384
4642:  MOVFF  B3,383
4646:  MOVFF  1EE,38A
464A:  MOVFF  1ED,389
464E:  MOVFF  1EC,388
4652:  MOVFF  1EB,387
4656:  CALL   0600
465A:  BTFSC  19.6
465C:  BSF    FF2.6
465E:  BTFSC  19.7
4660:  BSF    FF2.7
4662:  MOVFF  03,BA
4666:  MOVFF  02,B9
466A:  MOVFF  01,B8
466E:  MOVFF  00,B7
.................... 	} 
.................... //	} 
.................... } 
4672:  RETLW  00
....................  
.................... void definir_rango_salida_PBu_PBdu(double a, double b, double c, Universo salida, BOOLEAN select) 
.................... { 
4674:  MOVFF  1DE,00
4678:  MOVFF  1DF,01
467C:  MOVFF  1E0,02
4680:  MOVFF  1E1,03
4684:  BCF    01.7
4686:  BCF    FD8.1
4688:  CLRF   19
468A:  BTFSC  FF2.6
468C:  BSF    19.6
468E:  BCF    FF2.6
4690:  BTFSC  FF2.7
4692:  BSF    19.7
4694:  BCF    FF2.7
4696:  MOVFF  1E5,386
469A:  MOVFF  1E4,385
469E:  MOVFF  1E3,384
46A2:  MOVFF  1E2,383
46A6:  MOVFF  1E1,38A
46AA:  MOVFF  1E0,389
46AE:  MOVFF  01,388
46B2:  MOVFF  1DE,387
46B6:  CALL   0600
46BA:  BTFSC  19.6
46BC:  BSF    FF2.6
46BE:  BTFSC  19.7
46C0:  BSF    FF2.7
*
470A:  MOVFF  03,1EE
470E:  MOVFF  02,1ED
4712:  MOVFF  01,1EC
4716:  MOVFF  00,1EB
.................... 	double intervalo = (salida.max + fabs(salida.min))/4;  //4 porque son 5 conjuntos 
....................  
.................... /*	if(a < b && b < c) 
.................... 	{ 
.................... 		PBu.a = a; 
.................... 		PBu.b = b; 
.................... 		PBu.c = c; 
.................... 	} 
.................... 	else //por defecto 
.................... 	{*/ 
.................... 	if(select==PD) 
471A:  MOVLB  1
471C:  DECFSZ xEA,W
471E:  BRA    47CE
.................... 	{ 
.................... 		PBu.a = PSu.b; 
4720:  MOVFF  7A,82
4724:  MOVFF  79,81
4728:  MOVFF  78,80
472C:  MOVFF  77,7F
.................... 		PBu.b = PBu.a + intervalo; 
4730:  BCF    FD8.1
4732:  CLRF   19
4734:  BTFSC  FF2.6
4736:  BSF    19.6
4738:  BCF    FF2.6
473A:  BTFSC  FF2.7
473C:  BSF    19.7
473E:  BCF    FF2.7
4740:  MOVFF  82,386
4744:  MOVFF  81,385
4748:  MOVFF  80,384
474C:  MOVFF  7F,383
4750:  MOVFF  1EE,38A
4754:  MOVFF  1ED,389
4758:  MOVFF  1EC,388
475C:  MOVFF  1EB,387
4760:  MOVLB  0
4762:  CALL   0600
4766:  BTFSC  19.6
4768:  BSF    FF2.6
476A:  BTFSC  19.7
476C:  BSF    FF2.7
476E:  MOVFF  03,86
4772:  MOVFF  02,85
4776:  MOVFF  01,84
477A:  MOVFF  00,83
.................... 		PBu.c = PBu.b + intervalo; 
477E:  BCF    FD8.1
4780:  CLRF   19
4782:  BTFSC  FF2.6
4784:  BSF    19.6
4786:  BCF    FF2.6
4788:  BTFSC  FF2.7
478A:  BSF    19.7
478C:  BCF    FF2.7
478E:  MOVFF  86,386
4792:  MOVFF  85,385
4796:  MOVFF  84,384
479A:  MOVFF  83,383
479E:  MOVFF  1EE,38A
47A2:  MOVFF  1ED,389
47A6:  MOVFF  1EC,388
47AA:  MOVFF  1EB,387
47AE:  CALL   0600
47B2:  BTFSC  19.6
47B4:  BSF    FF2.6
47B6:  BTFSC  19.7
47B8:  BSF    FF2.7
47BA:  MOVFF  03,8A
47BE:  MOVFF  02,89
47C2:  MOVFF  01,88
47C6:  MOVFF  00,87
.................... 	} 
.................... 	else 
47CA:  BRA    4878
47CC:  MOVLB  1
.................... 	{ 
.................... 		PBdu.a = PSdu.b; 
47CE:  MOVFF  B6,BE
47D2:  MOVFF  B5,BD
47D6:  MOVFF  B4,BC
47DA:  MOVFF  B3,BB
.................... 		PBdu.b = PBdu.a + intervalo; 
47DE:  BCF    FD8.1
47E0:  CLRF   19
47E2:  BTFSC  FF2.6
47E4:  BSF    19.6
47E6:  BCF    FF2.6
47E8:  BTFSC  FF2.7
47EA:  BSF    19.7
47EC:  BCF    FF2.7
47EE:  MOVFF  BE,386
47F2:  MOVFF  BD,385
47F6:  MOVFF  BC,384
47FA:  MOVFF  BB,383
47FE:  MOVFF  1EE,38A
4802:  MOVFF  1ED,389
4806:  MOVFF  1EC,388
480A:  MOVFF  1EB,387
480E:  MOVLB  0
4810:  CALL   0600
4814:  BTFSC  19.6
4816:  BSF    FF2.6
4818:  BTFSC  19.7
481A:  BSF    FF2.7
481C:  MOVFF  03,C2
4820:  MOVFF  02,C1
4824:  MOVFF  01,C0
4828:  MOVFF  00,BF
.................... 		PBdu.c = PBdu.b + intervalo; 
482C:  BCF    FD8.1
482E:  CLRF   19
4830:  BTFSC  FF2.6
4832:  BSF    19.6
4834:  BCF    FF2.6
4836:  BTFSC  FF2.7
4838:  BSF    19.7
483A:  BCF    FF2.7
483C:  MOVFF  C2,386
4840:  MOVFF  C1,385
4844:  MOVFF  C0,384
4848:  MOVFF  BF,383
484C:  MOVFF  1EE,38A
4850:  MOVFF  1ED,389
4854:  MOVFF  1EC,388
4858:  MOVFF  1EB,387
485C:  CALL   0600
4860:  BTFSC  19.6
4862:  BSF    FF2.6
4864:  BTFSC  19.7
4866:  BSF    FF2.7
4868:  MOVFF  03,C6
486C:  MOVFF  02,C5
4870:  MOVFF  01,C4
4874:  MOVFF  00,C3
.................... 	} 
.................... //	} 
.................... } 
4878:  RETLW  00
....................  
....................  
.................... void PDInferenceEngine(double eP, double deD, double* uPD); 
.................... void PIInferenceEngine(double eI, double deP, double* duPI); 
.................... double consequent_equal(int conjunto, double x); 
.................... double OP_myOperations_Imp(double a, double b); 
.................... double OP_myOperations_Also(double a, double b); 
....................  
.................... void initialize_PI_Fuzzy(signed int16 _min,int16 _max,int16 _step) 
.................... { 
487A:  CLRF   19
487C:  BTFSC  FF2.6
487E:  BSF    19.6
4880:  BCF    FF2.6
4882:  BTFSC  FF2.7
4884:  BSF    19.7
4886:  BCF    FF2.7
.................... 	definir_universo_salida(_min,_max,_step,PI); 
4888:  MOVFF  1CD,21A
488C:  MOVFF  1CC,219
4890:  CALL   0326
4894:  BTFSC  19.6
4896:  BSF    FF2.6
4898:  BTFSC  19.7
489A:  BSF    FF2.7
489C:  MOVFF  00,1D2
48A0:  MOVFF  01,1D3
48A4:  MOVFF  02,1D4
48A8:  MOVFF  03,1D5
48AC:  CLRF   19
48AE:  BTFSC  FF2.6
48B0:  BSF    19.6
48B2:  BCF    FF2.6
48B4:  BTFSC  FF2.7
48B6:  BSF    19.7
48B8:  BCF    FF2.7
48BA:  MOVFF  1CF,216
48BE:  MOVFF  1CE,215
48C2:  CALL   04D4
48C6:  BTFSC  19.6
48C8:  BSF    FF2.6
48CA:  BTFSC  19.7
48CC:  BSF    FF2.7
48CE:  MOVFF  00,1D6
48D2:  MOVFF  01,1D7
48D6:  MOVFF  02,1D8
48DA:  MOVFF  03,1D9
48DE:  CLRF   19
48E0:  BTFSC  FF2.6
48E2:  BSF    19.6
48E4:  BCF    FF2.6
48E6:  BTFSC  FF2.7
48E8:  BSF    19.7
48EA:  BCF    FF2.7
48EC:  MOVFF  1D1,216
48F0:  MOVFF  1D0,215
48F4:  CALL   04D4
48F8:  BTFSC  19.6
48FA:  BSF    FF2.6
48FC:  BTFSC  19.7
48FE:  BSF    FF2.7
4900:  MOVFF  00,1DA
4904:  MOVFF  01,1DB
4908:  MOVFF  02,1DC
490C:  MOVFF  03,1DD
4910:  MOVFF  1D5,1E1
4914:  MOVFF  1D4,1E0
4918:  MOVFF  1D3,1DF
491C:  MOVFF  1D2,1DE
4920:  MOVFF  1D9,1E5
4924:  MOVFF  1D8,1E4
4928:  MOVFF  1D7,1E3
492C:  MOVFF  1D6,1E2
4930:  MOVFF  03,1E9
4934:  MOVFF  02,1E8
4938:  MOVFF  01,1E7
493C:  MOVFF  00,1E6
4940:  MOVLB  1
4942:  CLRF   xEA
4944:  MOVLB  0
4946:  CALL   395C
.................... 	definir_rango_salida_NBu_NBdu(0,0,0,PI_salida,PI); 
494A:  MOVLB  1
494C:  CLRF   xD5
494E:  CLRF   xD4
4950:  CLRF   xD3
4952:  CLRF   xD2
4954:  CLRF   xD9
4956:  CLRF   xD8
4958:  CLRF   xD7
495A:  CLRF   xD6
495C:  CLRF   xDD
495E:  CLRF   xDC
4960:  CLRF   xDB
4962:  CLRF   xDA
4964:  MOVFF  43,1DE
4968:  MOVFF  44,1DF
496C:  MOVFF  45,1E0
4970:  MOVFF  46,1E1
4974:  MOVFF  47,1E2
4978:  MOVFF  48,1E3
497C:  MOVFF  49,1E4
4980:  MOVFF  4A,1E5
4984:  MOVFF  4B,1E6
4988:  MOVFF  4C,1E7
498C:  MOVFF  4D,1E8
4990:  MOVFF  4E,1E9
4994:  CLRF   xEA
4996:  MOVLB  0
4998:  CALL   3DE4
.................... 	definir_rango_salida_NSu_NSdu(0,0,0,PI_salida,PI); 
499C:  MOVLB  1
499E:  CLRF   xD5
49A0:  CLRF   xD4
49A2:  CLRF   xD3
49A4:  CLRF   xD2
49A6:  CLRF   xD9
49A8:  CLRF   xD8
49AA:  CLRF   xD7
49AC:  CLRF   xD6
49AE:  CLRF   xDD
49B0:  CLRF   xDC
49B2:  CLRF   xDB
49B4:  CLRF   xDA
49B6:  MOVFF  43,1DE
49BA:  MOVFF  44,1DF
49BE:  MOVFF  45,1E0
49C2:  MOVFF  46,1E1
49C6:  MOVFF  47,1E2
49CA:  MOVFF  48,1E3
49CE:  MOVFF  49,1E4
49D2:  MOVFF  4A,1E5
49D6:  MOVFF  4B,1E6
49DA:  MOVFF  4C,1E7
49DE:  MOVFF  4D,1E8
49E2:  MOVFF  4E,1E9
49E6:  CLRF   xEA
49E8:  MOVLB  0
49EA:  CALL   4062
.................... 	definir_rango_salida_Zu_Zdu(0,0,0,PI_salida,PI); 
49EE:  MOVLB  1
49F0:  CLRF   xD5
49F2:  CLRF   xD4
49F4:  CLRF   xD3
49F6:  CLRF   xD2
49F8:  CLRF   xD9
49FA:  CLRF   xD8
49FC:  CLRF   xD7
49FE:  CLRF   xD6
4A00:  CLRF   xDD
4A02:  CLRF   xDC
4A04:  CLRF   xDB
4A06:  CLRF   xDA
4A08:  MOVFF  43,1DE
4A0C:  MOVFF  44,1DF
4A10:  MOVFF  45,1E0
4A14:  MOVFF  46,1E1
4A18:  MOVFF  47,1E2
4A1C:  MOVFF  48,1E3
4A20:  MOVFF  49,1E4
4A24:  MOVFF  4A,1E5
4A28:  MOVFF  4B,1E6
4A2C:  MOVFF  4C,1E7
4A30:  MOVFF  4D,1E8
4A34:  MOVFF  4E,1E9
4A38:  CLRF   xEA
4A3A:  MOVLB  0
4A3C:  RCALL  4268
.................... 	definir_rango_salida_PSu_PSdu(0,0,0,PI_salida,PI); 
4A3E:  MOVLB  1
4A40:  CLRF   xD5
4A42:  CLRF   xD4
4A44:  CLRF   xD3
4A46:  CLRF   xD2
4A48:  CLRF   xD9
4A4A:  CLRF   xD8
4A4C:  CLRF   xD7
4A4E:  CLRF   xD6
4A50:  CLRF   xDD
4A52:  CLRF   xDC
4A54:  CLRF   xDB
4A56:  CLRF   xDA
4A58:  MOVFF  43,1DE
4A5C:  MOVFF  44,1DF
4A60:  MOVFF  45,1E0
4A64:  MOVFF  46,1E1
4A68:  MOVFF  47,1E2
4A6C:  MOVFF  48,1E3
4A70:  MOVFF  49,1E4
4A74:  MOVFF  4A,1E5
4A78:  MOVFF  4B,1E6
4A7C:  MOVFF  4C,1E7
4A80:  MOVFF  4D,1E8
4A84:  MOVFF  4E,1E9
4A88:  CLRF   xEA
4A8A:  MOVLB  0
4A8C:  RCALL  446E
.................... 	definir_rango_salida_PBu_PBdu(0,0,0,PI_salida,PI); 
4A8E:  MOVLB  1
4A90:  CLRF   xD5
4A92:  CLRF   xD4
4A94:  CLRF   xD3
4A96:  CLRF   xD2
4A98:  CLRF   xD9
4A9A:  CLRF   xD8
4A9C:  CLRF   xD7
4A9E:  CLRF   xD6
4AA0:  CLRF   xDD
4AA2:  CLRF   xDC
4AA4:  CLRF   xDB
4AA6:  CLRF   xDA
4AA8:  MOVFF  43,1DE
4AAC:  MOVFF  44,1DF
4AB0:  MOVFF  45,1E0
4AB4:  MOVFF  46,1E1
4AB8:  MOVFF  47,1E2
4ABC:  MOVFF  48,1E3
4AC0:  MOVFF  49,1E4
4AC4:  MOVFF  4A,1E5
4AC8:  MOVFF  4B,1E6
4ACC:  MOVFF  4C,1E7
4AD0:  MOVFF  4D,1E8
4AD4:  MOVFF  4E,1E9
4AD8:  CLRF   xEA
4ADA:  MOVLB  0
4ADC:  RCALL  4674
.................... } 
4ADE:  GOTO   4DA6 (RETURN)
....................  
.................... void initialize_PD_Fuzzy(signed int16 _min,int16 _max,int16 _step) 
.................... { 
4AE2:  CLRF   19
4AE4:  BTFSC  FF2.6
4AE6:  BSF    19.6
4AE8:  BCF    FF2.6
4AEA:  BTFSC  FF2.7
4AEC:  BSF    19.7
4AEE:  BCF    FF2.7
.................... 	definir_universo_salida(_min,_max,_step,PD); 
4AF0:  MOVFF  1CD,21A
4AF4:  MOVFF  1CC,219
4AF8:  CALL   0326
4AFC:  BTFSC  19.6
4AFE:  BSF    FF2.6
4B00:  BTFSC  19.7
4B02:  BSF    FF2.7
4B04:  MOVFF  00,1D2
4B08:  MOVFF  01,1D3
4B0C:  MOVFF  02,1D4
4B10:  MOVFF  03,1D5
4B14:  CLRF   19
4B16:  BTFSC  FF2.6
4B18:  BSF    19.6
4B1A:  BCF    FF2.6
4B1C:  BTFSC  FF2.7
4B1E:  BSF    19.7
4B20:  BCF    FF2.7
4B22:  MOVFF  1CF,216
4B26:  MOVFF  1CE,215
4B2A:  CALL   04D4
4B2E:  BTFSC  19.6
4B30:  BSF    FF2.6
4B32:  BTFSC  19.7
4B34:  BSF    FF2.7
4B36:  MOVFF  00,1D6
4B3A:  MOVFF  01,1D7
4B3E:  MOVFF  02,1D8
4B42:  MOVFF  03,1D9
4B46:  CLRF   19
4B48:  BTFSC  FF2.6
4B4A:  BSF    19.6
4B4C:  BCF    FF2.6
4B4E:  BTFSC  FF2.7
4B50:  BSF    19.7
4B52:  BCF    FF2.7
4B54:  MOVFF  1D1,216
4B58:  MOVFF  1D0,215
4B5C:  CALL   04D4
4B60:  BTFSC  19.6
4B62:  BSF    FF2.6
4B64:  BTFSC  19.7
4B66:  BSF    FF2.7
4B68:  MOVFF  00,1DA
4B6C:  MOVFF  01,1DB
4B70:  MOVFF  02,1DC
4B74:  MOVFF  03,1DD
4B78:  MOVFF  1D5,1E1
4B7C:  MOVFF  1D4,1E0
4B80:  MOVFF  1D3,1DF
4B84:  MOVFF  1D2,1DE
4B88:  MOVFF  1D9,1E5
4B8C:  MOVFF  1D8,1E4
4B90:  MOVFF  1D7,1E3
4B94:  MOVFF  1D6,1E2
4B98:  MOVFF  03,1E9
4B9C:  MOVFF  02,1E8
4BA0:  MOVFF  01,1E7
4BA4:  MOVFF  00,1E6
4BA8:  MOVLW  01
4BAA:  MOVLB  1
4BAC:  MOVWF  xEA
4BAE:  MOVLB  0
4BB0:  CALL   395C
.................... 	definir_rango_salida_NBu_NBdu(0,0,0,PD_salida,PD); 
4BB4:  MOVLB  1
4BB6:  CLRF   xD5
4BB8:  CLRF   xD4
4BBA:  CLRF   xD3
4BBC:  CLRF   xD2
4BBE:  CLRF   xD9
4BC0:  CLRF   xD8
4BC2:  CLRF   xD7
4BC4:  CLRF   xD6
4BC6:  CLRF   xDD
4BC8:  CLRF   xDC
4BCA:  CLRF   xDB
4BCC:  CLRF   xDA
4BCE:  MOVFF  37,1DE
4BD2:  MOVFF  38,1DF
4BD6:  MOVFF  39,1E0
4BDA:  MOVFF  3A,1E1
4BDE:  MOVFF  3B,1E2
4BE2:  MOVFF  3C,1E3
4BE6:  MOVFF  3D,1E4
4BEA:  MOVFF  3E,1E5
4BEE:  MOVFF  3F,1E6
4BF2:  MOVFF  40,1E7
4BF6:  MOVFF  41,1E8
4BFA:  MOVFF  42,1E9
4BFE:  MOVLW  01
4C00:  MOVWF  xEA
4C02:  MOVLB  0
4C04:  CALL   3DE4
.................... 	definir_rango_salida_NSu_NSdu(0,0,0,PD_salida,PD); 
4C08:  MOVLB  1
4C0A:  CLRF   xD5
4C0C:  CLRF   xD4
4C0E:  CLRF   xD3
4C10:  CLRF   xD2
4C12:  CLRF   xD9
4C14:  CLRF   xD8
4C16:  CLRF   xD7
4C18:  CLRF   xD6
4C1A:  CLRF   xDD
4C1C:  CLRF   xDC
4C1E:  CLRF   xDB
4C20:  CLRF   xDA
4C22:  MOVFF  37,1DE
4C26:  MOVFF  38,1DF
4C2A:  MOVFF  39,1E0
4C2E:  MOVFF  3A,1E1
4C32:  MOVFF  3B,1E2
4C36:  MOVFF  3C,1E3
4C3A:  MOVFF  3D,1E4
4C3E:  MOVFF  3E,1E5
4C42:  MOVFF  3F,1E6
4C46:  MOVFF  40,1E7
4C4A:  MOVFF  41,1E8
4C4E:  MOVFF  42,1E9
4C52:  MOVLW  01
4C54:  MOVWF  xEA
4C56:  MOVLB  0
4C58:  CALL   4062
.................... 	definir_rango_salida_Zu_Zdu(0,0,0,PD_salida,PD); 
4C5C:  MOVLB  1
4C5E:  CLRF   xD5
4C60:  CLRF   xD4
4C62:  CLRF   xD3
4C64:  CLRF   xD2
4C66:  CLRF   xD9
4C68:  CLRF   xD8
4C6A:  CLRF   xD7
4C6C:  CLRF   xD6
4C6E:  CLRF   xDD
4C70:  CLRF   xDC
4C72:  CLRF   xDB
4C74:  CLRF   xDA
4C76:  MOVFF  37,1DE
4C7A:  MOVFF  38,1DF
4C7E:  MOVFF  39,1E0
4C82:  MOVFF  3A,1E1
4C86:  MOVFF  3B,1E2
4C8A:  MOVFF  3C,1E3
4C8E:  MOVFF  3D,1E4
4C92:  MOVFF  3E,1E5
4C96:  MOVFF  3F,1E6
4C9A:  MOVFF  40,1E7
4C9E:  MOVFF  41,1E8
4CA2:  MOVFF  42,1E9
4CA6:  MOVLW  01
4CA8:  MOVWF  xEA
4CAA:  MOVLB  0
4CAC:  CALL   4268
.................... 	definir_rango_salida_PSu_PSdu(0,0,0,PD_salida,PD); 
4CB0:  MOVLB  1
4CB2:  CLRF   xD5
4CB4:  CLRF   xD4
4CB6:  CLRF   xD3
4CB8:  CLRF   xD2
4CBA:  CLRF   xD9
4CBC:  CLRF   xD8
4CBE:  CLRF   xD7
4CC0:  CLRF   xD6
4CC2:  CLRF   xDD
4CC4:  CLRF   xDC
4CC6:  CLRF   xDB
4CC8:  CLRF   xDA
4CCA:  MOVFF  37,1DE
4CCE:  MOVFF  38,1DF
4CD2:  MOVFF  39,1E0
4CD6:  MOVFF  3A,1E1
4CDA:  MOVFF  3B,1E2
4CDE:  MOVFF  3C,1E3
4CE2:  MOVFF  3D,1E4
4CE6:  MOVFF  3E,1E5
4CEA:  MOVFF  3F,1E6
4CEE:  MOVFF  40,1E7
4CF2:  MOVFF  41,1E8
4CF6:  MOVFF  42,1E9
4CFA:  MOVLW  01
4CFC:  MOVWF  xEA
4CFE:  MOVLB  0
4D00:  CALL   446E
.................... 	definir_rango_salida_PBu_PBdu(0,0,0,PD_salida,PD); 
4D04:  MOVLB  1
4D06:  CLRF   xD5
4D08:  CLRF   xD4
4D0A:  CLRF   xD3
4D0C:  CLRF   xD2
4D0E:  CLRF   xD9
4D10:  CLRF   xD8
4D12:  CLRF   xD7
4D14:  CLRF   xD6
4D16:  CLRF   xDD
4D18:  CLRF   xDC
4D1A:  CLRF   xDB
4D1C:  CLRF   xDA
4D1E:  MOVFF  37,1DE
4D22:  MOVFF  38,1DF
4D26:  MOVFF  39,1E0
4D2A:  MOVFF  3A,1E1
4D2E:  MOVFF  3B,1E2
4D32:  MOVFF  3C,1E3
4D36:  MOVFF  3D,1E4
4D3A:  MOVFF  3E,1E5
4D3E:  MOVFF  3F,1E6
4D42:  MOVFF  40,1E7
4D46:  MOVFF  41,1E8
4D4A:  MOVFF  42,1E9
4D4E:  MOVLW  01
4D50:  MOVWF  xEA
4D52:  MOVLB  0
4D54:  RCALL  4674
.................... } 
4D56:  GOTO   4DF2 (RETURN)
....................  
.................... /*======================================================*/ 
.................... /*  Common function to compute a fuzzy number           */ 
.................... /*======================================================*/ 
....................  
.................... static double compute(FuzzyNumber fn,double x) { 
*
1E04:  MOVFF  342,34C
....................  int length = fn.length; 
....................  int i; 
....................  double imp;  
....................  double mu;  
....................   
....................  //Implication -> minimo 
....................  //Also -> maximo 
....................   
....................  //consequent_equal(i,x) grado de pertenencia de la salida 
....................  //fn.degree[i] grado de pertenencia de las entradas 
....................  
....................  //min(degree of applicability,grado de pertenencia de x en la funcion de membresia determinada) 
....................  imp = OP_myOperations_Imp(fn.degree[0],consequent_equal(0,x));  
1E08:  MOVLB  3
1E0A:  MOVFF  343,FE9
1E0E:  MOVFF  344,FEA
1E12:  MOVFF  FEF,356
1E16:  MOVFF  FEC,357
1E1A:  MOVFF  FEC,358
1E1E:  MOVFF  FEC,359
1E22:  CLRF   x5A
1E24:  MOVFF  34B,35E
1E28:  MOVFF  34A,35D
1E2C:  MOVFF  349,35C
1E30:  MOVFF  348,35B
1E34:  MOVLB  0
1E36:  RCALL  17F2
1E38:  MOVFF  00,35A
1E3C:  MOVFF  01,35B
1E40:  MOVFF  02,35C
1E44:  MOVFF  03,35D
1E48:  MOVFF  359,361
1E4C:  MOVFF  358,360
1E50:  MOVFF  357,35F
1E54:  MOVFF  356,35E
1E58:  MOVFF  03,365
1E5C:  MOVFF  02,364
1E60:  MOVFF  01,363
1E64:  MOVFF  00,362
1E68:  RCALL  1D6E
1E6A:  MOVFF  03,351
1E6E:  MOVFF  02,350
1E72:  MOVFF  01,34F
1E76:  MOVFF  00,34E
....................  mu = imp; 
1E7A:  MOVFF  351,355
1E7E:  MOVFF  350,354
1E82:  MOVFF  34F,353
1E86:  MOVFF  34E,352
....................  
....................  for(i=1; i<length; i++) { 
1E8A:  MOVLW  01
1E8C:  MOVLB  3
1E8E:  MOVWF  x4D
1E90:  MOVF   x4C,W
1E92:  SUBWF  x4D,W
1E94:  BC    1F4A
....................   imp = OP_myOperations_Imp(fn.degree[i],consequent_equal(i,x)); 
1E96:  MOVF   x4D,W
1E98:  MULLW  04
1E9A:  MOVF   FF3,W
1E9C:  CLRF   03
1E9E:  ADDWF  x43,W
1EA0:  MOVWF  FE9
1EA2:  MOVF   x44,W
1EA4:  ADDWFC 03,W
1EA6:  MOVWF  FEA
1EA8:  MOVFF  FEF,356
1EAC:  MOVFF  FEC,357
1EB0:  MOVFF  FEC,358
1EB4:  MOVFF  FEC,359
1EB8:  MOVFF  34D,35A
1EBC:  MOVFF  34B,35E
1EC0:  MOVFF  34A,35D
1EC4:  MOVFF  349,35C
1EC8:  MOVFF  348,35B
1ECC:  MOVLB  0
1ECE:  RCALL  17F2
1ED0:  MOVFF  00,35A
1ED4:  MOVFF  01,35B
1ED8:  MOVFF  02,35C
1EDC:  MOVFF  03,35D
1EE0:  MOVFF  359,361
1EE4:  MOVFF  358,360
1EE8:  MOVFF  357,35F
1EEC:  MOVFF  356,35E
1EF0:  MOVFF  03,365
1EF4:  MOVFF  02,364
1EF8:  MOVFF  01,363
1EFC:  MOVFF  00,362
1F00:  RCALL  1D6E
1F02:  MOVFF  03,351
1F06:  MOVFF  02,350
1F0A:  MOVFF  01,34F
1F0E:  MOVFF  00,34E
....................   mu = OP_myOperations_Also(mu,imp);  
1F12:  MOVFF  355,359
1F16:  MOVFF  354,358
1F1A:  MOVFF  353,357
1F1E:  MOVFF  352,356
1F22:  MOVFF  351,35D
1F26:  MOVFF  350,35C
1F2A:  MOVFF  34F,35B
1F2E:  MOVFF  34E,35A
1F32:  BRA    1DB8
1F34:  MOVFF  03,355
1F38:  MOVFF  02,354
1F3C:  MOVFF  01,353
1F40:  MOVFF  00,352
....................  } 
1F44:  MOVLB  3
1F46:  INCF   x4D,F
1F48:  BRA    1E90
....................  //mu determina de todas las reglas que se disparan cual es la que tiene 
....................  //mayor grado de pertenencia 
....................  return mu; 
1F4A:  MOVFF  352,00
1F4E:  MOVFF  353,01
1F52:  MOVFF  354,02
1F56:  MOVFF  355,03
.................... } 
1F5A:  MOVLB  0
1F5C:  GOTO   2058 (RETURN)
....................  
.................... /*======================================================*/ 
.................... /*  MembershipFunction MF_xfl_triangle                  */ 
.................... /*======================================================*/ 
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Function to compute an equal relationship            */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... //Indica el grado de pertenencia en el que valor x pertenece al 
.................... //conjunto fuzzy determinado (depende del que la llame)  
.................... static double MF_xfl_triangle_equal(double x, double min, double max, double step, double a, double b, double c) { 
....................     return (a<x && x<=b? (x-a)/(b-a) : (b<x && x<c? (c-x)/(c-b) : 0));  
*
0D50:  MOVFF  376,382
0D54:  MOVFF  375,381
0D58:  MOVFF  374,380
0D5C:  MOVFF  373,37F
0D60:  MOVFF  366,386
0D64:  MOVFF  365,385
0D68:  MOVFF  364,384
0D6C:  MOVFF  363,383
0D70:  RCALL  0878
0D72:  BNC   0E18
0D74:  MOVFF  366,382
0D78:  MOVFF  365,381
0D7C:  MOVFF  364,380
0D80:  MOVFF  363,37F
0D84:  MOVFF  37A,386
0D88:  MOVFF  379,385
0D8C:  MOVFF  378,384
0D90:  MOVFF  377,383
0D94:  RCALL  0878
0D96:  BC    0D9A
0D98:  BNZ   0E18
0D9A:  BSF    FD8.1
0D9C:  MOVFF  366,386
0DA0:  MOVFF  365,385
0DA4:  MOVFF  364,384
0DA8:  MOVFF  363,383
0DAC:  MOVFF  376,38A
0DB0:  MOVFF  375,389
0DB4:  MOVFF  374,388
0DB8:  MOVFF  373,387
0DBC:  RCALL  0600
0DBE:  MOVFF  00,37F
0DC2:  MOVFF  01,380
0DC6:  MOVFF  02,381
0DCA:  MOVFF  03,382
0DCE:  BSF    FD8.1
0DD0:  MOVFF  37A,386
0DD4:  MOVFF  379,385
0DD8:  MOVFF  378,384
0DDC:  MOVFF  377,383
0DE0:  MOVFF  376,38A
0DE4:  MOVFF  375,389
0DE8:  MOVFF  374,388
0DEC:  MOVFF  373,387
0DF0:  RCALL  0600
0DF2:  MOVFF  382,386
0DF6:  MOVFF  381,385
0DFA:  MOVFF  380,384
0DFE:  MOVFF  37F,383
0E02:  MOVFF  03,38A
0E06:  MOVFF  02,389
0E0A:  MOVFF  01,388
0E0E:  MOVFF  00,387
0E12:  CALL   0376
0E16:  BRA    0EEA
0E18:  MOVFF  37A,382
0E1C:  MOVFF  379,381
0E20:  MOVFF  378,380
0E24:  MOVFF  377,37F
0E28:  MOVFF  366,386
0E2C:  MOVFF  365,385
0E30:  MOVFF  364,384
0E34:  MOVFF  363,383
0E38:  RCALL  0878
0E3A:  BNC   0EE2
0E3C:  MOVFF  366,382
0E40:  MOVFF  365,381
0E44:  MOVFF  364,380
0E48:  MOVFF  363,37F
0E4C:  MOVFF  37E,386
0E50:  MOVFF  37D,385
0E54:  MOVFF  37C,384
0E58:  MOVFF  37B,383
0E5C:  RCALL  0878
0E5E:  BNC   0EE2
0E60:  BSF    FD8.1
0E62:  MOVFF  37E,386
0E66:  MOVFF  37D,385
0E6A:  MOVFF  37C,384
0E6E:  MOVFF  37B,383
0E72:  MOVFF  366,38A
0E76:  MOVFF  365,389
0E7A:  MOVFF  364,388
0E7E:  MOVFF  363,387
0E82:  CALL   0600
0E86:  MOVFF  00,37F
0E8A:  MOVFF  01,380
0E8E:  MOVFF  02,381
0E92:  MOVFF  03,382
0E96:  BSF    FD8.1
0E98:  MOVFF  37E,386
0E9C:  MOVFF  37D,385
0EA0:  MOVFF  37C,384
0EA4:  MOVFF  37B,383
0EA8:  MOVFF  37A,38A
0EAC:  MOVFF  379,389
0EB0:  MOVFF  378,388
0EB4:  MOVFF  377,387
0EB8:  CALL   0600
0EBC:  MOVFF  382,386
0EC0:  MOVFF  381,385
0EC4:  MOVFF  380,384
0EC8:  MOVFF  37F,383
0ECC:  MOVFF  03,38A
0ED0:  MOVFF  02,389
0ED4:  MOVFF  01,388
0ED8:  MOVFF  00,387
0EDC:  CALL   0376
0EE0:  BRA    0EEA
0EE2:  CLRF   00
0EE4:  CLRF   01
0EE6:  CLRF   02
0EE8:  CLRF   03
....................  
.................... } 
0EEA:  RETLW  00
....................  
.................... /*======================================================*/ 
.................... /*  Operatorset OP_myOperations                         */ 
.................... /*======================================================*/ 
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the operator AND                      */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double OP_myOperations_And(double a, double b) { 
....................     return (a<b? a : b);  
*
1314:  MOVFF  2F9,382
1318:  MOVFF  2F8,381
131C:  MOVFF  2F7,380
1320:  MOVFF  2F6,37F
1324:  MOVFF  2FD,386
1328:  MOVFF  2FC,385
132C:  MOVFF  2FB,384
1330:  MOVFF  2FA,383
1334:  CALL   0878
1338:  BNC   134C
133A:  MOVFF  2F6,00
133E:  MOVFF  2F7,01
1342:  MOVFF  2F8,02
1346:  MOVFF  2F9,03
134A:  BRA    135C
134C:  MOVFF  2FA,00
1350:  MOVFF  2FB,01
1354:  MOVFF  2FC,02
1358:  MOVFF  2FD,03
....................  
.................... } 
135C:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the operator ALSO                     */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double OP_myOperations_Also(double a, double b) { 
....................     return (a>b? a : b);  
*
1DB8:  MOVFF  35D,382
1DBC:  MOVFF  35C,381
1DC0:  MOVFF  35B,380
1DC4:  MOVFF  35A,37F
1DC8:  MOVFF  359,386
1DCC:  MOVFF  358,385
1DD0:  MOVFF  357,384
1DD4:  MOVFF  356,383
1DD8:  CALL   0878
1DDC:  BNC   1DF0
1DDE:  MOVFF  356,00
1DE2:  MOVFF  357,01
1DE6:  MOVFF  358,02
1DEA:  MOVFF  359,03
1DEE:  BRA    1E00
1DF0:  MOVFF  35A,00
1DF4:  MOVFF  35B,01
1DF8:  MOVFF  35C,02
1DFC:  MOVFF  35D,03
....................  
.................... } 
1E00:  GOTO   1F34 (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the operator IMPLICATION              */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double OP_myOperations_Imp(double a, double b) { 
....................     return (a<b? a : b);  
*
1D6E:  MOVFF  361,382
1D72:  MOVFF  360,381
1D76:  MOVFF  35F,380
1D7A:  MOVFF  35E,37F
1D7E:  MOVFF  365,386
1D82:  MOVFF  364,385
1D86:  MOVFF  363,384
1D8A:  MOVFF  362,383
1D8E:  CALL   0878
1D92:  BNC   1DA6
1D94:  MOVFF  35E,00
1D98:  MOVFF  35F,01
1D9C:  MOVFF  360,02
1DA0:  MOVFF  361,03
1DA4:  BRA    1DB6
1DA6:  MOVFF  362,00
1DAA:  MOVFF  363,01
1DAE:  MOVFF  364,02
1DB2:  MOVFF  365,03
....................  
.................... } 
1DB6:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the defuzzification method            */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double OP_myOperations_Defuz(FuzzyNumber mf) { 
*
1F60:  MOVFF  2FB,315
1F64:  MOVFF  2FA,314
1F68:  MOVFF  2F9,313
1F6C:  MOVFF  2F8,312
1F70:  MOVFF  2FF,319
1F74:  MOVFF  2FE,318
1F78:  MOVFF  2FD,317
1F7C:  MOVFF  2FC,316
1F80:  MOVFF  303,31D
1F84:  MOVFF  302,31C
1F88:  MOVFF  301,31B
1F8C:  MOVFF  300,31A
1F90:  MOVLB  3
1F92:  CLRF   x29
1F94:  CLRF   x28
1F96:  CLRF   x27
1F98:  CLRF   x26
1F9A:  CLRF   x2D
1F9C:  CLRF   x2C
1F9E:  CLRF   x2B
1FA0:  CLRF   x2A
....................  double min = mf.min; 
....................  double max = mf.max; 
....................  double step = mf.step; 
....................      double x, m, num=0, denom=0; 
....................      for(x=min; x<=max; x+=step) { 
1FA2:  MOVFF  315,321
1FA6:  MOVFF  314,320
1FAA:  MOVFF  313,31F
1FAE:  MOVFF  312,31E
1FB2:  MOVFF  321,382
1FB6:  MOVFF  320,381
1FBA:  MOVFF  31F,380
1FBE:  MOVFF  31E,37F
1FC2:  MOVFF  319,386
1FC6:  MOVFF  318,385
1FCA:  MOVFF  317,384
1FCE:  MOVFF  316,383
1FD2:  MOVLB  0
1FD4:  CALL   0878
1FD8:  BC    1FDE
1FDA:  BTFSS  FD8.2
1FDC:  BRA    2132
....................       m = compute(mf,x); 
1FDE:  MOVFF  2F8,32E
1FE2:  MOVFF  2F9,32F
1FE6:  MOVFF  2FA,330
1FEA:  MOVFF  2FB,331
1FEE:  MOVFF  2FC,332
1FF2:  MOVFF  2FD,333
1FF6:  MOVFF  2FE,334
1FFA:  MOVFF  2FF,335
1FFE:  MOVFF  300,336
2002:  MOVFF  301,337
2006:  MOVFF  302,338
200A:  MOVFF  303,339
200E:  MOVFF  304,33A
2012:  MOVFF  305,33B
2016:  MOVFF  306,33C
201A:  MOVFF  307,33D
201E:  MOVFF  308,33E
2022:  MOVFF  309,33F
2026:  MOVFF  30A,340
202A:  MOVFF  30B,341
202E:  MOVFF  30C,342
2032:  MOVFF  30D,343
2036:  MOVFF  30E,344
203A:  MOVFF  30F,345
203E:  MOVFF  310,346
2042:  MOVFF  311,347
2046:  MOVFF  321,34B
204A:  MOVFF  320,34A
204E:  MOVFF  31F,349
2052:  MOVFF  31E,348
2056:  BRA    1E04
2058:  MOVFF  03,325
205C:  MOVFF  02,324
2060:  MOVFF  01,323
2064:  MOVFF  00,322
....................       num += x*m; 
2068:  MOVFF  321,331
206C:  MOVFF  320,330
2070:  MOVFF  31F,32F
2074:  MOVFF  31E,32E
2078:  MOVFF  325,335
207C:  MOVFF  324,334
2080:  MOVFF  323,333
2084:  MOVFF  322,332
2088:  CALL   050A
208C:  BCF    FD8.1
208E:  MOVFF  329,386
2092:  MOVFF  328,385
2096:  MOVFF  327,384
209A:  MOVFF  326,383
209E:  MOVFF  03,38A
20A2:  MOVFF  02,389
20A6:  MOVFF  01,388
20AA:  MOVFF  00,387
20AE:  CALL   0600
20B2:  MOVFF  03,329
20B6:  MOVFF  02,328
20BA:  MOVFF  01,327
20BE:  MOVFF  00,326
....................       denom += m; 
20C2:  BCF    FD8.1
20C4:  MOVFF  32D,386
20C8:  MOVFF  32C,385
20CC:  MOVFF  32B,384
20D0:  MOVFF  32A,383
20D4:  MOVFF  325,38A
20D8:  MOVFF  324,389
20DC:  MOVFF  323,388
20E0:  MOVFF  322,387
20E4:  CALL   0600
20E8:  MOVFF  03,32D
20EC:  MOVFF  02,32C
20F0:  MOVFF  01,32B
20F4:  MOVFF  00,32A
....................      } 
20F8:  BCF    FD8.1
20FA:  MOVFF  321,386
20FE:  MOVFF  320,385
2102:  MOVFF  31F,384
2106:  MOVFF  31E,383
210A:  MOVFF  31D,38A
210E:  MOVFF  31C,389
2112:  MOVFF  31B,388
2116:  MOVFF  31A,387
211A:  CALL   0600
211E:  MOVFF  03,321
2122:  MOVFF  02,320
2126:  MOVFF  01,31F
212A:  MOVFF  00,31E
212E:  MOVLB  3
2130:  BRA    1FB2
....................      if(denom==0) return (min+max)/2; 
2132:  MOVFF  32D,382
2136:  MOVFF  32C,381
213A:  MOVFF  32B,380
213E:  MOVFF  32A,37F
2142:  MOVLB  3
2144:  CLRF   x86
2146:  CLRF   x85
2148:  CLRF   x84
214A:  CLRF   x83
214C:  MOVLB  0
214E:  CALL   0878
2152:  BNZ   21AE
2154:  BCF    FD8.1
2156:  MOVFF  315,386
215A:  MOVFF  314,385
215E:  MOVFF  313,384
2162:  MOVFF  312,383
2166:  MOVFF  319,38A
216A:  MOVFF  318,389
216E:  MOVFF  317,388
2172:  MOVFF  316,387
2176:  CALL   0600
217A:  MOVFF  00,32E
217E:  MOVFF  01,32F
2182:  MOVFF  02,330
2186:  MOVFF  03,331
218A:  MOVFF  03,386
218E:  MOVFF  02,385
2192:  MOVFF  01,384
2196:  MOVFF  00,383
219A:  MOVLB  3
219C:  CLRF   x8A
219E:  CLRF   x89
21A0:  CLRF   x88
21A2:  MOVLW  80
21A4:  MOVWF  x87
21A6:  MOVLB  0
21A8:  CALL   0376
21AC:  BRA    21D2
....................      return num/denom; 
21AE:  MOVFF  329,386
21B2:  MOVFF  328,385
21B6:  MOVFF  327,384
21BA:  MOVFF  326,383
21BE:  MOVFF  32D,38A
21C2:  MOVFF  32C,389
21C6:  MOVFF  32B,388
21CA:  MOVFF  32A,387
21CE:  CALL   0376
....................  
.................... } 
21D2:  GOTO   2CF4 (RETURN)
....................  
.................... /*======================================================*/ 
.................... /*  Type TP_e                                           */ 
.................... /*======================================================*/ 
.................... //Llama a la funcion que determina el grado de pertenencia 
.................... //para un conjunto especifico (el conjunto fuzzy determinado). 
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label NB                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_e_NB_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,-1534.5,-1023.0,-511.5); 
*
0EEC:  MOVFF  2F9,366
0EF0:  MOVFF  2F8,365
0EF4:  MOVFF  2F7,364
0EF8:  MOVFF  2F6,363
0EFC:  MOVLB  3
0EFE:  CLRF   x6A
0F00:  MOVLW  C0
0F02:  MOVWF  x69
0F04:  MOVLW  FF
0F06:  MOVWF  x68
0F08:  MOVLW  88
0F0A:  MOVWF  x67
0F0C:  CLRF   x6E
0F0E:  MOVLW  C0
0F10:  MOVWF  x6D
0F12:  MOVLW  7F
0F14:  MOVWF  x6C
0F16:  MOVLW  88
0F18:  MOVWF  x6B
0F1A:  MOVLW  55
0F1C:  MOVWF  x72
0F1E:  MOVWF  x71
0F20:  MOVLW  63
0F22:  MOVWF  x70
0F24:  MOVLW  86
0F26:  MOVWF  x6F
0F28:  CLRF   x76
0F2A:  MOVLW  D0
0F2C:  MOVWF  x75
0F2E:  MOVLW  BF
0F30:  MOVWF  x74
0F32:  MOVLW  89
0F34:  MOVWF  x73
0F36:  CLRF   x7A
0F38:  MOVLW  C0
0F3A:  MOVWF  x79
0F3C:  MOVLW  FF
0F3E:  MOVWF  x78
0F40:  MOVLW  88
0F42:  MOVWF  x77
0F44:  CLRF   x7E
0F46:  MOVLW  C0
0F48:  MOVWF  x7D
0F4A:  MOVLW  FF
0F4C:  MOVWF  x7C
0F4E:  MOVLW  87
0F50:  MOVWF  x7B
0F52:  MOVLB  0
0F54:  RCALL  0D50
.................... } 
0F56:  GOTO   222C (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label NS                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_e_NS_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,-1023.0,-511.5,0.0); 
0F5A:  MOVFF  2F9,366
0F5E:  MOVFF  2F8,365
0F62:  MOVFF  2F7,364
0F66:  MOVFF  2F6,363
0F6A:  MOVLB  3
0F6C:  CLRF   x6A
0F6E:  MOVLW  C0
0F70:  MOVWF  x69
0F72:  MOVLW  FF
0F74:  MOVWF  x68
0F76:  MOVLW  88
0F78:  MOVWF  x67
0F7A:  CLRF   x6E
0F7C:  MOVLW  C0
0F7E:  MOVWF  x6D
0F80:  MOVLW  7F
0F82:  MOVWF  x6C
0F84:  MOVLW  88
0F86:  MOVWF  x6B
0F88:  MOVLW  55
0F8A:  MOVWF  x72
0F8C:  MOVWF  x71
0F8E:  MOVLW  63
0F90:  MOVWF  x70
0F92:  MOVLW  86
0F94:  MOVWF  x6F
0F96:  CLRF   x76
0F98:  MOVLW  C0
0F9A:  MOVWF  x75
0F9C:  MOVLW  FF
0F9E:  MOVWF  x74
0FA0:  MOVLW  88
0FA2:  MOVWF  x73
0FA4:  CLRF   x7A
0FA6:  MOVLW  C0
0FA8:  MOVWF  x79
0FAA:  MOVLW  FF
0FAC:  MOVWF  x78
0FAE:  MOVLW  87
0FB0:  MOVWF  x77
0FB2:  CLRF   x7E
0FB4:  CLRF   x7D
0FB6:  CLRF   x7C
0FB8:  CLRF   x7B
0FBA:  MOVLB  0
0FBC:  RCALL  0D50
.................... } 
0FBE:  GOTO   2250 (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label Z                           */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_e_Z_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,-511.5,0.0,511.5); 
0FC2:  MOVFF  2F9,366
0FC6:  MOVFF  2F8,365
0FCA:  MOVFF  2F7,364
0FCE:  MOVFF  2F6,363
0FD2:  MOVLB  3
0FD4:  CLRF   x6A
0FD6:  MOVLW  C0
0FD8:  MOVWF  x69
0FDA:  MOVLW  FF
0FDC:  MOVWF  x68
0FDE:  MOVLW  88
0FE0:  MOVWF  x67
0FE2:  CLRF   x6E
0FE4:  MOVLW  C0
0FE6:  MOVWF  x6D
0FE8:  MOVLW  7F
0FEA:  MOVWF  x6C
0FEC:  MOVLW  88
0FEE:  MOVWF  x6B
0FF0:  MOVLW  55
0FF2:  MOVWF  x72
0FF4:  MOVWF  x71
0FF6:  MOVLW  63
0FF8:  MOVWF  x70
0FFA:  MOVLW  86
0FFC:  MOVWF  x6F
0FFE:  CLRF   x76
1000:  MOVLW  C0
1002:  MOVWF  x75
1004:  MOVLW  FF
1006:  MOVWF  x74
1008:  MOVLW  87
100A:  MOVWF  x73
100C:  CLRF   x7A
100E:  CLRF   x79
1010:  CLRF   x78
1012:  CLRF   x77
1014:  CLRF   x7E
1016:  MOVLW  C0
1018:  MOVWF  x7D
101A:  MOVLW  7F
101C:  MOVWF  x7C
101E:  MOVLW  87
1020:  MOVWF  x7B
1022:  MOVLB  0
1024:  RCALL  0D50
.................... } 
1026:  GOTO   2274 (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label PS                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_e_PS_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,0.0,511.5,1023.0); 
102A:  MOVFF  2F9,366
102E:  MOVFF  2F8,365
1032:  MOVFF  2F7,364
1036:  MOVFF  2F6,363
103A:  MOVLB  3
103C:  CLRF   x6A
103E:  MOVLW  C0
1040:  MOVWF  x69
1042:  MOVLW  FF
1044:  MOVWF  x68
1046:  MOVLW  88
1048:  MOVWF  x67
104A:  CLRF   x6E
104C:  MOVLW  C0
104E:  MOVWF  x6D
1050:  MOVLW  7F
1052:  MOVWF  x6C
1054:  MOVLW  88
1056:  MOVWF  x6B
1058:  MOVLW  55
105A:  MOVWF  x72
105C:  MOVWF  x71
105E:  MOVLW  63
1060:  MOVWF  x70
1062:  MOVLW  86
1064:  MOVWF  x6F
1066:  CLRF   x76
1068:  CLRF   x75
106A:  CLRF   x74
106C:  CLRF   x73
106E:  CLRF   x7A
1070:  MOVLW  C0
1072:  MOVWF  x79
1074:  MOVLW  7F
1076:  MOVWF  x78
1078:  MOVLW  87
107A:  MOVWF  x77
107C:  CLRF   x7E
107E:  MOVLW  C0
1080:  MOVWF  x7D
1082:  MOVLW  7F
1084:  MOVWF  x7C
1086:  MOVLW  88
1088:  MOVWF  x7B
108A:  MOVLB  0
108C:  RCALL  0D50
.................... } 
108E:  GOTO   2298 (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label PB                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_e_PB_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,511.5,1023.0,1534.5); 
1092:  MOVFF  2F9,366
1096:  MOVFF  2F8,365
109A:  MOVFF  2F7,364
109E:  MOVFF  2F6,363
10A2:  MOVLB  3
10A4:  CLRF   x6A
10A6:  MOVLW  C0
10A8:  MOVWF  x69
10AA:  MOVLW  FF
10AC:  MOVWF  x68
10AE:  MOVLW  88
10B0:  MOVWF  x67
10B2:  CLRF   x6E
10B4:  MOVLW  C0
10B6:  MOVWF  x6D
10B8:  MOVLW  7F
10BA:  MOVWF  x6C
10BC:  MOVLW  88
10BE:  MOVWF  x6B
10C0:  MOVLW  55
10C2:  MOVWF  x72
10C4:  MOVWF  x71
10C6:  MOVLW  63
10C8:  MOVWF  x70
10CA:  MOVLW  86
10CC:  MOVWF  x6F
10CE:  CLRF   x76
10D0:  MOVLW  C0
10D2:  MOVWF  x75
10D4:  MOVLW  7F
10D6:  MOVWF  x74
10D8:  MOVLW  87
10DA:  MOVWF  x73
10DC:  CLRF   x7A
10DE:  MOVLW  C0
10E0:  MOVWF  x79
10E2:  MOVLW  7F
10E4:  MOVWF  x78
10E6:  MOVLW  88
10E8:  MOVWF  x77
10EA:  CLRF   x7E
10EC:  MOVLW  D0
10EE:  MOVWF  x7D
10F0:  MOVLW  3F
10F2:  MOVWF  x7C
10F4:  MOVLW  89
10F6:  MOVWF  x7B
10F8:  MOVLB  0
10FA:  RCALL  0D50
.................... } 
10FC:  GOTO   22BC (RETURN)
....................  
.................... /*======================================================*/ 
.................... /*  Type TP_de                                          */ 
.................... /*======================================================*/ 
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label DB                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_de_DB_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,-1534.5,-1023.0,-511.5); 
1100:  MOVFF  2F9,366
1104:  MOVFF  2F8,365
1108:  MOVFF  2F7,364
110C:  MOVFF  2F6,363
1110:  MOVLB  3
1112:  CLRF   x6A
1114:  MOVLW  C0
1116:  MOVWF  x69
1118:  MOVLW  FF
111A:  MOVWF  x68
111C:  MOVLW  88
111E:  MOVWF  x67
1120:  CLRF   x6E
1122:  MOVLW  C0
1124:  MOVWF  x6D
1126:  MOVLW  7F
1128:  MOVWF  x6C
112A:  MOVLW  88
112C:  MOVWF  x6B
112E:  MOVLW  55
1130:  MOVWF  x72
1132:  MOVWF  x71
1134:  MOVLW  63
1136:  MOVWF  x70
1138:  MOVLW  86
113A:  MOVWF  x6F
113C:  CLRF   x76
113E:  MOVLW  D0
1140:  MOVWF  x75
1142:  MOVLW  BF
1144:  MOVWF  x74
1146:  MOVLW  89
1148:  MOVWF  x73
114A:  CLRF   x7A
114C:  MOVLW  C0
114E:  MOVWF  x79
1150:  MOVLW  FF
1152:  MOVWF  x78
1154:  MOVLW  88
1156:  MOVWF  x77
1158:  CLRF   x7E
115A:  MOVLW  C0
115C:  MOVWF  x7D
115E:  MOVLW  FF
1160:  MOVWF  x7C
1162:  MOVLW  87
1164:  MOVWF  x7B
1166:  MOVLB  0
1168:  RCALL  0D50
.................... } 
116A:  GOTO   22E0 (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label DS                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_de_DS_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,-1023.0,-511.5,0.0); 
116E:  MOVFF  2F9,366
1172:  MOVFF  2F8,365
1176:  MOVFF  2F7,364
117A:  MOVFF  2F6,363
117E:  MOVLB  3
1180:  CLRF   x6A
1182:  MOVLW  C0
1184:  MOVWF  x69
1186:  MOVLW  FF
1188:  MOVWF  x68
118A:  MOVLW  88
118C:  MOVWF  x67
118E:  CLRF   x6E
1190:  MOVLW  C0
1192:  MOVWF  x6D
1194:  MOVLW  7F
1196:  MOVWF  x6C
1198:  MOVLW  88
119A:  MOVWF  x6B
119C:  MOVLW  55
119E:  MOVWF  x72
11A0:  MOVWF  x71
11A2:  MOVLW  63
11A4:  MOVWF  x70
11A6:  MOVLW  86
11A8:  MOVWF  x6F
11AA:  CLRF   x76
11AC:  MOVLW  C0
11AE:  MOVWF  x75
11B0:  MOVLW  FF
11B2:  MOVWF  x74
11B4:  MOVLW  88
11B6:  MOVWF  x73
11B8:  CLRF   x7A
11BA:  MOVLW  C0
11BC:  MOVWF  x79
11BE:  MOVLW  FF
11C0:  MOVWF  x78
11C2:  MOVLW  87
11C4:  MOVWF  x77
11C6:  CLRF   x7E
11C8:  CLRF   x7D
11CA:  CLRF   x7C
11CC:  CLRF   x7B
11CE:  MOVLB  0
11D0:  RCALL  0D50
.................... } 
11D2:  GOTO   2304 (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label Z                           */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_de_Z_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,-511.5,0.0,511.5); 
11D6:  MOVFF  2F9,366
11DA:  MOVFF  2F8,365
11DE:  MOVFF  2F7,364
11E2:  MOVFF  2F6,363
11E6:  MOVLB  3
11E8:  CLRF   x6A
11EA:  MOVLW  C0
11EC:  MOVWF  x69
11EE:  MOVLW  FF
11F0:  MOVWF  x68
11F2:  MOVLW  88
11F4:  MOVWF  x67
11F6:  CLRF   x6E
11F8:  MOVLW  C0
11FA:  MOVWF  x6D
11FC:  MOVLW  7F
11FE:  MOVWF  x6C
1200:  MOVLW  88
1202:  MOVWF  x6B
1204:  MOVLW  55
1206:  MOVWF  x72
1208:  MOVWF  x71
120A:  MOVLW  63
120C:  MOVWF  x70
120E:  MOVLW  86
1210:  MOVWF  x6F
1212:  CLRF   x76
1214:  MOVLW  C0
1216:  MOVWF  x75
1218:  MOVLW  FF
121A:  MOVWF  x74
121C:  MOVLW  87
121E:  MOVWF  x73
1220:  CLRF   x7A
1222:  CLRF   x79
1224:  CLRF   x78
1226:  CLRF   x77
1228:  CLRF   x7E
122A:  MOVLW  C0
122C:  MOVWF  x7D
122E:  MOVLW  7F
1230:  MOVWF  x7C
1232:  MOVLW  87
1234:  MOVWF  x7B
1236:  MOVLB  0
1238:  RCALL  0D50
.................... } 
123A:  GOTO   2328 (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label IS                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_de_IS_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,0.0,511.5,1023.0); 
123E:  MOVFF  2F9,366
1242:  MOVFF  2F8,365
1246:  MOVFF  2F7,364
124A:  MOVFF  2F6,363
124E:  MOVLB  3
1250:  CLRF   x6A
1252:  MOVLW  C0
1254:  MOVWF  x69
1256:  MOVLW  FF
1258:  MOVWF  x68
125A:  MOVLW  88
125C:  MOVWF  x67
125E:  CLRF   x6E
1260:  MOVLW  C0
1262:  MOVWF  x6D
1264:  MOVLW  7F
1266:  MOVWF  x6C
1268:  MOVLW  88
126A:  MOVWF  x6B
126C:  MOVLW  55
126E:  MOVWF  x72
1270:  MOVWF  x71
1272:  MOVLW  63
1274:  MOVWF  x70
1276:  MOVLW  86
1278:  MOVWF  x6F
127A:  CLRF   x76
127C:  CLRF   x75
127E:  CLRF   x74
1280:  CLRF   x73
1282:  CLRF   x7A
1284:  MOVLW  C0
1286:  MOVWF  x79
1288:  MOVLW  7F
128A:  MOVWF  x78
128C:  MOVLW  87
128E:  MOVWF  x77
1290:  CLRF   x7E
1292:  MOVLW  C0
1294:  MOVWF  x7D
1296:  MOVLW  7F
1298:  MOVWF  x7C
129A:  MOVLW  88
129C:  MOVWF  x7B
129E:  MOVLB  0
12A0:  RCALL  0D50
.................... } 
12A2:  GOTO   234C (RETURN)
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label IB                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_de_IB_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,-1023.0,1023.0,227.33333333333334,511.5,1023.0,1534.5); 
12A6:  MOVFF  2F9,366
12AA:  MOVFF  2F8,365
12AE:  MOVFF  2F7,364
12B2:  MOVFF  2F6,363
12B6:  MOVLB  3
12B8:  CLRF   x6A
12BA:  MOVLW  C0
12BC:  MOVWF  x69
12BE:  MOVLW  FF
12C0:  MOVWF  x68
12C2:  MOVLW  88
12C4:  MOVWF  x67
12C6:  CLRF   x6E
12C8:  MOVLW  C0
12CA:  MOVWF  x6D
12CC:  MOVLW  7F
12CE:  MOVWF  x6C
12D0:  MOVLW  88
12D2:  MOVWF  x6B
12D4:  MOVLW  55
12D6:  MOVWF  x72
12D8:  MOVWF  x71
12DA:  MOVLW  63
12DC:  MOVWF  x70
12DE:  MOVLW  86
12E0:  MOVWF  x6F
12E2:  CLRF   x76
12E4:  MOVLW  C0
12E6:  MOVWF  x75
12E8:  MOVLW  7F
12EA:  MOVWF  x74
12EC:  MOVLW  87
12EE:  MOVWF  x73
12F0:  CLRF   x7A
12F2:  MOVLW  C0
12F4:  MOVWF  x79
12F6:  MOVLW  7F
12F8:  MOVWF  x78
12FA:  MOVLW  88
12FC:  MOVWF  x77
12FE:  CLRF   x7E
1300:  MOVLW  D0
1302:  MOVWF  x7D
1304:  MOVLW  3F
1306:  MOVWF  x7C
1308:  MOVLW  89
130A:  MOVWF  x7B
130C:  MOVLB  0
130E:  RCALL  0D50
.................... } 
1310:  GOTO   2370 (RETURN)
....................  
.................... /*======================================================*/ 
.................... /*  Type TP_duPI                                        */ 
.................... /*======================================================*/ 
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label NBdu                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_duPI_NBdu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PI_salida.min,PI_salida.max,PI_salida.step,NBdu.a,NBdu.b,NBdu.c); 
*
135E:  MOVFF  362,366
1362:  MOVFF  361,365
1366:  MOVFF  360,364
136A:  MOVFF  35F,363
136E:  MOVFF  46,36A
1372:  MOVFF  45,369
1376:  MOVFF  44,368
137A:  MOVFF  43,367
137E:  MOVFF  4A,36E
1382:  MOVFF  49,36D
1386:  MOVFF  48,36C
138A:  MOVFF  47,36B
138E:  MOVFF  4E,372
1392:  MOVFF  4D,371
1396:  MOVFF  4C,370
139A:  MOVFF  4B,36F
139E:  MOVFF  8E,376
13A2:  MOVFF  8D,375
13A6:  MOVFF  8C,374
13AA:  MOVFF  8B,373
13AE:  MOVFF  92,37A
13B2:  MOVFF  91,379
13B6:  MOVFF  90,378
13BA:  MOVFF  8F,377
13BE:  MOVFF  96,37E
13C2:  MOVFF  95,37D
13C6:  MOVFF  94,37C
13CA:  MOVFF  93,37B
13CE:  RCALL  0D50
.................... } 
13D0:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label NSdu                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_duPI_NSdu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PI_salida.min,PI_salida.max,PI_salida.step,NSdu.a,NSdu.b,NSdu.c); 
13D2:  MOVFF  362,366
13D6:  MOVFF  361,365
13DA:  MOVFF  360,364
13DE:  MOVFF  35F,363
13E2:  MOVFF  46,36A
13E6:  MOVFF  45,369
13EA:  MOVFF  44,368
13EE:  MOVFF  43,367
13F2:  MOVFF  4A,36E
13F6:  MOVFF  49,36D
13FA:  MOVFF  48,36C
13FE:  MOVFF  47,36B
1402:  MOVFF  4E,372
1406:  MOVFF  4D,371
140A:  MOVFF  4C,370
140E:  MOVFF  4B,36F
1412:  MOVFF  9A,376
1416:  MOVFF  99,375
141A:  MOVFF  98,374
141E:  MOVFF  97,373
1422:  MOVFF  9E,37A
1426:  MOVFF  9D,379
142A:  MOVFF  9C,378
142E:  MOVFF  9B,377
1432:  MOVFF  A2,37E
1436:  MOVFF  A1,37D
143A:  MOVFF  A0,37C
143E:  MOVFF  9F,37B
1442:  RCALL  0D50
.................... } 
1444:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label Zdu                           */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_duPI_Zdu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PI_salida.min,PI_salida.max,PI_salida.step,Zdu.a,Zdu.b,Zdu.c); 
1446:  MOVFF  362,366
144A:  MOVFF  361,365
144E:  MOVFF  360,364
1452:  MOVFF  35F,363
1456:  MOVFF  46,36A
145A:  MOVFF  45,369
145E:  MOVFF  44,368
1462:  MOVFF  43,367
1466:  MOVFF  4A,36E
146A:  MOVFF  49,36D
146E:  MOVFF  48,36C
1472:  MOVFF  47,36B
1476:  MOVFF  4E,372
147A:  MOVFF  4D,371
147E:  MOVFF  4C,370
1482:  MOVFF  4B,36F
1486:  MOVFF  A6,376
148A:  MOVFF  A5,375
148E:  MOVFF  A4,374
1492:  MOVFF  A3,373
1496:  MOVFF  AA,37A
149A:  MOVFF  A9,379
149E:  MOVFF  A8,378
14A2:  MOVFF  A7,377
14A6:  MOVFF  AE,37E
14AA:  MOVFF  AD,37D
14AE:  MOVFF  AC,37C
14B2:  MOVFF  AB,37B
14B6:  RCALL  0D50
.................... } 
14B8:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label PSdu                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_duPI_PSdu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PI_salida.min,PI_salida.max,PI_salida.step,PSdu.a,PSdu.b,PSdu.c); 
14BA:  MOVFF  362,366
14BE:  MOVFF  361,365
14C2:  MOVFF  360,364
14C6:  MOVFF  35F,363
14CA:  MOVFF  46,36A
14CE:  MOVFF  45,369
14D2:  MOVFF  44,368
14D6:  MOVFF  43,367
14DA:  MOVFF  4A,36E
14DE:  MOVFF  49,36D
14E2:  MOVFF  48,36C
14E6:  MOVFF  47,36B
14EA:  MOVFF  4E,372
14EE:  MOVFF  4D,371
14F2:  MOVFF  4C,370
14F6:  MOVFF  4B,36F
14FA:  MOVFF  B2,376
14FE:  MOVFF  B1,375
1502:  MOVFF  B0,374
1506:  MOVFF  AF,373
150A:  MOVFF  B6,37A
150E:  MOVFF  B5,379
1512:  MOVFF  B4,378
1516:  MOVFF  B3,377
151A:  MOVFF  BA,37E
151E:  MOVFF  B9,37D
1522:  MOVFF  B8,37C
1526:  MOVFF  B7,37B
152A:  RCALL  0D50
.................... } 
152C:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label PBdu                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_duPI_PBdu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PI_salida.min,PI_salida.max,PI_salida.step,PBdu.a,PBdu.b,PBdu.c); 
152E:  MOVFF  362,366
1532:  MOVFF  361,365
1536:  MOVFF  360,364
153A:  MOVFF  35F,363
153E:  MOVFF  46,36A
1542:  MOVFF  45,369
1546:  MOVFF  44,368
154A:  MOVFF  43,367
154E:  MOVFF  4A,36E
1552:  MOVFF  49,36D
1556:  MOVFF  48,36C
155A:  MOVFF  47,36B
155E:  MOVFF  4E,372
1562:  MOVFF  4D,371
1566:  MOVFF  4C,370
156A:  MOVFF  4B,36F
156E:  MOVFF  BE,376
1572:  MOVFF  BD,375
1576:  MOVFF  BC,374
157A:  MOVFF  BB,373
157E:  MOVFF  C2,37A
1582:  MOVFF  C1,379
1586:  MOVFF  C0,378
158A:  MOVFF  BF,377
158E:  MOVFF  C6,37E
1592:  MOVFF  C5,37D
1596:  MOVFF  C4,37C
159A:  MOVFF  C3,37B
159E:  CALL   0D50
.................... } 
15A2:  RETLW  00
....................  
.................... /*======================================================*/ 
.................... /*  Type TP_uPD                                         */ 
.................... /*======================================================*/ 
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label NBu                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_uPD_NBu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PD_salida.min,PD_salida.max,PD_salida.step,NBu.a,NBu.b,NBu.c); 
15A4:  MOVFF  362,366
15A8:  MOVFF  361,365
15AC:  MOVFF  360,364
15B0:  MOVFF  35F,363
15B4:  MOVFF  3A,36A
15B8:  MOVFF  39,369
15BC:  MOVFF  38,368
15C0:  MOVFF  37,367
15C4:  MOVFF  3E,36E
15C8:  MOVFF  3D,36D
15CC:  MOVFF  3C,36C
15D0:  MOVFF  3B,36B
15D4:  MOVFF  42,372
15D8:  MOVFF  41,371
15DC:  MOVFF  40,370
15E0:  MOVFF  3F,36F
15E4:  MOVFF  52,376
15E8:  MOVFF  51,375
15EC:  MOVFF  50,374
15F0:  MOVFF  4F,373
15F4:  MOVFF  56,37A
15F8:  MOVFF  55,379
15FC:  MOVFF  54,378
1600:  MOVFF  53,377
1604:  MOVFF  5A,37E
1608:  MOVFF  59,37D
160C:  MOVFF  58,37C
1610:  MOVFF  57,37B
1614:  CALL   0D50
.................... } 
1618:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label NSu                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_uPD_NSu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PD_salida.min,PD_salida.max,PD_salida.step,NSu.a,NSu.b,NSu.c); 
161A:  MOVFF  362,366
161E:  MOVFF  361,365
1622:  MOVFF  360,364
1626:  MOVFF  35F,363
162A:  MOVFF  3A,36A
162E:  MOVFF  39,369
1632:  MOVFF  38,368
1636:  MOVFF  37,367
163A:  MOVFF  3E,36E
163E:  MOVFF  3D,36D
1642:  MOVFF  3C,36C
1646:  MOVFF  3B,36B
164A:  MOVFF  42,372
164E:  MOVFF  41,371
1652:  MOVFF  40,370
1656:  MOVFF  3F,36F
165A:  MOVFF  5E,376
165E:  MOVFF  5D,375
1662:  MOVFF  5C,374
1666:  MOVFF  5B,373
166A:  MOVFF  62,37A
166E:  MOVFF  61,379
1672:  MOVFF  60,378
1676:  MOVFF  5F,377
167A:  MOVFF  66,37E
167E:  MOVFF  65,37D
1682:  MOVFF  64,37C
1686:  MOVFF  63,37B
168A:  CALL   0D50
.................... } 
168E:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label Zu                           */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_uPD_Zu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PD_salida.min,PD_salida.max,PD_salida.step,Zu.a,Zu.b,Zu.c); 
1690:  MOVFF  362,366
1694:  MOVFF  361,365
1698:  MOVFF  360,364
169C:  MOVFF  35F,363
16A0:  MOVFF  3A,36A
16A4:  MOVFF  39,369
16A8:  MOVFF  38,368
16AC:  MOVFF  37,367
16B0:  MOVFF  3E,36E
16B4:  MOVFF  3D,36D
16B8:  MOVFF  3C,36C
16BC:  MOVFF  3B,36B
16C0:  MOVFF  42,372
16C4:  MOVFF  41,371
16C8:  MOVFF  40,370
16CC:  MOVFF  3F,36F
16D0:  MOVFF  6A,376
16D4:  MOVFF  69,375
16D8:  MOVFF  68,374
16DC:  MOVFF  67,373
16E0:  MOVFF  6E,37A
16E4:  MOVFF  6D,379
16E8:  MOVFF  6C,378
16EC:  MOVFF  6B,377
16F0:  MOVFF  72,37E
16F4:  MOVFF  71,37D
16F8:  MOVFF  70,37C
16FC:  MOVFF  6F,37B
1700:  CALL   0D50
.................... } 
1704:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label PSu                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_uPD_PSu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PD_salida.min,PD_salida.max,PD_salida.step,PSu.a,PSu.b,PSu.c); 
1706:  MOVFF  362,366
170A:  MOVFF  361,365
170E:  MOVFF  360,364
1712:  MOVFF  35F,363
1716:  MOVFF  3A,36A
171A:  MOVFF  39,369
171E:  MOVFF  38,368
1722:  MOVFF  37,367
1726:  MOVFF  3E,36E
172A:  MOVFF  3D,36D
172E:  MOVFF  3C,36C
1732:  MOVFF  3B,36B
1736:  MOVFF  42,372
173A:  MOVFF  41,371
173E:  MOVFF  40,370
1742:  MOVFF  3F,36F
1746:  MOVFF  76,376
174A:  MOVFF  75,375
174E:  MOVFF  74,374
1752:  MOVFF  73,373
1756:  MOVFF  7A,37A
175A:  MOVFF  79,379
175E:  MOVFF  78,378
1762:  MOVFF  77,377
1766:  MOVFF  7E,37E
176A:  MOVFF  7D,37D
176E:  MOVFF  7C,37C
1772:  MOVFF  7B,37B
1776:  CALL   0D50
.................... } 
177A:  RETLW  00
....................  
.................... /*------------------------------------------------------*/ 
.................... /* Description of the label PBu                          */ 
.................... /*------------------------------------------------------*/ 
....................  
.................... static double TP_uPD_PBu_equal(double x){ 
....................    return MF_xfl_triangle_equal(x,PD_salida.min,PD_salida.max,PD_salida.step,PBu.a,PBu.b,PBu.c); 
177C:  MOVFF  362,366
1780:  MOVFF  361,365
1784:  MOVFF  360,364
1788:  MOVFF  35F,363
178C:  MOVFF  3A,36A
1790:  MOVFF  39,369
1794:  MOVFF  38,368
1798:  MOVFF  37,367
179C:  MOVFF  3E,36E
17A0:  MOVFF  3D,36D
17A4:  MOVFF  3C,36C
17A8:  MOVFF  3B,36B
17AC:  MOVFF  42,372
17B0:  MOVFF  41,371
17B4:  MOVFF  40,370
17B8:  MOVFF  3F,36F
17BC:  MOVFF  82,376
17C0:  MOVFF  81,375
17C4:  MOVFF  80,374
17C8:  MOVFF  7F,373
17CC:  MOVFF  86,37A
17D0:  MOVFF  85,379
17D4:  MOVFF  84,378
17D8:  MOVFF  83,377
17DC:  MOVFF  8A,37E
17E0:  MOVFF  89,37D
17E4:  MOVFF  88,37C
17E8:  MOVFF  87,37B
17EC:  CALL   0D50
.................... } 
17F0:  RETLW  00
....................  
.................... /*======================================================*/ 
.................... /*  Rulebase RL_rules                                   */ 
.................... /*======================================================*/ 
....................  
.................... static void RL_rules(double e, double de, double *U, Universo salida) { 
....................  double _rl; 
....................  
....................  double _U_degree[25]; 
....................  FuzzyNumber _U; 
....................  _U.min = salida.min;  //minimo del universo de la variable de control 
*
21D6:  MOVFF  242,2B6
21DA:  MOVFF  241,2B5
21DE:  MOVFF  240,2B4
21E2:  MOVFF  23F,2B3
....................  _U.max = salida.max;  //maximo del universo de la variable de control 
21E6:  MOVFF  246,2BA
21EA:  MOVFF  245,2B9
21EE:  MOVFF  244,2B8
21F2:  MOVFF  243,2B7
....................  _U.step = salida.step; 
21F6:  MOVFF  24A,2BE
21FA:  MOVFF  249,2BD
21FE:  MOVFF  248,2BC
2202:  MOVFF  247,2BB
....................  _U.length = 25;  //cantidad de reglas 
2206:  MOVLW  19
2208:  MOVLB  2
220A:  MOVWF  xC7
....................  _U.degree = _U_degree;  //grado de pertenencia de cada regla(grado de aplicabilidad de cada regla) 
220C:  MOVLW  02
220E:  MOVWF  xC9
2210:  MOVLW  4F
2212:  MOVWF  xC8
....................  int _U_i = 0; //counter 
....................  
....................  //determinando el grado de pertenencia de la entrada crisp a cada funcion  
....................  //de membresia fuzzy de las entradas 
....................  //y los almacena en los arreglos de las 2 entradas 
....................  double _e_eq[5]; 
2214:  CLRF   xCD
....................  _e_eq[0] = TP_e_NB_equal(e); 
2216:  MOVFF  238,2F9
221A:  MOVFF  237,2F8
221E:  MOVFF  236,2F7
2222:  MOVFF  235,2F6
2226:  MOVLB  0
2228:  GOTO   0EEC
222C:  MOVFF  03,2D1
2230:  MOVFF  02,2D0
2234:  MOVFF  01,2CF
2238:  MOVFF  00,2CE
....................  _e_eq[1] = TP_e_NS_equal(e); 
223C:  MOVFF  238,2F9
2240:  MOVFF  237,2F8
2244:  MOVFF  236,2F7
2248:  MOVFF  235,2F6
224C:  GOTO   0F5A
2250:  MOVFF  03,2D5
2254:  MOVFF  02,2D4
2258:  MOVFF  01,2D3
225C:  MOVFF  00,2D2
....................  _e_eq[2] = TP_e_Z_equal(e); 
2260:  MOVFF  238,2F9
2264:  MOVFF  237,2F8
2268:  MOVFF  236,2F7
226C:  MOVFF  235,2F6
2270:  GOTO   0FC2
2274:  MOVFF  03,2D9
2278:  MOVFF  02,2D8
227C:  MOVFF  01,2D7
2280:  MOVFF  00,2D6
....................  _e_eq[3] = TP_e_PS_equal(e); 
2284:  MOVFF  238,2F9
2288:  MOVFF  237,2F8
228C:  MOVFF  236,2F7
2290:  MOVFF  235,2F6
2294:  GOTO   102A
2298:  MOVFF  03,2DD
229C:  MOVFF  02,2DC
22A0:  MOVFF  01,2DB
22A4:  MOVFF  00,2DA
....................  _e_eq[4] = TP_e_PB_equal(e); 
22A8:  MOVFF  238,2F9
22AC:  MOVFF  237,2F8
22B0:  MOVFF  236,2F7
22B4:  MOVFF  235,2F6
22B8:  GOTO   1092
22BC:  MOVFF  03,2E1
22C0:  MOVFF  02,2E0
22C4:  MOVFF  01,2DF
22C8:  MOVFF  00,2DE
....................  
....................  double _de_eq[5]; 
....................  _de_eq[0] = TP_de_DB_equal(de); 
22CC:  MOVFF  23C,2F9
22D0:  MOVFF  23B,2F8
22D4:  MOVFF  23A,2F7
22D8:  MOVFF  239,2F6
22DC:  GOTO   1100
22E0:  MOVFF  03,2E5
22E4:  MOVFF  02,2E4
22E8:  MOVFF  01,2E3
22EC:  MOVFF  00,2E2
....................  _de_eq[1] = TP_de_DS_equal(de); 
22F0:  MOVFF  23C,2F9
22F4:  MOVFF  23B,2F8
22F8:  MOVFF  23A,2F7
22FC:  MOVFF  239,2F6
2300:  GOTO   116E
2304:  MOVFF  03,2E9
2308:  MOVFF  02,2E8
230C:  MOVFF  01,2E7
2310:  MOVFF  00,2E6
....................  _de_eq[2] = TP_de_Z_equal(de); 
2314:  MOVFF  23C,2F9
2318:  MOVFF  23B,2F8
231C:  MOVFF  23A,2F7
2320:  MOVFF  239,2F6
2324:  GOTO   11D6
2328:  MOVFF  03,2ED
232C:  MOVFF  02,2EC
2330:  MOVFF  01,2EB
2334:  MOVFF  00,2EA
....................  _de_eq[3] = TP_de_IS_equal(de); 
2338:  MOVFF  23C,2F9
233C:  MOVFF  23B,2F8
2340:  MOVFF  23A,2F7
2344:  MOVFF  239,2F6
2348:  GOTO   123E
234C:  MOVFF  03,2F1
2350:  MOVFF  02,2F0
2354:  MOVFF  01,2EF
2358:  MOVFF  00,2EE
....................  _de_eq[4] = TP_de_IB_equal(de); 
235C:  MOVFF  23C,2F9
2360:  MOVFF  23B,2F8
2364:  MOVFF  23A,2F7
2368:  MOVFF  239,2F6
236C:  GOTO   12A6
2370:  MOVFF  03,2F5
2374:  MOVFF  02,2F4
2378:  MOVFF  01,2F3
237C:  MOVFF  00,2F2
....................   
....................  //calculan los minimos(and es minimo) para todas las posibles combinaciones 
....................  //de las funciones de membresia activadas para  
....................  //todo el conjunto de entradas 
....................   
....................  //Regla 0 
....................  _rl = OP_myOperations_And(_e_eq[0],_de_eq[0]); //NB,DB=NBu 
2380:  MOVFF  2D1,2F9
2384:  MOVFF  2D0,2F8
2388:  MOVFF  2CF,2F7
238C:  MOVFF  2CE,2F6
2390:  MOVFF  2E5,2FD
2394:  MOVFF  2E4,2FC
2398:  MOVFF  2E3,2FB
239C:  MOVFF  2E2,2FA
23A0:  CALL   1314
23A4:  MOVFF  03,24E
23A8:  MOVFF  02,24D
23AC:  MOVFF  01,24C
23B0:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
23B4:  MOVLB  2
23B6:  MOVF   xCD,W
23B8:  MULLW  04
23BA:  MOVF   FF3,W
23BC:  CLRF   03
23BE:  ADDLW  4F
23C0:  MOVWF  FE9
23C2:  MOVLW  02
23C4:  ADDWFC 03,W
23C6:  MOVWF  FEA
23C8:  MOVFF  24B,FEF
23CC:  MOVFF  24C,FEC
23D0:  MOVFF  24D,FEC
23D4:  MOVFF  24E,FEC
....................  _U_i++;  
23D8:  INCF   xCD,F
....................  
....................  //Regla 1 
....................  _rl = OP_myOperations_And(_e_eq[0],_de_eq[1]); //NB,DS=NBu 
23DA:  MOVFF  2D1,2F9
23DE:  MOVFF  2D0,2F8
23E2:  MOVFF  2CF,2F7
23E6:  MOVFF  2CE,2F6
23EA:  MOVFF  2E9,2FD
23EE:  MOVFF  2E8,2FC
23F2:  MOVFF  2E7,2FB
23F6:  MOVFF  2E6,2FA
23FA:  MOVLB  0
23FC:  CALL   1314
2400:  MOVFF  03,24E
2404:  MOVFF  02,24D
2408:  MOVFF  01,24C
240C:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2410:  MOVLB  2
2412:  MOVF   xCD,W
2414:  MULLW  04
2416:  MOVF   FF3,W
2418:  CLRF   03
241A:  ADDLW  4F
241C:  MOVWF  FE9
241E:  MOVLW  02
2420:  ADDWFC 03,W
2422:  MOVWF  FEA
2424:  MOVFF  24B,FEF
2428:  MOVFF  24C,FEC
242C:  MOVFF  24D,FEC
2430:  MOVFF  24E,FEC
....................  _U_i++;   
2434:  INCF   xCD,F
....................  
....................  //Regla 2 
....................  _rl = OP_myOperations_And(_e_eq[0],_de_eq[2]); //NB,Z=NBu 
2436:  MOVFF  2D1,2F9
243A:  MOVFF  2D0,2F8
243E:  MOVFF  2CF,2F7
2442:  MOVFF  2CE,2F6
2446:  MOVFF  2ED,2FD
244A:  MOVFF  2EC,2FC
244E:  MOVFF  2EB,2FB
2452:  MOVFF  2EA,2FA
2456:  MOVLB  0
2458:  CALL   1314
245C:  MOVFF  03,24E
2460:  MOVFF  02,24D
2464:  MOVFF  01,24C
2468:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
246C:  MOVLB  2
246E:  MOVF   xCD,W
2470:  MULLW  04
2472:  MOVF   FF3,W
2474:  CLRF   03
2476:  ADDLW  4F
2478:  MOVWF  FE9
247A:  MOVLW  02
247C:  ADDWFC 03,W
247E:  MOVWF  FEA
2480:  MOVFF  24B,FEF
2484:  MOVFF  24C,FEC
2488:  MOVFF  24D,FEC
248C:  MOVFF  24E,FEC
....................  _U_i++;   
2490:  INCF   xCD,F
....................  
....................  //Regla 3 
....................  _rl = OP_myOperations_And(_e_eq[0],_de_eq[3]); //NB,IS=NBu 
2492:  MOVFF  2D1,2F9
2496:  MOVFF  2D0,2F8
249A:  MOVFF  2CF,2F7
249E:  MOVFF  2CE,2F6
24A2:  MOVFF  2F1,2FD
24A6:  MOVFF  2F0,2FC
24AA:  MOVFF  2EF,2FB
24AE:  MOVFF  2EE,2FA
24B2:  MOVLB  0
24B4:  CALL   1314
24B8:  MOVFF  03,24E
24BC:  MOVFF  02,24D
24C0:  MOVFF  01,24C
24C4:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
24C8:  MOVLB  2
24CA:  MOVF   xCD,W
24CC:  MULLW  04
24CE:  MOVF   FF3,W
24D0:  CLRF   03
24D2:  ADDLW  4F
24D4:  MOVWF  FE9
24D6:  MOVLW  02
24D8:  ADDWFC 03,W
24DA:  MOVWF  FEA
24DC:  MOVFF  24B,FEF
24E0:  MOVFF  24C,FEC
24E4:  MOVFF  24D,FEC
24E8:  MOVFF  24E,FEC
....................  _U_i++;	  
24EC:  INCF   xCD,F
....................  
....................  //Regla 4 
....................  _rl = OP_myOperations_And(_e_eq[0],_de_eq[4]); //NB,IB=NBu 
24EE:  MOVFF  2D1,2F9
24F2:  MOVFF  2D0,2F8
24F6:  MOVFF  2CF,2F7
24FA:  MOVFF  2CE,2F6
24FE:  MOVFF  2F5,2FD
2502:  MOVFF  2F4,2FC
2506:  MOVFF  2F3,2FB
250A:  MOVFF  2F2,2FA
250E:  MOVLB  0
2510:  CALL   1314
2514:  MOVFF  03,24E
2518:  MOVFF  02,24D
251C:  MOVFF  01,24C
2520:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2524:  MOVLB  2
2526:  MOVF   xCD,W
2528:  MULLW  04
252A:  MOVF   FF3,W
252C:  CLRF   03
252E:  ADDLW  4F
2530:  MOVWF  FE9
2532:  MOVLW  02
2534:  ADDWFC 03,W
2536:  MOVWF  FEA
2538:  MOVFF  24B,FEF
253C:  MOVFF  24C,FEC
2540:  MOVFF  24D,FEC
2544:  MOVFF  24E,FEC
....................  _U_i++;   
2548:  INCF   xCD,F
....................  
....................  //Regla 5 
....................  _rl = OP_myOperations_And(_e_eq[1],_de_eq[0]); //NS,DB=NSu 
254A:  MOVFF  2D5,2F9
254E:  MOVFF  2D4,2F8
2552:  MOVFF  2D3,2F7
2556:  MOVFF  2D2,2F6
255A:  MOVFF  2E5,2FD
255E:  MOVFF  2E4,2FC
2562:  MOVFF  2E3,2FB
2566:  MOVFF  2E2,2FA
256A:  MOVLB  0
256C:  CALL   1314
2570:  MOVFF  03,24E
2574:  MOVFF  02,24D
2578:  MOVFF  01,24C
257C:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2580:  MOVLB  2
2582:  MOVF   xCD,W
2584:  MULLW  04
2586:  MOVF   FF3,W
2588:  CLRF   03
258A:  ADDLW  4F
258C:  MOVWF  FE9
258E:  MOVLW  02
2590:  ADDWFC 03,W
2592:  MOVWF  FEA
2594:  MOVFF  24B,FEF
2598:  MOVFF  24C,FEC
259C:  MOVFF  24D,FEC
25A0:  MOVFF  24E,FEC
....................  _U_i++;   
25A4:  INCF   xCD,F
....................  
....................  //Regla 6 
....................  _rl = OP_myOperations_And(_e_eq[1],_de_eq[1]); //NS,DS=NSu 
25A6:  MOVFF  2D5,2F9
25AA:  MOVFF  2D4,2F8
25AE:  MOVFF  2D3,2F7
25B2:  MOVFF  2D2,2F6
25B6:  MOVFF  2E9,2FD
25BA:  MOVFF  2E8,2FC
25BE:  MOVFF  2E7,2FB
25C2:  MOVFF  2E6,2FA
25C6:  MOVLB  0
25C8:  CALL   1314
25CC:  MOVFF  03,24E
25D0:  MOVFF  02,24D
25D4:  MOVFF  01,24C
25D8:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
25DC:  MOVLB  2
25DE:  MOVF   xCD,W
25E0:  MULLW  04
25E2:  MOVF   FF3,W
25E4:  CLRF   03
25E6:  ADDLW  4F
25E8:  MOVWF  FE9
25EA:  MOVLW  02
25EC:  ADDWFC 03,W
25EE:  MOVWF  FEA
25F0:  MOVFF  24B,FEF
25F4:  MOVFF  24C,FEC
25F8:  MOVFF  24D,FEC
25FC:  MOVFF  24E,FEC
....................  _U_i++;   
2600:  INCF   xCD,F
....................  
....................  //Regla 7 
....................  _rl = OP_myOperations_And(_e_eq[1],_de_eq[2]); //NS,Z=NSu 
2602:  MOVFF  2D5,2F9
2606:  MOVFF  2D4,2F8
260A:  MOVFF  2D3,2F7
260E:  MOVFF  2D2,2F6
2612:  MOVFF  2ED,2FD
2616:  MOVFF  2EC,2FC
261A:  MOVFF  2EB,2FB
261E:  MOVFF  2EA,2FA
2622:  MOVLB  0
2624:  CALL   1314
2628:  MOVFF  03,24E
262C:  MOVFF  02,24D
2630:  MOVFF  01,24C
2634:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2638:  MOVLB  2
263A:  MOVF   xCD,W
263C:  MULLW  04
263E:  MOVF   FF3,W
2640:  CLRF   03
2642:  ADDLW  4F
2644:  MOVWF  FE9
2646:  MOVLW  02
2648:  ADDWFC 03,W
264A:  MOVWF  FEA
264C:  MOVFF  24B,FEF
2650:  MOVFF  24C,FEC
2654:  MOVFF  24D,FEC
2658:  MOVFF  24E,FEC
....................  _U_i++;   
265C:  INCF   xCD,F
....................  
....................  //Regla 8 
....................  _rl = OP_myOperations_And(_e_eq[1],_de_eq[3]); //NS,IS=NSu 
265E:  MOVFF  2D5,2F9
2662:  MOVFF  2D4,2F8
2666:  MOVFF  2D3,2F7
266A:  MOVFF  2D2,2F6
266E:  MOVFF  2F1,2FD
2672:  MOVFF  2F0,2FC
2676:  MOVFF  2EF,2FB
267A:  MOVFF  2EE,2FA
267E:  MOVLB  0
2680:  CALL   1314
2684:  MOVFF  03,24E
2688:  MOVFF  02,24D
268C:  MOVFF  01,24C
2690:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2694:  MOVLB  2
2696:  MOVF   xCD,W
2698:  MULLW  04
269A:  MOVF   FF3,W
269C:  CLRF   03
269E:  ADDLW  4F
26A0:  MOVWF  FE9
26A2:  MOVLW  02
26A4:  ADDWFC 03,W
26A6:  MOVWF  FEA
26A8:  MOVFF  24B,FEF
26AC:  MOVFF  24C,FEC
26B0:  MOVFF  24D,FEC
26B4:  MOVFF  24E,FEC
....................  _U_i++;   
26B8:  INCF   xCD,F
....................  
....................  //Regla 9 
....................  _rl = OP_myOperations_And(_e_eq[1],_de_eq[4]); //NS,IB=NBu 
26BA:  MOVFF  2D5,2F9
26BE:  MOVFF  2D4,2F8
26C2:  MOVFF  2D3,2F7
26C6:  MOVFF  2D2,2F6
26CA:  MOVFF  2F5,2FD
26CE:  MOVFF  2F4,2FC
26D2:  MOVFF  2F3,2FB
26D6:  MOVFF  2F2,2FA
26DA:  MOVLB  0
26DC:  CALL   1314
26E0:  MOVFF  03,24E
26E4:  MOVFF  02,24D
26E8:  MOVFF  01,24C
26EC:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
26F0:  MOVLB  2
26F2:  MOVF   xCD,W
26F4:  MULLW  04
26F6:  MOVF   FF3,W
26F8:  CLRF   03
26FA:  ADDLW  4F
26FC:  MOVWF  FE9
26FE:  MOVLW  02
2700:  ADDWFC 03,W
2702:  MOVWF  FEA
2704:  MOVFF  24B,FEF
2708:  MOVFF  24C,FEC
270C:  MOVFF  24D,FEC
2710:  MOVFF  24E,FEC
....................  _U_i++;   
2714:  INCF   xCD,F
....................  
....................  //Regla 10 
....................  _rl = OP_myOperations_And(_e_eq[2],_de_eq[0]); //Z,DB=Zu 
2716:  MOVFF  2D9,2F9
271A:  MOVFF  2D8,2F8
271E:  MOVFF  2D7,2F7
2722:  MOVFF  2D6,2F6
2726:  MOVFF  2E5,2FD
272A:  MOVFF  2E4,2FC
272E:  MOVFF  2E3,2FB
2732:  MOVFF  2E2,2FA
2736:  MOVLB  0
2738:  CALL   1314
273C:  MOVFF  03,24E
2740:  MOVFF  02,24D
2744:  MOVFF  01,24C
2748:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
274C:  MOVLB  2
274E:  MOVF   xCD,W
2750:  MULLW  04
2752:  MOVF   FF3,W
2754:  CLRF   03
2756:  ADDLW  4F
2758:  MOVWF  FE9
275A:  MOVLW  02
275C:  ADDWFC 03,W
275E:  MOVWF  FEA
2760:  MOVFF  24B,FEF
2764:  MOVFF  24C,FEC
2768:  MOVFF  24D,FEC
276C:  MOVFF  24E,FEC
....................  _U_i++;   
2770:  INCF   xCD,F
....................   
....................  //Regla 11 
....................  _rl = OP_myOperations_And(_e_eq[2],_de_eq[1]); //Z,DS=Zu 
2772:  MOVFF  2D9,2F9
2776:  MOVFF  2D8,2F8
277A:  MOVFF  2D7,2F7
277E:  MOVFF  2D6,2F6
2782:  MOVFF  2E9,2FD
2786:  MOVFF  2E8,2FC
278A:  MOVFF  2E7,2FB
278E:  MOVFF  2E6,2FA
2792:  MOVLB  0
2794:  CALL   1314
2798:  MOVFF  03,24E
279C:  MOVFF  02,24D
27A0:  MOVFF  01,24C
27A4:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
27A8:  MOVLB  2
27AA:  MOVF   xCD,W
27AC:  MULLW  04
27AE:  MOVF   FF3,W
27B0:  CLRF   03
27B2:  ADDLW  4F
27B4:  MOVWF  FE9
27B6:  MOVLW  02
27B8:  ADDWFC 03,W
27BA:  MOVWF  FEA
27BC:  MOVFF  24B,FEF
27C0:  MOVFF  24C,FEC
27C4:  MOVFF  24D,FEC
27C8:  MOVFF  24E,FEC
....................  _U_i++;  
27CC:  INCF   xCD,F
....................   
....................  //Regla 12 
....................  _rl = OP_myOperations_And(_e_eq[2],_de_eq[2]); //Z,Z=Zu 
27CE:  MOVFF  2D9,2F9
27D2:  MOVFF  2D8,2F8
27D6:  MOVFF  2D7,2F7
27DA:  MOVFF  2D6,2F6
27DE:  MOVFF  2ED,2FD
27E2:  MOVFF  2EC,2FC
27E6:  MOVFF  2EB,2FB
27EA:  MOVFF  2EA,2FA
27EE:  MOVLB  0
27F0:  CALL   1314
27F4:  MOVFF  03,24E
27F8:  MOVFF  02,24D
27FC:  MOVFF  01,24C
2800:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2804:  MOVLB  2
2806:  MOVF   xCD,W
2808:  MULLW  04
280A:  MOVF   FF3,W
280C:  CLRF   03
280E:  ADDLW  4F
2810:  MOVWF  FE9
2812:  MOVLW  02
2814:  ADDWFC 03,W
2816:  MOVWF  FEA
2818:  MOVFF  24B,FEF
281C:  MOVFF  24C,FEC
2820:  MOVFF  24D,FEC
2824:  MOVFF  24E,FEC
....................  _U_i++;  
2828:  INCF   xCD,F
....................   
....................  //Regla 13 
....................  _rl = OP_myOperations_And(_e_eq[2],_de_eq[3]); //Z,IS=Zu 
282A:  MOVFF  2D9,2F9
282E:  MOVFF  2D8,2F8
2832:  MOVFF  2D7,2F7
2836:  MOVFF  2D6,2F6
283A:  MOVFF  2F1,2FD
283E:  MOVFF  2F0,2FC
2842:  MOVFF  2EF,2FB
2846:  MOVFF  2EE,2FA
284A:  MOVLB  0
284C:  CALL   1314
2850:  MOVFF  03,24E
2854:  MOVFF  02,24D
2858:  MOVFF  01,24C
285C:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2860:  MOVLB  2
2862:  MOVF   xCD,W
2864:  MULLW  04
2866:  MOVF   FF3,W
2868:  CLRF   03
286A:  ADDLW  4F
286C:  MOVWF  FE9
286E:  MOVLW  02
2870:  ADDWFC 03,W
2872:  MOVWF  FEA
2874:  MOVFF  24B,FEF
2878:  MOVFF  24C,FEC
287C:  MOVFF  24D,FEC
2880:  MOVFF  24E,FEC
....................  _U_i++; 
2884:  INCF   xCD,F
....................   
....................  //Regla 14 
....................  _rl = OP_myOperations_And(_e_eq[2],_de_eq[4]); //Z,IB=Zu 
2886:  MOVFF  2D9,2F9
288A:  MOVFF  2D8,2F8
288E:  MOVFF  2D7,2F7
2892:  MOVFF  2D6,2F6
2896:  MOVFF  2F5,2FD
289A:  MOVFF  2F4,2FC
289E:  MOVFF  2F3,2FB
28A2:  MOVFF  2F2,2FA
28A6:  MOVLB  0
28A8:  CALL   1314
28AC:  MOVFF  03,24E
28B0:  MOVFF  02,24D
28B4:  MOVFF  01,24C
28B8:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
28BC:  MOVLB  2
28BE:  MOVF   xCD,W
28C0:  MULLW  04
28C2:  MOVF   FF3,W
28C4:  CLRF   03
28C6:  ADDLW  4F
28C8:  MOVWF  FE9
28CA:  MOVLW  02
28CC:  ADDWFC 03,W
28CE:  MOVWF  FEA
28D0:  MOVFF  24B,FEF
28D4:  MOVFF  24C,FEC
28D8:  MOVFF  24D,FEC
28DC:  MOVFF  24E,FEC
....................  _U_i++; 
28E0:  INCF   xCD,F
....................  
....................  //Regla 15 
....................  _rl = OP_myOperations_And(_e_eq[3],_de_eq[0]); //PS,DB=PSu 
28E2:  MOVFF  2DD,2F9
28E6:  MOVFF  2DC,2F8
28EA:  MOVFF  2DB,2F7
28EE:  MOVFF  2DA,2F6
28F2:  MOVFF  2E5,2FD
28F6:  MOVFF  2E4,2FC
28FA:  MOVFF  2E3,2FB
28FE:  MOVFF  2E2,2FA
2902:  MOVLB  0
2904:  CALL   1314
2908:  MOVFF  03,24E
290C:  MOVFF  02,24D
2910:  MOVFF  01,24C
2914:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2918:  MOVLB  2
291A:  MOVF   xCD,W
291C:  MULLW  04
291E:  MOVF   FF3,W
2920:  CLRF   03
2922:  ADDLW  4F
2924:  MOVWF  FE9
2926:  MOVLW  02
2928:  ADDWFC 03,W
292A:  MOVWF  FEA
292C:  MOVFF  24B,FEF
2930:  MOVFF  24C,FEC
2934:  MOVFF  24D,FEC
2938:  MOVFF  24E,FEC
....................  _U_i++;   
293C:  INCF   xCD,F
....................  
....................  //Regla 16 
....................  _rl = OP_myOperations_And(_e_eq[3],_de_eq[1]); //PS,DS=PSu 
293E:  MOVFF  2DD,2F9
2942:  MOVFF  2DC,2F8
2946:  MOVFF  2DB,2F7
294A:  MOVFF  2DA,2F6
294E:  MOVFF  2E9,2FD
2952:  MOVFF  2E8,2FC
2956:  MOVFF  2E7,2FB
295A:  MOVFF  2E6,2FA
295E:  MOVLB  0
2960:  CALL   1314
2964:  MOVFF  03,24E
2968:  MOVFF  02,24D
296C:  MOVFF  01,24C
2970:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2974:  MOVLB  2
2976:  MOVF   xCD,W
2978:  MULLW  04
297A:  MOVF   FF3,W
297C:  CLRF   03
297E:  ADDLW  4F
2980:  MOVWF  FE9
2982:  MOVLW  02
2984:  ADDWFC 03,W
2986:  MOVWF  FEA
2988:  MOVFF  24B,FEF
298C:  MOVFF  24C,FEC
2990:  MOVFF  24D,FEC
2994:  MOVFF  24E,FEC
....................  _U_i++;   
2998:  INCF   xCD,F
....................  
....................  //Regla 17 
....................  _rl = OP_myOperations_And(_e_eq[3],_de_eq[2]); //PS,Z=PSu 
299A:  MOVFF  2DD,2F9
299E:  MOVFF  2DC,2F8
29A2:  MOVFF  2DB,2F7
29A6:  MOVFF  2DA,2F6
29AA:  MOVFF  2ED,2FD
29AE:  MOVFF  2EC,2FC
29B2:  MOVFF  2EB,2FB
29B6:  MOVFF  2EA,2FA
29BA:  MOVLB  0
29BC:  CALL   1314
29C0:  MOVFF  03,24E
29C4:  MOVFF  02,24D
29C8:  MOVFF  01,24C
29CC:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
29D0:  MOVLB  2
29D2:  MOVF   xCD,W
29D4:  MULLW  04
29D6:  MOVF   FF3,W
29D8:  CLRF   03
29DA:  ADDLW  4F
29DC:  MOVWF  FE9
29DE:  MOVLW  02
29E0:  ADDWFC 03,W
29E2:  MOVWF  FEA
29E4:  MOVFF  24B,FEF
29E8:  MOVFF  24C,FEC
29EC:  MOVFF  24D,FEC
29F0:  MOVFF  24E,FEC
....................  _U_i++;   
29F4:  INCF   xCD,F
....................  
....................  //Regla 18 
....................  _rl = OP_myOperations_And(_e_eq[3],_de_eq[3]); //PS,IS=PSu 
29F6:  MOVFF  2DD,2F9
29FA:  MOVFF  2DC,2F8
29FE:  MOVFF  2DB,2F7
2A02:  MOVFF  2DA,2F6
2A06:  MOVFF  2F1,2FD
2A0A:  MOVFF  2F0,2FC
2A0E:  MOVFF  2EF,2FB
2A12:  MOVFF  2EE,2FA
2A16:  MOVLB  0
2A18:  CALL   1314
2A1C:  MOVFF  03,24E
2A20:  MOVFF  02,24D
2A24:  MOVFF  01,24C
2A28:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2A2C:  MOVLB  2
2A2E:  MOVF   xCD,W
2A30:  MULLW  04
2A32:  MOVF   FF3,W
2A34:  CLRF   03
2A36:  ADDLW  4F
2A38:  MOVWF  FE9
2A3A:  MOVLW  02
2A3C:  ADDWFC 03,W
2A3E:  MOVWF  FEA
2A40:  MOVFF  24B,FEF
2A44:  MOVFF  24C,FEC
2A48:  MOVFF  24D,FEC
2A4C:  MOVFF  24E,FEC
....................  _U_i++;   
2A50:  INCF   xCD,F
....................  
....................  //Regla 19 
....................  _rl = OP_myOperations_And(_e_eq[3],_de_eq[4]); //PS,IB=PBu 
2A52:  MOVFF  2DD,2F9
2A56:  MOVFF  2DC,2F8
2A5A:  MOVFF  2DB,2F7
2A5E:  MOVFF  2DA,2F6
2A62:  MOVFF  2F5,2FD
2A66:  MOVFF  2F4,2FC
2A6A:  MOVFF  2F3,2FB
2A6E:  MOVFF  2F2,2FA
2A72:  MOVLB  0
2A74:  CALL   1314
2A78:  MOVFF  03,24E
2A7C:  MOVFF  02,24D
2A80:  MOVFF  01,24C
2A84:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2A88:  MOVLB  2
2A8A:  MOVF   xCD,W
2A8C:  MULLW  04
2A8E:  MOVF   FF3,W
2A90:  CLRF   03
2A92:  ADDLW  4F
2A94:  MOVWF  FE9
2A96:  MOVLW  02
2A98:  ADDWFC 03,W
2A9A:  MOVWF  FEA
2A9C:  MOVFF  24B,FEF
2AA0:  MOVFF  24C,FEC
2AA4:  MOVFF  24D,FEC
2AA8:  MOVFF  24E,FEC
....................  _U_i++;   
2AAC:  INCF   xCD,F
....................  
....................  //Regla 20 
....................  _rl = OP_myOperations_And(_e_eq[4],_de_eq[0]); //PB,DB=PBu 
2AAE:  MOVFF  2E1,2F9
2AB2:  MOVFF  2E0,2F8
2AB6:  MOVFF  2DF,2F7
2ABA:  MOVFF  2DE,2F6
2ABE:  MOVFF  2E5,2FD
2AC2:  MOVFF  2E4,2FC
2AC6:  MOVFF  2E3,2FB
2ACA:  MOVFF  2E2,2FA
2ACE:  MOVLB  0
2AD0:  CALL   1314
2AD4:  MOVFF  03,24E
2AD8:  MOVFF  02,24D
2ADC:  MOVFF  01,24C
2AE0:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2AE4:  MOVLB  2
2AE6:  MOVF   xCD,W
2AE8:  MULLW  04
2AEA:  MOVF   FF3,W
2AEC:  CLRF   03
2AEE:  ADDLW  4F
2AF0:  MOVWF  FE9
2AF2:  MOVLW  02
2AF4:  ADDWFC 03,W
2AF6:  MOVWF  FEA
2AF8:  MOVFF  24B,FEF
2AFC:  MOVFF  24C,FEC
2B00:  MOVFF  24D,FEC
2B04:  MOVFF  24E,FEC
....................  _U_i++;   
2B08:  INCF   xCD,F
....................  
....................  //Regla 21 
....................  _rl = OP_myOperations_And(_e_eq[4],_de_eq[1]); //PB,DS=PBu 
2B0A:  MOVFF  2E1,2F9
2B0E:  MOVFF  2E0,2F8
2B12:  MOVFF  2DF,2F7
2B16:  MOVFF  2DE,2F6
2B1A:  MOVFF  2E9,2FD
2B1E:  MOVFF  2E8,2FC
2B22:  MOVFF  2E7,2FB
2B26:  MOVFF  2E6,2FA
2B2A:  MOVLB  0
2B2C:  CALL   1314
2B30:  MOVFF  03,24E
2B34:  MOVFF  02,24D
2B38:  MOVFF  01,24C
2B3C:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2B40:  MOVLB  2
2B42:  MOVF   xCD,W
2B44:  MULLW  04
2B46:  MOVF   FF3,W
2B48:  CLRF   03
2B4A:  ADDLW  4F
2B4C:  MOVWF  FE9
2B4E:  MOVLW  02
2B50:  ADDWFC 03,W
2B52:  MOVWF  FEA
2B54:  MOVFF  24B,FEF
2B58:  MOVFF  24C,FEC
2B5C:  MOVFF  24D,FEC
2B60:  MOVFF  24E,FEC
....................  _U_i++;   
2B64:  INCF   xCD,F
....................  
....................  //Regla 22 
....................  _rl = OP_myOperations_And(_e_eq[4],_de_eq[2]); //PB,Z=PBu 
2B66:  MOVFF  2E1,2F9
2B6A:  MOVFF  2E0,2F8
2B6E:  MOVFF  2DF,2F7
2B72:  MOVFF  2DE,2F6
2B76:  MOVFF  2ED,2FD
2B7A:  MOVFF  2EC,2FC
2B7E:  MOVFF  2EB,2FB
2B82:  MOVFF  2EA,2FA
2B86:  MOVLB  0
2B88:  CALL   1314
2B8C:  MOVFF  03,24E
2B90:  MOVFF  02,24D
2B94:  MOVFF  01,24C
2B98:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2B9C:  MOVLB  2
2B9E:  MOVF   xCD,W
2BA0:  MULLW  04
2BA2:  MOVF   FF3,W
2BA4:  CLRF   03
2BA6:  ADDLW  4F
2BA8:  MOVWF  FE9
2BAA:  MOVLW  02
2BAC:  ADDWFC 03,W
2BAE:  MOVWF  FEA
2BB0:  MOVFF  24B,FEF
2BB4:  MOVFF  24C,FEC
2BB8:  MOVFF  24D,FEC
2BBC:  MOVFF  24E,FEC
....................  _U_i++;   
2BC0:  INCF   xCD,F
....................  
....................  //Regla 23 
....................  _rl = OP_myOperations_And(_e_eq[4],_de_eq[3]); //PB,IS=PBu 
2BC2:  MOVFF  2E1,2F9
2BC6:  MOVFF  2E0,2F8
2BCA:  MOVFF  2DF,2F7
2BCE:  MOVFF  2DE,2F6
2BD2:  MOVFF  2F1,2FD
2BD6:  MOVFF  2F0,2FC
2BDA:  MOVFF  2EF,2FB
2BDE:  MOVFF  2EE,2FA
2BE2:  MOVLB  0
2BE4:  CALL   1314
2BE8:  MOVFF  03,24E
2BEC:  MOVFF  02,24D
2BF0:  MOVFF  01,24C
2BF4:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2BF8:  MOVLB  2
2BFA:  MOVF   xCD,W
2BFC:  MULLW  04
2BFE:  MOVF   FF3,W
2C00:  CLRF   03
2C02:  ADDLW  4F
2C04:  MOVWF  FE9
2C06:  MOVLW  02
2C08:  ADDWFC 03,W
2C0A:  MOVWF  FEA
2C0C:  MOVFF  24B,FEF
2C10:  MOVFF  24C,FEC
2C14:  MOVFF  24D,FEC
2C18:  MOVFF  24E,FEC
....................  _U_i++;   
2C1C:  INCF   xCD,F
....................  
....................  //Regla 24 
....................  _rl = OP_myOperations_And(_e_eq[4],_de_eq[4]); //PB,IB=PBu 
2C1E:  MOVFF  2E1,2F9
2C22:  MOVFF  2E0,2F8
2C26:  MOVFF  2DF,2F7
2C2A:  MOVFF  2DE,2F6
2C2E:  MOVFF  2F5,2FD
2C32:  MOVFF  2F4,2FC
2C36:  MOVFF  2F3,2FB
2C3A:  MOVFF  2F2,2FA
2C3E:  MOVLB  0
2C40:  CALL   1314
2C44:  MOVFF  03,24E
2C48:  MOVFF  02,24D
2C4C:  MOVFF  01,24C
2C50:  MOVFF  00,24B
....................  _U_degree[_U_i] = _rl; 
2C54:  MOVLB  2
2C56:  MOVF   xCD,W
2C58:  MULLW  04
2C5A:  MOVF   FF3,W
2C5C:  CLRF   03
2C5E:  ADDLW  4F
2C60:  MOVWF  FE9
2C62:  MOVLW  02
2C64:  ADDWFC 03,W
2C66:  MOVWF  FEA
2C68:  MOVFF  24B,FEF
2C6C:  MOVFF  24C,FEC
2C70:  MOVFF  24D,FEC
2C74:  MOVFF  24E,FEC
....................  _U_i++; //25 
2C78:  INCF   xCD,F
....................  
....................  *U = OP_myOperations_Defuz(_U); 
2C7A:  MOVFF  23E,03
2C7E:  MOVFF  23D,2F6
2C82:  MOVFF  23E,2F7
2C86:  MOVFF  2B3,2F8
2C8A:  MOVFF  2B4,2F9
2C8E:  MOVFF  2B5,2FA
2C92:  MOVFF  2B6,2FB
2C96:  MOVFF  2B7,2FC
2C9A:  MOVFF  2B8,2FD
2C9E:  MOVFF  2B9,2FE
2CA2:  MOVFF  2BA,2FF
2CA6:  MOVFF  2BB,300
2CAA:  MOVFF  2BC,301
2CAE:  MOVFF  2BD,302
2CB2:  MOVFF  2BE,303
2CB6:  MOVFF  2BF,304
2CBA:  MOVFF  2C0,305
2CBE:  MOVFF  2C1,306
2CC2:  MOVFF  2C2,307
2CC6:  MOVFF  2C3,308
2CCA:  MOVFF  2C4,309
2CCE:  MOVFF  2C5,30A
2CD2:  MOVFF  2C6,30B
2CD6:  MOVFF  2C7,30C
2CDA:  MOVFF  2C8,30D
2CDE:  MOVFF  2C9,30E
2CE2:  MOVFF  2CA,30F
2CE6:  MOVFF  2CB,310
2CEA:  MOVFF  2CC,311
2CEE:  MOVLB  0
2CF0:  GOTO   1F60
2CF4:  MOVFF  2F7,FEA
2CF8:  MOVFF  2F6,FE9
2CFC:  MOVFF  00,FEF
2D00:  MOVFF  01,FEC
2D04:  MOVFF  02,FEC
2D08:  MOVFF  03,FEC
.................... } 
2D0C:  RETLW  00
....................  
.................... /*======================================================*/ 
.................... /*  Rulebase RL_rulesPI                                 */ 
.................... /*======================================================*/ 
....................  
.................... static void RL_rulesPI(double e, double de, double *duPI) { 
.................... 	double _duPI; 
.................... 	RL_rules(e,de,&_duPI,PI_salida); 
*
2DDE:  MOVFF  22A,238
2DE2:  MOVFF  229,237
2DE6:  MOVFF  228,236
2DEA:  MOVFF  227,235
2DEE:  MOVFF  22E,23C
2DF2:  MOVFF  22D,23B
2DF6:  MOVFF  22C,23A
2DFA:  MOVFF  22B,239
2DFE:  MOVLW  02
2E00:  MOVLB  2
2E02:  MOVWF  x3E
2E04:  MOVLW  31
2E06:  MOVWF  x3D
2E08:  MOVFF  43,23F
2E0C:  MOVFF  44,240
2E10:  MOVFF  45,241
2E14:  MOVFF  46,242
2E18:  MOVFF  47,243
2E1C:  MOVFF  48,244
2E20:  MOVFF  49,245
2E24:  MOVFF  4A,246
2E28:  MOVFF  4B,247
2E2C:  MOVFF  4C,248
2E30:  MOVFF  4D,249
2E34:  MOVFF  4E,24A
2E38:  MOVLB  0
2E3A:  CALL   21D6
....................   *duPI = _duPI; 
2E3E:  MOVLB  2
2E40:  MOVFF  22F,FE9
2E44:  MOVFF  230,FEA
2E48:  MOVFF  231,FEF
2E4C:  MOVFF  232,FEC
2E50:  MOVFF  233,FEC
2E54:  MOVFF  234,FEC
.................... } 
2E58:  MOVLB  0
2E5A:  GOTO   2E8E (RETURN)
....................  
.................... /*======================================================*/ 
.................... /*  Rulebase RL_rulesPD                                 */ 
.................... /*======================================================*/ 
....................  
.................... static void RL_rulesPD(double e, double de, double *uPD) { 
.................... 	double _uPD; 
.................... 	RL_rules(e,de,&_uPD,PD_salida); 
*
2D0E:  MOVFF  22A,238
2D12:  MOVFF  229,237
2D16:  MOVFF  228,236
2D1A:  MOVFF  227,235
2D1E:  MOVFF  22E,23C
2D22:  MOVFF  22D,23B
2D26:  MOVFF  22C,23A
2D2A:  MOVFF  22B,239
2D2E:  MOVLW  02
2D30:  MOVLB  2
2D32:  MOVWF  x3E
2D34:  MOVLW  31
2D36:  MOVWF  x3D
2D38:  MOVFF  37,23F
2D3C:  MOVFF  38,240
2D40:  MOVFF  39,241
2D44:  MOVFF  3A,242
2D48:  MOVFF  3B,243
2D4C:  MOVFF  3C,244
2D50:  MOVFF  3D,245
2D54:  MOVFF  3E,246
2D58:  MOVFF  3F,247
2D5C:  MOVFF  40,248
2D60:  MOVFF  41,249
2D64:  MOVFF  42,24A
2D68:  MOVLB  0
2D6A:  CALL   21D6
....................   *uPD = _uPD; 
2D6E:  MOVLB  2
2D70:  MOVFF  22F,FE9
2D74:  MOVFF  230,FEA
2D78:  MOVFF  231,FEF
2D7C:  MOVFF  232,FEC
2D80:  MOVFF  233,FEC
2D84:  MOVFF  234,FEC
.................... } 
2D88:  MOVLB  0
2D8A:  GOTO   2DBE (RETURN)
....................  
.................... /*======================================================*/ 
.................... /*                   Inference Engine                   */ 
.................... /*======================================================*/ 
....................  
.................... void PIInferenceEngine(double eI, double deP, double *_d_duPI) { 
....................  double duPI; 
....................  selected = PI; 
*
2E5E:  BCF    36.0
....................  RL_rulesPI(eI, deP, &duPI); 
2E60:  MOVFF  21C,22A
2E64:  MOVFF  21B,229
2E68:  MOVFF  21A,228
2E6C:  MOVFF  219,227
2E70:  MOVFF  220,22E
2E74:  MOVFF  21F,22D
2E78:  MOVFF  21E,22C
2E7C:  MOVFF  21D,22B
2E80:  MOVLW  02
2E82:  MOVLB  2
2E84:  MOVWF  x30
2E86:  MOVLW  23
2E88:  MOVWF  x2F
2E8A:  MOVLB  0
2E8C:  BRA    2DDE
....................  *_d_duPI = duPI; 
2E8E:  MOVLB  2
2E90:  MOVFF  221,FE9
2E94:  MOVFF  222,FEA
2E98:  MOVFF  223,FEF
2E9C:  MOVFF  224,FEC
2EA0:  MOVFF  225,FEC
2EA4:  MOVFF  226,FEC
.................... } 
2EA8:  MOVLB  0
2EAA:  GOTO   32E6 (RETURN)
....................  
.................... void PDInferenceEngine(double eP, double deD, double *_d_uPD) { 
....................  double uPD; 
....................  selected = PD; 
*
2D8E:  BSF    36.0
....................  RL_rulesPD(eP, deD, &uPD); 
2D90:  MOVFF  21C,22A
2D94:  MOVFF  21B,229
2D98:  MOVFF  21A,228
2D9C:  MOVFF  219,227
2DA0:  MOVFF  220,22E
2DA4:  MOVFF  21F,22D
2DA8:  MOVFF  21E,22C
2DAC:  MOVFF  21D,22B
2DB0:  MOVLW  02
2DB2:  MOVLB  2
2DB4:  MOVWF  x30
2DB6:  MOVLW  23
2DB8:  MOVWF  x2F
2DBA:  MOVLB  0
2DBC:  BRA    2D0E
....................  *_d_uPD = uPD; 
2DBE:  MOVLB  2
2DC0:  MOVFF  221,FE9
2DC4:  MOVFF  222,FEA
2DC8:  MOVFF  223,FEF
2DCC:  MOVFF  224,FEC
2DD0:  MOVFF  225,FEC
2DD4:  MOVFF  226,FEC
.................... } 
2DD8:  MOVLB  0
2DDA:  GOTO   32B8 (RETURN)
....................  
.................... //Ver el grado de pertenencia de x en la funcion de membresia determinada 
.................... double consequent_equal(int conjunto, double x) 
.................... {	 
.................... 	if(selected == PI) 
*
17F2:  BTFSC  36.0
17F4:  BRA    1A66
.................... 	{ 
.................... 		switch(conjunto) 
.................... 		{ 
17F6:  MOVLB  3
17F8:  MOVF   x5A,W
17FA:  ADDLW  E7
17FC:  BTFSC  FD8.0
17FE:  BRA    1A62
1800:  ADDLW  19
1802:  MOVLB  0
1804:  GOTO   1CD6
.................... 			case 0: return TP_duPI_NBdu_equal(x); break; 
1808:  MOVFF  35E,362
180C:  MOVFF  35D,361
1810:  MOVFF  35C,360
1814:  MOVFF  35B,35F
1818:  RCALL  135E
181A:  BRA    1CD0
181C:  MOVLB  3
181E:  BRA    1A62
.................... 			case 1: return TP_duPI_NBdu_equal(x); break; 
1820:  MOVFF  35E,362
1824:  MOVFF  35D,361
1828:  MOVFF  35C,360
182C:  MOVFF  35B,35F
1830:  RCALL  135E
1832:  BRA    1CD0
1834:  MOVLB  3
1836:  BRA    1A62
.................... 			case 2: return TP_duPI_NBdu_equal(x); break; 
1838:  MOVFF  35E,362
183C:  MOVFF  35D,361
1840:  MOVFF  35C,360
1844:  MOVFF  35B,35F
1848:  RCALL  135E
184A:  BRA    1CD0
184C:  MOVLB  3
184E:  BRA    1A62
.................... 			case 3: return TP_duPI_NBdu_equal(x); break; 
1850:  MOVFF  35E,362
1854:  MOVFF  35D,361
1858:  MOVFF  35C,360
185C:  MOVFF  35B,35F
1860:  RCALL  135E
1862:  BRA    1CD0
1864:  MOVLB  3
1866:  BRA    1A62
.................... 			case 4: return TP_duPI_NBdu_equal(x); break; 
1868:  MOVFF  35E,362
186C:  MOVFF  35D,361
1870:  MOVFF  35C,360
1874:  MOVFF  35B,35F
1878:  RCALL  135E
187A:  BRA    1CD0
187C:  MOVLB  3
187E:  BRA    1A62
.................... 			case 5: return TP_duPI_NSdu_equal(x); break; 
1880:  MOVFF  35E,362
1884:  MOVFF  35D,361
1888:  MOVFF  35C,360
188C:  MOVFF  35B,35F
1890:  RCALL  13D2
1892:  BRA    1CD0
1894:  MOVLB  3
1896:  BRA    1A62
.................... 			case 6: return TP_duPI_NSdu_equal(x); break; 
1898:  MOVFF  35E,362
189C:  MOVFF  35D,361
18A0:  MOVFF  35C,360
18A4:  MOVFF  35B,35F
18A8:  RCALL  13D2
18AA:  BRA    1CD0
18AC:  MOVLB  3
18AE:  BRA    1A62
.................... 			case 7: return TP_duPI_NSdu_equal(x); break; 
18B0:  MOVFF  35E,362
18B4:  MOVFF  35D,361
18B8:  MOVFF  35C,360
18BC:  MOVFF  35B,35F
18C0:  RCALL  13D2
18C2:  BRA    1CD0
18C4:  MOVLB  3
18C6:  BRA    1A62
.................... 			case 8: return TP_duPI_NSdu_equal(x); break; 
18C8:  MOVFF  35E,362
18CC:  MOVFF  35D,361
18D0:  MOVFF  35C,360
18D4:  MOVFF  35B,35F
18D8:  RCALL  13D2
18DA:  BRA    1CD0
18DC:  MOVLB  3
18DE:  BRA    1A62
.................... 			case 9: return TP_duPI_NBdu_equal(x); break; 
18E0:  MOVFF  35E,362
18E4:  MOVFF  35D,361
18E8:  MOVFF  35C,360
18EC:  MOVFF  35B,35F
18F0:  RCALL  135E
18F2:  BRA    1CD0
18F4:  MOVLB  3
18F6:  BRA    1A62
.................... 			case 10: return TP_duPI_Zdu_equal(x); break; 
18F8:  MOVFF  35E,362
18FC:  MOVFF  35D,361
1900:  MOVFF  35C,360
1904:  MOVFF  35B,35F
1908:  RCALL  1446
190A:  BRA    1CD0
190C:  MOVLB  3
190E:  BRA    1A62
.................... 			case 11: return TP_duPI_Zdu_equal(x); break; 
1910:  MOVFF  35E,362
1914:  MOVFF  35D,361
1918:  MOVFF  35C,360
191C:  MOVFF  35B,35F
1920:  RCALL  1446
1922:  BRA    1CD0
1924:  MOVLB  3
1926:  BRA    1A62
.................... 			case 12: return TP_duPI_Zdu_equal(x); break; 
1928:  MOVFF  35E,362
192C:  MOVFF  35D,361
1930:  MOVFF  35C,360
1934:  MOVFF  35B,35F
1938:  RCALL  1446
193A:  BRA    1CD0
193C:  MOVLB  3
193E:  BRA    1A62
.................... 			case 13: return TP_duPI_Zdu_equal(x); break; 
1940:  MOVFF  35E,362
1944:  MOVFF  35D,361
1948:  MOVFF  35C,360
194C:  MOVFF  35B,35F
1950:  RCALL  1446
1952:  BRA    1CD0
1954:  MOVLB  3
1956:  BRA    1A62
.................... 			case 14: return TP_duPI_Zdu_equal(x); break; 
1958:  MOVFF  35E,362
195C:  MOVFF  35D,361
1960:  MOVFF  35C,360
1964:  MOVFF  35B,35F
1968:  RCALL  1446
196A:  BRA    1CD0
196C:  MOVLB  3
196E:  BRA    1A62
.................... 			case 15: return TP_duPI_PSdu_equal(x); break; 
1970:  MOVFF  35E,362
1974:  MOVFF  35D,361
1978:  MOVFF  35C,360
197C:  MOVFF  35B,35F
1980:  RCALL  14BA
1982:  BRA    1CD0
1984:  MOVLB  3
1986:  BRA    1A62
.................... 			case 16: return TP_duPI_PSdu_equal(x); break; 
1988:  MOVFF  35E,362
198C:  MOVFF  35D,361
1990:  MOVFF  35C,360
1994:  MOVFF  35B,35F
1998:  RCALL  14BA
199A:  BRA    1CD0
199C:  MOVLB  3
199E:  BRA    1A62
.................... 			case 17: return TP_duPI_PSdu_equal(x); break; 
19A0:  MOVFF  35E,362
19A4:  MOVFF  35D,361
19A8:  MOVFF  35C,360
19AC:  MOVFF  35B,35F
19B0:  RCALL  14BA
19B2:  BRA    1CD0
19B4:  MOVLB  3
19B6:  BRA    1A62
.................... 			case 18: return TP_duPI_PSdu_equal(x); break; 
19B8:  MOVFF  35E,362
19BC:  MOVFF  35D,361
19C0:  MOVFF  35C,360
19C4:  MOVFF  35B,35F
19C8:  RCALL  14BA
19CA:  BRA    1CD0
19CC:  MOVLB  3
19CE:  BRA    1A62
.................... 			case 19: return TP_duPI_PBdu_equal(x); break; 
19D0:  MOVFF  35E,362
19D4:  MOVFF  35D,361
19D8:  MOVFF  35C,360
19DC:  MOVFF  35B,35F
19E0:  RCALL  152E
19E2:  BRA    1CD0
19E4:  MOVLB  3
19E6:  BRA    1A62
.................... 			case 20: return TP_duPI_PBdu_equal(x); break; 
19E8:  MOVFF  35E,362
19EC:  MOVFF  35D,361
19F0:  MOVFF  35C,360
19F4:  MOVFF  35B,35F
19F8:  RCALL  152E
19FA:  BRA    1CD0
19FC:  MOVLB  3
19FE:  BRA    1A62
.................... 			case 21: return TP_duPI_PBdu_equal(x); break; 
1A00:  MOVFF  35E,362
1A04:  MOVFF  35D,361
1A08:  MOVFF  35C,360
1A0C:  MOVFF  35B,35F
1A10:  RCALL  152E
1A12:  BRA    1CD0
1A14:  MOVLB  3
1A16:  BRA    1A62
.................... 			case 22: return TP_duPI_PBdu_equal(x); break; 
1A18:  MOVFF  35E,362
1A1C:  MOVFF  35D,361
1A20:  MOVFF  35C,360
1A24:  MOVFF  35B,35F
1A28:  RCALL  152E
1A2A:  BRA    1CD0
1A2C:  MOVLB  3
1A2E:  BRA    1A62
.................... 			case 23: return TP_duPI_PBdu_equal(x); break; 
1A30:  MOVFF  35E,362
1A34:  MOVFF  35D,361
1A38:  MOVFF  35C,360
1A3C:  MOVFF  35B,35F
1A40:  RCALL  152E
1A42:  BRA    1CD0
1A44:  MOVLB  3
1A46:  BRA    1A62
.................... 			case 24: return TP_duPI_PBdu_equal(x); break; 
1A48:  MOVFF  35E,362
1A4C:  MOVFF  35D,361
1A50:  MOVFF  35C,360
1A54:  MOVFF  35B,35F
1A58:  RCALL  152E
1A5A:  BRA    1CD0
1A5C:  MOVLB  3
1A5E:  BRA    1A62
1A60:  MOVLB  3
.................... 		} 
.................... 	} 
.................... 	else 
1A62:  BRA    1CD2
1A64:  MOVLB  0
.................... 	{ 
.................... 		switch(conjunto) 
.................... 		{ 
1A66:  MOVLB  3
1A68:  MOVF   x5A,W
1A6A:  ADDLW  E7
1A6C:  BTFSC  FD8.0
1A6E:  BRA    1CD2
1A70:  ADDLW  19
1A72:  MOVLB  0
1A74:  GOTO   1D22
.................... 			case 0: return TP_uPD_NBu_equal(x); break; 
1A78:  MOVFF  35E,362
1A7C:  MOVFF  35D,361
1A80:  MOVFF  35C,360
1A84:  MOVFF  35B,35F
1A88:  RCALL  15A4
1A8A:  BRA    1CD0
1A8C:  MOVLB  3
1A8E:  BRA    1CD2
.................... 			case 1: return TP_uPD_NBu_equal(x); break; 
1A90:  MOVFF  35E,362
1A94:  MOVFF  35D,361
1A98:  MOVFF  35C,360
1A9C:  MOVFF  35B,35F
1AA0:  RCALL  15A4
1AA2:  BRA    1CD0
1AA4:  MOVLB  3
1AA6:  BRA    1CD2
.................... 			case 2: return TP_uPD_NBu_equal(x); break; 
1AA8:  MOVFF  35E,362
1AAC:  MOVFF  35D,361
1AB0:  MOVFF  35C,360
1AB4:  MOVFF  35B,35F
1AB8:  RCALL  15A4
1ABA:  BRA    1CD0
1ABC:  MOVLB  3
1ABE:  BRA    1CD2
.................... 			case 3: return TP_uPD_NBu_equal(x); break; 
1AC0:  MOVFF  35E,362
1AC4:  MOVFF  35D,361
1AC8:  MOVFF  35C,360
1ACC:  MOVFF  35B,35F
1AD0:  RCALL  15A4
1AD2:  BRA    1CD0
1AD4:  MOVLB  3
1AD6:  BRA    1CD2
.................... 			case 4: return TP_uPD_NBu_equal(x); break; 
1AD8:  MOVFF  35E,362
1ADC:  MOVFF  35D,361
1AE0:  MOVFF  35C,360
1AE4:  MOVFF  35B,35F
1AE8:  RCALL  15A4
1AEA:  BRA    1CD0
1AEC:  MOVLB  3
1AEE:  BRA    1CD2
.................... 			case 5: return TP_uPD_NSu_equal(x); break; 
1AF0:  MOVFF  35E,362
1AF4:  MOVFF  35D,361
1AF8:  MOVFF  35C,360
1AFC:  MOVFF  35B,35F
1B00:  RCALL  161A
1B02:  BRA    1CD0
1B04:  MOVLB  3
1B06:  BRA    1CD2
.................... 			case 6: return TP_uPD_NSu_equal(x); break; 
1B08:  MOVFF  35E,362
1B0C:  MOVFF  35D,361
1B10:  MOVFF  35C,360
1B14:  MOVFF  35B,35F
1B18:  RCALL  161A
1B1A:  BRA    1CD0
1B1C:  MOVLB  3
1B1E:  BRA    1CD2
.................... 			case 7: return TP_uPD_NSu_equal(x); break; 
1B20:  MOVFF  35E,362
1B24:  MOVFF  35D,361
1B28:  MOVFF  35C,360
1B2C:  MOVFF  35B,35F
1B30:  RCALL  161A
1B32:  BRA    1CD0
1B34:  MOVLB  3
1B36:  BRA    1CD2
.................... 			case 8: return TP_uPD_NSu_equal(x); break; 
1B38:  MOVFF  35E,362
1B3C:  MOVFF  35D,361
1B40:  MOVFF  35C,360
1B44:  MOVFF  35B,35F
1B48:  RCALL  161A
1B4A:  BRA    1CD0
1B4C:  MOVLB  3
1B4E:  BRA    1CD2
.................... 			case 9: return TP_uPD_NBu_equal(x); break; 
1B50:  MOVFF  35E,362
1B54:  MOVFF  35D,361
1B58:  MOVFF  35C,360
1B5C:  MOVFF  35B,35F
1B60:  RCALL  15A4
1B62:  BRA    1CD0
1B64:  MOVLB  3
1B66:  BRA    1CD2
.................... 			case 10: return TP_uPD_Zu_equal(x); break; 
1B68:  MOVFF  35E,362
1B6C:  MOVFF  35D,361
1B70:  MOVFF  35C,360
1B74:  MOVFF  35B,35F
1B78:  RCALL  1690
1B7A:  BRA    1CD0
1B7C:  MOVLB  3
1B7E:  BRA    1CD2
.................... 			case 11: return TP_uPD_Zu_equal(x); break; 
1B80:  MOVFF  35E,362
1B84:  MOVFF  35D,361
1B88:  MOVFF  35C,360
1B8C:  MOVFF  35B,35F
1B90:  RCALL  1690
1B92:  BRA    1CD0
1B94:  MOVLB  3
1B96:  BRA    1CD2
.................... 			case 12: return TP_uPD_Zu_equal(x); break; 
1B98:  MOVFF  35E,362
1B9C:  MOVFF  35D,361
1BA0:  MOVFF  35C,360
1BA4:  MOVFF  35B,35F
1BA8:  RCALL  1690
1BAA:  BRA    1CD0
1BAC:  MOVLB  3
1BAE:  BRA    1CD2
.................... 			case 13: return TP_uPD_Zu_equal(x); break; 
1BB0:  MOVFF  35E,362
1BB4:  MOVFF  35D,361
1BB8:  MOVFF  35C,360
1BBC:  MOVFF  35B,35F
1BC0:  RCALL  1690
1BC2:  BRA    1CD0
1BC4:  MOVLB  3
1BC6:  BRA    1CD2
.................... 			case 14: return TP_uPD_Zu_equal(x); break; 
1BC8:  MOVFF  35E,362
1BCC:  MOVFF  35D,361
1BD0:  MOVFF  35C,360
1BD4:  MOVFF  35B,35F
1BD8:  RCALL  1690
1BDA:  BRA    1CD0
1BDC:  MOVLB  3
1BDE:  BRA    1CD2
.................... 			case 15: return TP_uPD_PSu_equal(x); break; 
1BE0:  MOVFF  35E,362
1BE4:  MOVFF  35D,361
1BE8:  MOVFF  35C,360
1BEC:  MOVFF  35B,35F
1BF0:  RCALL  1706
1BF2:  BRA    1CD0
1BF4:  MOVLB  3
1BF6:  BRA    1CD2
.................... 			case 16: return TP_uPD_PSu_equal(x); break; 
1BF8:  MOVFF  35E,362
1BFC:  MOVFF  35D,361
1C00:  MOVFF  35C,360
1C04:  MOVFF  35B,35F
1C08:  RCALL  1706
1C0A:  BRA    1CD0
1C0C:  MOVLB  3
1C0E:  BRA    1CD2
.................... 			case 17: return TP_uPD_PSu_equal(x); break; 
1C10:  MOVFF  35E,362
1C14:  MOVFF  35D,361
1C18:  MOVFF  35C,360
1C1C:  MOVFF  35B,35F
1C20:  RCALL  1706
1C22:  BRA    1CD0
1C24:  MOVLB  3
1C26:  BRA    1CD2
.................... 			case 18: return TP_uPD_PSu_equal(x); break; 
1C28:  MOVFF  35E,362
1C2C:  MOVFF  35D,361
1C30:  MOVFF  35C,360
1C34:  MOVFF  35B,35F
1C38:  RCALL  1706
1C3A:  BRA    1CD0
1C3C:  MOVLB  3
1C3E:  BRA    1CD2
.................... 			case 19: return TP_uPD_PBu_equal(x); break; 
1C40:  MOVFF  35E,362
1C44:  MOVFF  35D,361
1C48:  MOVFF  35C,360
1C4C:  MOVFF  35B,35F
1C50:  RCALL  177C
1C52:  BRA    1CD0
1C54:  MOVLB  3
1C56:  BRA    1CD2
.................... 			case 20: return TP_uPD_PBu_equal(x); break; 
1C58:  MOVFF  35E,362
1C5C:  MOVFF  35D,361
1C60:  MOVFF  35C,360
1C64:  MOVFF  35B,35F
1C68:  RCALL  177C
1C6A:  BRA    1CD0
1C6C:  MOVLB  3
1C6E:  BRA    1CD2
.................... 			case 21: return TP_uPD_PBu_equal(x); break; 
1C70:  MOVFF  35E,362
1C74:  MOVFF  35D,361
1C78:  MOVFF  35C,360
1C7C:  MOVFF  35B,35F
1C80:  RCALL  177C
1C82:  BRA    1CD0
1C84:  MOVLB  3
1C86:  BRA    1CD2
.................... 			case 22: return TP_uPD_PBu_equal(x); break; 
1C88:  MOVFF  35E,362
1C8C:  MOVFF  35D,361
1C90:  MOVFF  35C,360
1C94:  MOVFF  35B,35F
1C98:  RCALL  177C
1C9A:  BRA    1CD0
1C9C:  MOVLB  3
1C9E:  BRA    1CD2
.................... 			case 23: return TP_uPD_PBu_equal(x); break; 
1CA0:  MOVFF  35E,362
1CA4:  MOVFF  35D,361
1CA8:  MOVFF  35C,360
1CAC:  MOVFF  35B,35F
1CB0:  RCALL  177C
1CB2:  BRA    1CD0
1CB4:  MOVLB  3
1CB6:  BRA    1CD2
.................... 			case 24: return TP_uPD_PBu_equal(x); break; 
1CB8:  MOVFF  35E,362
1CBC:  MOVFF  35D,361
1CC0:  MOVFF  35C,360
1CC4:  MOVFF  35B,35F
1CC8:  RCALL  177C
1CCA:  BRA    1CD0
1CCC:  MOVLB  3
1CCE:  BRA    1CD2
1CD0:  MOVLB  3
.................... 		} 
.................... 	} 
.................... } 
1CD2:  MOVLB  0
1CD4:  RETLW  00
....................  
....................  
.................... //para almacenar en  EEPROM: kp,ki,kd,tc,rf(0-1023) 
.................... #define address_Kp 0    //como son float ocupan 32 bits (4 bytes) 
.................... #define address_Ki 4 
.................... #define address_Kd 8 
.................... #define address_Tc 12    //2 bytes 
.................... #define address_rf 14   //rf(0-1023->14,15) 
.................... #define address_cantM 16  //1 byte 
.................... #define address_BaudRate 18  //1 byte 
.................... #define address_PWMf 20  //1 byte (frecuencia del PWM para calcular el registro PR2) 
.................... #define address_tipoProcesamiento 22 //1 byte 
.................... #define address_Kp_Fuzzy 24  //4 bytes 
.................... #define address_Ki_Fuzzy 28  //4 bytes 
.................... #define address_Kd_Fuzzy 32  //4 bytes 
.................... #define address_universoPD 36  //2 bytes 
.................... #define address_universoPI 38  //2 bytes 
.................... #define address_Tc_Fuzzy 40  //2 bytes 
.................... #define address_stepPD 42  //4 bytes 
.................... #define address_stepPI 46  //4 bytes 
.................... #define address_Kpi_Fuzzy 50  //4 bytes 
.................... #define address_fPWM1 54  //1 byte 
.................... #define address_ADselected 55  //1 byte 
.................... #define address_TipoAccion 56  //1 byte 
....................   
.................... #define Ry 1023  // ymax=1023; ymin=0; rango_Tx(A/D): Ry=ymax-ymin;  
....................  
.................... #define conv_tiempo 0.0000016 //4*50n*8  
....................  
.................... #define buffer_size 10 
....................  
.................... #define automatico 0 
.................... #define manual 1 
....................  
.................... #define supervision 0 
.................... #define control 1 
....................  
.................... #define directa 0 
.................... #define inversa 1 
....................  
.................... //COMANDOS 
.................... #define conectar '!' 
.................... #define desconectar 'Q' 
.................... //CONTROL 
.................... #define Tx 'X' 
.................... #define estado_pid 'O' 
.................... #define estado_pid_reenvio 'o' 
.................... #define end_of_Tx 'E' 
.................... //#define clc '~' 
.................... #define cambiar_modo 'M' 
.................... //FUZZY 
.................... #define estado_fuzzy 'F' 
.................... #define estado_fuzzy_reenvio 'f' 
.................... //Supervision 
.................... #define estado_supervision 'S' 
.................... #define tipo_de_modulo '*' 
.................... #define entrada_analogica 'A' 
.................... #define entrada_digital 'D' 
.................... #define ciclo_util_PWM 'P' 
.................... #define salida_digital 'T' 
.................... #define escritura_configuracion 'C' 
.................... #define lectura_configuracion 'L' 
.................... //Avisos de RESET 
.................... #define WDT '$' 
.................... #define POR '%' 
.................... #define BOR '#' 
.................... //Aviso por recepcion de caracteres no validos 
.................... #define caracter_no_valido '?' 
.................... //Reset por software 
.................... #define RESET 'R' 
....................  
.................... /////////////////////////////*GLOBAL VARIABLES*///////////////////////////////// 
....................  
.................... /* 
....................   Significado de los coeficientes: 
....................     g = guardar 
....................     t = temporal 
....................     f = flag o float 
.................... */ 
....................  
.................... //PID Profesional 
.................... typedef struct  
.................... { 
....................   float Kp,Kd,Ki;  
....................   int16 Tc;  //es de 16bits para procesos lentos 
.................... }Parametros; 
....................  
.................... typedef struct  
.................... { 
.................... 	Parametros param,paramTemp; 
....................   signed int16 u; 
.................... 	float en; 
.................... 	float Integral,Integral_1; 
.................... 	float Derivativo; 
.................... 	float Proporcional;   
.................... }PID; 
....................  
.................... //Fuzzy 
.................... typedef struct  
.................... { 
.................... 	float Kp,Kd,Ki,Kpi; //Kp->PD, Kpi->PI 
.................... 	signed int16 universo_duPI_min,universo_duPI_max; 
.................... 	signed int16 universo_uPD_min,universo_uPD_max; 
.................... 	float stepPD,stepPI; 
.................... 	int16 Tc;  //es de 16bits para procesos lentos (en este caso no influye en el algoritmo) 
.................... 	BOOLEAN guniversoPI,guniversoPD; 
.................... 	BOOLEAN gstepPI,gstepPD; 
.................... }FuzzyParametros; 
....................  
.................... typedef struct  
.................... { 
....................   FuzzyParametros fparam,fparamTemp; 
.................... 	double u_PI,du_PI,u_PI_1,u_PD,u;   
.................... 	float error,error_1,derror; 
.................... 	float e_P,de_D,e_I,de_P;  //d->variacion 
.................... }FUZZY; 
....................  
.................... #case  //Will cause the compiler to be case sensitive 
.................... PID pid; 
.................... FUZZY fuzzy; 
....................  
.................... signed int16 rf,yf,yf_1;  //son signed para procurar compatibilidad al calcular en(error nominal) 
.................... BOOLEAN modo; 
.................... int8 seleccionBR,seleccionPWMf;  //variable de seleccion del Baud Rate 
.................... BOOLEAN fuzzy_selected; 
.................... BOOLEAN pid_selected; 
.................... BOOLEAN grf,gBR,gPWMf,gTP;  //TP->tipo de procesamiento 
.................... BOOLEAN fprintPIDini,fprintFUZZYini,fprintTc,fprint; 
.................... BOOLEAN gk; 
.................... BOOLEAN gTc; //Para guardar en EEPROM 
.................... unsigned int16 tmr1,tmr0; 
.................... int16 count_timer; 
.................... BOOLEAN fPWM1;  //true->PWM1 seleccionado, false->PWM2 seleccionado 
.................... int ADselected; 
.................... BOOLEAN gPWMseleccion,gADseleccion; 
.................... int16 Tsupervision; 
.................... BOOLEAN fTipoAccion,gTipoAccion; 
....................  
.................... //Filtro promedio	 
.................... int8 cantM;  //cantidad de muestras para el filtro promedio	 
.................... int16 promM[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  //promedio de las muestras 
.................... int8 tipo_procesamiento; 
.................... BOOLEAN fcantM;   //depende del tipo de procesamiento 
.................... BOOLEAN gcantM; 
....................  
.................... //Case entrada_analogica 
.................... BOOLEAN fentrada_analogica; 
.................... int8 analog_value; 
....................  
.................... //Puerto serie 
.................... BOOLEAN fFirst_time_pid; 
.................... BOOLEAN fFirst_time_fuzzy; 
.................... char *buffer; 
.................... char bRx[buffer_size+1]={0,0,0,0,0,0,0,0,0,0,0}; 
.................... char bufferRx[buffer_size+1]={0,0,0,0,0,0,0,0,0,0,0}; 
.................... float fnumber; 
.................... BOOLEAN tgk,tgcantM,tgTc; 
.................... int tcantM; 
.................... int16 tu; 
.................... BOOLEAN fRx=FALSE; 
.................... char bRxSelect,bufferRxSelect; 
....................  
.................... /////////////////////////////*STATEMENTS*/////////////////////////////////////// 
.................... #separate int16 ADC_Read(int8); 
.................... #separate int16 promedio(int16); 
.................... #separate void setup(void); 
.................... #separate void initialize(void); 
.................... #separate void set_PWM_period(void); 
.................... #separate void algoritmo_PID(void); 
.................... #separate void algoritmo_Fuzzy(void); 
.................... #separate void enable_timer0(BOOLEAN); 
.................... #separate void enable_timer1(BOOLEAN); 
.................... #separate void initialize_Fuzzy(void); 
.................... #separate void set_PWM(int16); 
.................... #separate int16 calc_tmr(int16); 
.................... #separate void print_enabled(void); 
.................... //Puerto serie 
.................... #separate void Tx_function(void); 
.................... #separate void estado_pid_function(void); 
.................... #separate void estado_fuzzy_function(void); 
.................... #separate void end_of_Tx_function(void); 
.................... #separate void escritura_configuracion_function(void); 
.................... #separate void entrada_digital_function(void); 
.................... #separate void ciclo_util_PWM_function(void); 
.................... #separate void salida_digital_function(void); 
.................... #separate void lectura_configuracion_function(void); 
.................... #separate void saveToEEPROM(void); 
.................... #separate void printRS232(void); 
.................... #separate void analizar_Rx(char); 
.................... #separate void guardar_bufferRx(void); 
....................  
....................  
....................  
.................... //Puerto serie 
.................... #INT_RDA HIGH 
.................... void serial_port() 
.................... { 	 
.................... 	static BOOLEAN fRxFirst=FALSE; 
.................... 	static int posicion=0; 
.................... 	char Rx; 
....................  
.................... 	Rx=getc(); 
*
0190:  BRA    0178
0192:  MOVFF  01,393
....................  
.................... 	if(Rx=='<')		 
0196:  MOVLB  3
0198:  MOVF   x93,W
019A:  SUBLW  3C
019C:  BNZ   01A8
.................... 	{ 
.................... 		posicion=0; 
019E:  MOVLB  1
01A0:  CLRF   xC7
.................... 		fRxFirst=TRUE; 
01A2:  BSF    xC1.4
.................... 	}	 
.................... 	else 
01A4:  BRA    01E0
01A6:  MOVLB  3
.................... 	{ 
.................... 		if(Rx==13)//ENTER 
01A8:  MOVF   x93,W
01AA:  SUBLW  0D
01AC:  BNZ   01B6
.................... 			fRx=TRUE; 
01AE:  MOVLB  1
01B0:  BSF    xC1.3
.................... 		else 
01B2:  BRA    01E0
01B4:  MOVLB  3
.................... 		{ 
.................... 			if(fRxFirst) {bufferRxSelect=Rx; fRxFirst=FALSE;} 
01B6:  MOVLB  1
01B8:  BTFSS  xC1.4
01BA:  BRA    01C4
01BC:  MOVFF  393,1C6
01C0:  BCF    xC1.4
.................... 			else  
01C2:  BRA    01E0
.................... 			{ 
.................... 				bufferRx[posicion++]=Rx; 
01C4:  MOVF   xC7,W
01C6:  INCF   xC7,F
01C8:  CLRF   03
01CA:  ADDLW  B2
01CC:  MOVWF  FE9
01CE:  MOVLW  01
01D0:  ADDWFC 03,W
01D2:  MOVWF  FEA
01D4:  MOVFF  393,FEF
.................... 				 
.................... 				if(posicion==buffer_size) 
01D8:  MOVF   xC7,W
01DA:  SUBLW  0A
01DC:  BNZ   01E0
.................... 					posicion=0; 
01DE:  CLRF   xC7
.................... 			} 
.................... 		}	 
.................... 	} 
.................... } 
....................  
01E0:  BCF    F9E.5
01E2:  MOVLB  0
01E4:  GOTO   012A
.................... #separate 
.................... void analizar_Rx(char Rx) 
.................... { 
.................... 	switch(Rx) 
....................   { 
*
7028:  MOVLB  1
702A:  MOVF   xC9,W
702C:  XORLW  21
702E:  MOVLB  0
7030:  BZ    7088
7032:  XORLW  70
7034:  BZ    7090
7036:  XORLW  09
7038:  BZ    70C4
703A:  XORLW  17
703C:  BZ    70D0
703E:  XORLW  09
7040:  BZ    70D4
7042:  XORLW  29
7044:  BZ    70D8
7046:  XORLW  09
7048:  BZ    70E2
704A:  XORLW  23
704C:  BZ    70EC
704E:  XORLW  08
7050:  BZ    70F6
7052:  XORLW  1E
7054:  BZ    7108
7056:  XORLW  79
7058:  BTFSC  FD8.2
705A:  BRA    713A
705C:  XORLW  6B
705E:  BTFSC  FD8.2
7060:  BRA    7142
7062:  XORLW  05
7064:  BTFSC  FD8.2
7066:  BRA    714E
7068:  XORLW  14
706A:  BTFSC  FD8.2
706C:  BRA    7152
706E:  XORLW  04
7070:  BTFSC  FD8.2
7072:  BRA    715C
7074:  XORLW  06
7076:  BTFSC  FD8.2
7078:  BRA    7166
707A:  XORLW  11
707C:  BTFSC  FD8.2
707E:  BRA    716A
7080:  XORLW  0F
7082:  BTFSC  FD8.2
7084:  BRA    7174
7086:  BRA    7178
....................   case conectar: putc('!'); break; 
7088:  MOVLW  21
708A:  CALL   4F82
708E:  BRA    7180
....................   case desconectar:  
.................... 		fFirst_time_pid=FALSE;  
7090:  MOVLB  1
7092:  BCF    x7F.6
.................... 		fFirst_time_fuzzy=FALSE; 
7094:  BCF    x7F.7
.................... 		enable_timer0(FALSE);  
7096:  CLRF   xCA
7098:  MOVLB  0
709A:  CALL   59AC
709E:  CLRF   19
70A0:  BTFSC  FF2.6
70A2:  BSF    19.6
70A4:  BCF    FF2.6
70A6:  BTFSC  FF2.7
70A8:  BSF    19.7
70AA:  BCF    FF2.7
.................... 		enable_timer1(FALSE); 
70AC:  MOVLB  2
70AE:  CLRF   x13
70B0:  MOVLB  0
70B2:  CALL   34BE
70B6:  BTFSC  19.6
70B8:  BSF    FF2.6
70BA:  BTFSC  19.7
70BC:  BSF    FF2.7
.................... 		set_pwm1_duty(0); 
70BE:  CLRF   FBE
.................... 		set_pwm2_duty(0); 
70C0:  CLRF   FBB
.................... 		break; 
70C2:  BRA    7180
....................   //CONTROL 
....................   case Tx: Tx_function(); putc('<'); break; 
70C4:  GOTO   64FE
70C8:  MOVLW  3C
70CA:  CALL   4F82
70CE:  BRA    7180
....................   case estado_pid: estado_pid_function(); break; 
70D0:  RCALL  69E0
70D2:  BRA    7180
.................... 	case estado_fuzzy: estado_fuzzy_function(); break; 
70D4:  RCALL  6A0C
70D6:  BRA    7180
.................... 	case estado_pid_reenvio: fFirst_time_pid=FALSE; estado_pid_function(); break; 
70D8:  MOVLB  1
70DA:  BCF    x7F.6
70DC:  MOVLB  0
70DE:  RCALL  69E0
70E0:  BRA    7180
.................... 	case estado_fuzzy_reenvio: fFirst_time_fuzzy=FALSE; estado_fuzzy_function(); break; 
70E2:  MOVLB  1
70E4:  BCF    x7F.7
70E6:  MOVLB  0
70E8:  RCALL  6A0C
70EA:  BRA    7180
....................   case end_of_Tx: end_of_Tx_function(); putc('<'); break;      
70EC:  BRA    6A70
70EE:  MOVLW  3C
70F0:  CALL   4F82
70F4:  BRA    7180
....................   case cambiar_modo: modo = bRx[0]; putc('<'); break;  
70F6:  BCF    36.1
70F8:  MOVLB  1
70FA:  BTFSC  xA7.0
70FC:  BSF    36.1
70FE:  MOVLW  3C
7100:  MOVLB  0
7102:  CALL   4F82
7106:  BRA    7180
....................   //SUPERVISION 
....................   case estado_supervision: enable_timer0(FALSE); enable_timer1(FALSE); putc('<'); break; 
7108:  MOVLB  1
710A:  CLRF   xCA
710C:  MOVLB  0
710E:  CALL   59AC
7112:  CLRF   19
7114:  BTFSC  FF2.6
7116:  BSF    19.6
7118:  BCF    FF2.6
711A:  BTFSC  FF2.7
711C:  BSF    19.7
711E:  BCF    FF2.7
7120:  MOVLB  2
7122:  CLRF   x13
7124:  MOVLB  0
7126:  CALL   34BE
712A:  BTFSC  19.6
712C:  BSF    FF2.6
712E:  BTFSC  19.7
7130:  BSF    FF2.7
7132:  MOVLW  3C
7134:  CALL   4F82
7138:  BRA    7180
....................   case tipo_de_modulo: putc('^'); break;  
713A:  MOVLW  5E
713C:  CALL   4F82
7140:  BRA    7180
....................   case entrada_analogica: analog_value=bRx[0]; fentrada_analogica=TRUE; break; 
7142:  MOVFF  1A7,1A4
7146:  MOVLB  1
7148:  BSF    x7F.5
714A:  MOVLB  0
714C:  BRA    7180
....................   case entrada_digital: entrada_digital_function(); break;        
714E:  BRA    6C26
7150:  BRA    7180
....................   case ciclo_util_PWM: ciclo_util_PWM_function(); putc('<'); break;   
7152:  BRA    6CE8
7154:  MOVLW  3C
7156:  CALL   4F82
715A:  BRA    7180
....................   case salida_digital: salida_digital_function(); putc('<'); break;  
715C:  BRA    6DD8
715E:  MOVLW  3C
7160:  CALL   4F82
7164:  BRA    7180
....................   case RESET: reset_cpu(); break; 
7166:  RESET
7168:  BRA    7180
....................   case escritura_configuracion: escritura_configuracion_function(); putc('<'); break; 
716A:  BRA    6E2E
716C:  MOVLW  3C
716E:  CALL   4F82
7172:  BRA    7180
....................   case lectura_configuracion: lectura_configuracion_function(); break;  
7174:  BRA    6F52
7176:  BRA    7180
....................   default: putc(caracter_no_valido); break; 
7178:  MOVLW  3F
717A:  CALL   4F82
717E:  BRA    7180
....................   } 
.................... } 
7180:  GOTO   7254 (RETURN)
....................  
.................... #separate 
.................... void Tx_function() 
.................... { 
....................      // get_string(bRx,buffer_size); 
....................       fnumber = strtod(bRx,&buffer); 
*
64FE:  MOVLW  01
6500:  MOVLB  1
6502:  MOVWF  xCB
6504:  MOVLW  A7
6506:  MOVWF  xCA
6508:  MOVLW  01
650A:  MOVWF  xCD
650C:  MOVLW  A5
650E:  MOVWF  xCC
6510:  MOVLB  0
6512:  RCALL  61EA
6514:  MOVFF  03,1C0
6518:  MOVFF  02,1BF
651C:  MOVFF  01,1BE
6520:  MOVFF  00,1BD
....................        
....................       switch(buffer[0]) 
....................       { 
6524:  MOVLB  1
6526:  MOVF   xA5,W
6528:  MOVWF  FE9
652A:  MOVF   xA6,W
652C:  MOVWF  FEA
652E:  MOVF   FEF,W
6530:  XORLW  72
6532:  MOVLB  0
6534:  BZ    6580
6536:  XORLW  06
6538:  BTFSC  FD8.2
653A:  BRA    664A
653C:  XORLW  04
653E:  BTFSC  FD8.2
6540:  BRA    670C
6542:  XORLW  19
6544:  BTFSC  FD8.2
6546:  BRA    673E
6548:  XORLW  0D
654A:  BTFSC  FD8.2
654C:  BRA    6770
654E:  XORLW  02
6550:  BTFSC  FD8.2
6552:  BRA    67A2
6554:  XORLW  13
6556:  BTFSC  FD8.2
6558:  BRA    67D8
655A:  XORLW  3C
655C:  BTFSC  FD8.2
655E:  BRA    680C
6560:  XORLW  0D
6562:  BTFSC  FD8.2
6564:  BRA    68B2
6566:  XORLW  37
6568:  BTFSC  FD8.2
656A:  BRA    6958
656C:  XORLW  20
656E:  BTFSC  FD8.2
6570:  BRA    6970
6572:  XORLW  29
6574:  BTFSC  FD8.2
6576:  BRA    6988
6578:  XORLW  3D
657A:  BTFSC  FD8.2
657C:  BRA    69A0
657E:  BRA    69D4
....................         case 'r': 
6580:  CLRF   19
6582:  BTFSC  FF2.6
6584:  BSF    19.6
6586:  BCF    FF2.6
6588:  BTFSC  FF2.7
658A:  BSF    19.7
658C:  BCF    FF2.7
....................           if(fnumber>1023) fnumber=1023; 
658E:  MOVLB  3
6590:  CLRF   x82
6592:  MOVLW  C0
6594:  MOVWF  x81
6596:  MOVLW  7F
6598:  MOVWF  x80
659A:  MOVLW  88
659C:  MOVWF  x7F
659E:  MOVFF  1C0,386
65A2:  MOVFF  1BF,385
65A6:  MOVFF  1BE,384
65AA:  MOVFF  1BD,383
65AE:  MOVLB  0
65B0:  CALL   0878
65B4:  BTFSC  19.6
65B6:  BSF    FF2.6
65B8:  BTFSC  19.7
65BA:  BSF    FF2.7
65BC:  BNC   65D0
65BE:  MOVLB  1
65C0:  CLRF   xC0
65C2:  MOVLW  C0
65C4:  MOVWF  xBF
65C6:  MOVLW  7F
65C8:  MOVWF  xBE
65CA:  MOVLW  88
65CC:  MOVWF  xBD
65CE:  MOVLB  0
65D0:  CLRF   19
65D2:  BTFSC  FF2.6
65D4:  BSF    19.6
65D6:  BCF    FF2.6
65D8:  BTFSC  FF2.7
65DA:  BSF    19.7
65DC:  BCF    FF2.7
....................           if(fnumber<0) fnumber=0; 
65DE:  MOVFF  1C0,382
65E2:  MOVFF  1BF,381
65E6:  MOVFF  1BE,380
65EA:  MOVFF  1BD,37F
65EE:  MOVLB  3
65F0:  CLRF   x86
65F2:  CLRF   x85
65F4:  CLRF   x84
65F6:  CLRF   x83
65F8:  MOVLB  0
65FA:  CALL   0878
65FE:  BTFSC  19.6
6600:  BSF    FF2.6
6602:  BTFSC  19.7
6604:  BSF    FF2.7
6606:  BNC   6614
6608:  MOVLB  1
660A:  CLRF   xC0
660C:  CLRF   xBF
660E:  CLRF   xBE
6610:  CLRF   xBD
6612:  MOVLB  0
6614:  CLRF   19
6616:  BTFSC  FF2.6
6618:  BSF    19.6
661A:  BCF    FF2.6
661C:  BTFSC  FF2.7
661E:  BSF    19.7
6620:  BCF    FF2.7
....................           rf = fnumber;  
6622:  MOVFF  1C0,21C
6626:  MOVFF  1BF,21B
662A:  MOVFF  1BE,21A
662E:  MOVFF  1BD,219
6632:  CALL   08F2
6636:  BTFSC  19.6
6638:  BSF    FF2.6
663A:  BTFSC  19.7
663C:  BSF    FF2.7
663E:  MOVFF  02,170
6642:  MOVFF  01,16F
.................... 			//		fuzzy.u_PI_1=0;   
.................... 			//		pid.Integral_1 = 0; 
....................           grf=1;  
6646:  BSF    36.4
....................           break; 
6648:  BRA    69DC
....................         case 't':  
.................... 					if(pid_selected)  
664A:  BTFSS  36.3
664C:  BRA    66CE
664E:  CLRF   19
6650:  BTFSC  FF2.6
6652:  BSF    19.6
6654:  BCF    FF2.6
6656:  BTFSC  FF2.7
6658:  BSF    19.7
665A:  BCF    FF2.7
.................... 						pid.paramTemp.Tc = ((int16)fnumber > 0 ? (int16)fnumber : 1);  
665C:  MOVFF  1C0,21C
6660:  MOVFF  1BF,21B
6664:  MOVFF  1BE,21A
6668:  MOVFF  1BD,219
666C:  CALL   08F2
6670:  BTFSC  19.6
6672:  BSF    FF2.6
6674:  BTFSC  19.7
6676:  BSF    FF2.7
6678:  MOVFF  02,1CB
667C:  MOVFF  01,1CA
6680:  MOVLB  1
6682:  MOVF   xCA,F
6684:  BNZ   668A
6686:  MOVF   xCB,F
6688:  BZ    66C0
668A:  CLRF   19
668C:  BTFSC  FF2.6
668E:  BSF    19.6
6690:  BCF    FF2.6
6692:  BTFSC  FF2.7
6694:  BSF    19.7
6696:  BCF    FF2.7
6698:  MOVFF  1C0,21C
669C:  MOVFF  1BF,21B
66A0:  MOVFF  1BE,21A
66A4:  MOVFF  1BD,219
66A8:  MOVLB  0
66AA:  CALL   08F2
66AE:  BTFSC  19.6
66B0:  BSF    FF2.6
66B2:  BTFSC  19.7
66B4:  BSF    FF2.7
66B6:  MOVFF  02,03
66BA:  MOVF   01,W
66BC:  BRA    66C6
66BE:  MOVLB  1
66C0:  CLRF   03
66C2:  MOVLW  01
66C4:  MOVLB  0
66C6:  MOVWF  xE1
66C8:  MOVFF  03,E2
.................... 					else if(fuzzy_selected)  
66CC:  BRA    6704
66CE:  BTFSS  36.2
66D0:  BRA    6704
66D2:  CLRF   19
66D4:  BTFSC  FF2.6
66D6:  BSF    19.6
66D8:  BCF    FF2.6
66DA:  BTFSC  FF2.7
66DC:  BSF    19.7
66DE:  BCF    FF2.7
.................... 						fuzzy.fparamTemp.Tc = (int16)fnumber; 
66E0:  MOVFF  1C0,21C
66E4:  MOVFF  1BF,21B
66E8:  MOVFF  1BE,21A
66EC:  MOVFF  1BD,219
66F0:  CALL   08F2
66F4:  BTFSC  19.6
66F6:  BSF    FF2.6
66F8:  BTFSC  19.7
66FA:  BSF    FF2.7
66FC:  MOVFF  02,13D
6700:  MOVFF  01,13C
.................... 					tgTc = TRUE;  
6704:  MOVLB  1
6706:  BSF    xC1.2
.................... 					break; 
6708:  MOVLB  0
670A:  BRA    69DC
....................         case 'p':  
.................... 					if(pid_selected) pid.paramTemp.Kp = fnumber; 
670C:  BTFSS  36.3
670E:  BRA    6722
6710:  MOVFF  1C0,D8
6714:  MOVFF  1BF,D7
6718:  MOVFF  1BE,D6
671C:  MOVFF  1BD,D5
.................... 					else if(fuzzy_selected) fuzzy.fparamTemp.Kp = fnumber; 
6720:  BRA    6736
6722:  BTFSS  36.2
6724:  BRA    6736
6726:  MOVFF  1C0,11F
672A:  MOVFF  1BF,11E
672E:  MOVFF  1BE,11D
6732:  MOVFF  1BD,11C
.................... 					tgk = TRUE; 
6736:  MOVLB  1
6738:  BSF    xC1.0
.................... 					break; 
673A:  MOVLB  0
673C:  BRA    69DC
....................         case 'i':  
.................... 					if(pid_selected) pid.paramTemp.Ki = fnumber;  
673E:  BTFSS  36.3
6740:  BRA    6754
6742:  MOVFF  1C0,E0
6746:  MOVFF  1BF,DF
674A:  MOVFF  1BE,DE
674E:  MOVFF  1BD,DD
.................... 					else if(fuzzy_selected) fuzzy.fparamTemp.Ki = fnumber; 
6752:  BRA    6768
6754:  BTFSS  36.2
6756:  BRA    6768
6758:  MOVFF  1C0,127
675C:  MOVFF  1BF,126
6760:  MOVFF  1BE,125
6764:  MOVFF  1BD,124
.................... 					tgk = TRUE; 
6768:  MOVLB  1
676A:  BSF    xC1.0
.................... 					break; 
676C:  MOVLB  0
676E:  BRA    69DC
....................         case 'd':  
.................... 					if(pid_selected) pid.paramTemp.Kd = fnumber; 
6770:  BTFSS  36.3
6772:  BRA    6786
6774:  MOVFF  1C0,DC
6778:  MOVFF  1BF,DB
677C:  MOVFF  1BE,DA
6780:  MOVFF  1BD,D9
.................... 					else if(fuzzy_selected) fuzzy.fparamTemp.Kd = fnumber; 
6784:  BRA    679A
6786:  BTFSS  36.2
6788:  BRA    679A
678A:  MOVFF  1C0,123
678E:  MOVFF  1BF,122
6792:  MOVFF  1BE,121
6796:  MOVFF  1BD,120
.................... 					tgk = TRUE; 
679A:  MOVLB  1
679C:  BSF    xC1.0
.................... 					break; 
679E:  MOVLB  0
67A0:  BRA    69DC
....................         case 'f': tcantM = fnumber; tgcantM = TRUE; break; 
67A2:  CLRF   19
67A4:  BTFSC  FF2.6
67A6:  BSF    19.6
67A8:  BCF    FF2.6
67AA:  BTFSC  FF2.7
67AC:  BSF    19.7
67AE:  BCF    FF2.7
67B0:  MOVFF  1C0,21C
67B4:  MOVFF  1BF,21B
67B8:  MOVFF  1BE,21A
67BC:  MOVFF  1BD,219
67C0:  CALL   08F2
67C4:  BTFSC  19.6
67C6:  BSF    FF2.6
67C8:  BTFSC  19.7
67CA:  BSF    FF2.7
67CC:  MOVFF  01,1C2
67D0:  MOVLB  1
67D2:  BSF    xC1.1
67D4:  MOVLB  0
67D6:  BRA    69DC
....................         case 'u': tu = fnumber; break; 
67D8:  CLRF   19
67DA:  BTFSC  FF2.6
67DC:  BSF    19.6
67DE:  BCF    FF2.6
67E0:  BTFSC  FF2.7
67E2:  BSF    19.7
67E4:  BCF    FF2.7
67E6:  MOVFF  1C0,21C
67EA:  MOVFF  1BF,21B
67EE:  MOVFF  1BE,21A
67F2:  MOVFF  1BD,219
67F6:  CALL   08F2
67FA:  BTFSC  19.6
67FC:  BSF    FF2.6
67FE:  BTFSC  19.7
6800:  BSF    FF2.7
6802:  MOVFF  02,1C4
6806:  MOVFF  01,1C3
680A:  BRA    69DC
.................... 				case 'I':  
680C:  CLRF   19
680E:  BTFSC  FF2.6
6810:  BSF    19.6
6812:  BCF    FF2.6
6814:  BTFSC  FF2.7
6816:  BSF    19.7
6818:  BCF    FF2.7
.................... 					fuzzy.fparamTemp.universo_duPI_max = fnumber; 
681A:  MOVFF  1C0,21C
681E:  MOVFF  1BF,21B
6822:  MOVFF  1BE,21A
6826:  MOVFF  1BD,219
682A:  CALL   08F2
682E:  BTFSC  19.6
6830:  BSF    FF2.6
6832:  BTFSC  19.7
6834:  BSF    FF2.7
6836:  MOVFF  02,12F
683A:  MOVFF  01,12E
683E:  CLRF   19
6840:  BTFSC  FF2.6
6842:  BSF    19.6
6844:  BCF    FF2.6
6846:  BTFSC  FF2.7
6848:  BSF    19.7
684A:  BCF    FF2.7
.................... 					fuzzy.fparamTemp.universo_duPI_min = fnumber * (-1); 
684C:  MOVFF  1C0,331
6850:  MOVFF  1BF,330
6854:  MOVFF  1BE,32F
6858:  MOVFF  1BD,32E
685C:  MOVLB  3
685E:  CLRF   x35
6860:  CLRF   x34
6862:  MOVLW  80
6864:  MOVWF  x33
6866:  MOVLW  7F
6868:  MOVWF  x32
686A:  MOVLB  0
686C:  CALL   050A
6870:  BTFSC  19.6
6872:  BSF    FF2.6
6874:  BTFSC  19.7
6876:  BSF    FF2.7
6878:  CLRF   19
687A:  BTFSC  FF2.6
687C:  BSF    19.6
687E:  BCF    FF2.6
6880:  BTFSC  FF2.7
6882:  BSF    19.7
6884:  BCF    FF2.7
6886:  MOVFF  03,21C
688A:  MOVFF  02,21B
688E:  MOVFF  01,21A
6892:  MOVFF  00,219
6896:  CALL   08F2
689A:  BTFSC  19.6
689C:  BSF    FF2.6
689E:  BTFSC  19.7
68A0:  BSF    FF2.7
68A2:  MOVFF  02,12D
68A6:  MOVFF  01,12C
.................... 					fuzzy.fparamTemp.guniversoPI = TRUE; 
68AA:  MOVLB  1
68AC:  BSF    x3E.0
.................... 					break; 
68AE:  MOVLB  0
68B0:  BRA    69DC
.................... 				case 'D':  
68B2:  CLRF   19
68B4:  BTFSC  FF2.6
68B6:  BSF    19.6
68B8:  BCF    FF2.6
68BA:  BTFSC  FF2.7
68BC:  BSF    19.7
68BE:  BCF    FF2.7
.................... 					fuzzy.fparamTemp.universo_uPD_max = fnumber; 
68C0:  MOVFF  1C0,21C
68C4:  MOVFF  1BF,21B
68C8:  MOVFF  1BE,21A
68CC:  MOVFF  1BD,219
68D0:  CALL   08F2
68D4:  BTFSC  19.6
68D6:  BSF    FF2.6
68D8:  BTFSC  19.7
68DA:  BSF    FF2.7
68DC:  MOVFF  02,133
68E0:  MOVFF  01,132
68E4:  CLRF   19
68E6:  BTFSC  FF2.6
68E8:  BSF    19.6
68EA:  BCF    FF2.6
68EC:  BTFSC  FF2.7
68EE:  BSF    19.7
68F0:  BCF    FF2.7
.................... 					fuzzy.fparamTemp.universo_uPD_min = fnumber * (-1); 
68F2:  MOVFF  1C0,331
68F6:  MOVFF  1BF,330
68FA:  MOVFF  1BE,32F
68FE:  MOVFF  1BD,32E
6902:  MOVLB  3
6904:  CLRF   x35
6906:  CLRF   x34
6908:  MOVLW  80
690A:  MOVWF  x33
690C:  MOVLW  7F
690E:  MOVWF  x32
6910:  MOVLB  0
6912:  CALL   050A
6916:  BTFSC  19.6
6918:  BSF    FF2.6
691A:  BTFSC  19.7
691C:  BSF    FF2.7
691E:  CLRF   19
6920:  BTFSC  FF2.6
6922:  BSF    19.6
6924:  BCF    FF2.6
6926:  BTFSC  FF2.7
6928:  BSF    19.7
692A:  BCF    FF2.7
692C:  MOVFF  03,21C
6930:  MOVFF  02,21B
6934:  MOVFF  01,21A
6938:  MOVFF  00,219
693C:  CALL   08F2
6940:  BTFSC  19.6
6942:  BSF    FF2.6
6944:  BTFSC  19.7
6946:  BSF    FF2.7
6948:  MOVFF  02,131
694C:  MOVFF  01,130
.................... 					fuzzy.fparamTemp.guniversoPD = TRUE; 
6950:  MOVLB  1
6952:  BSF    x3E.1
.................... 					break; 
6954:  MOVLB  0
6956:  BRA    69DC
.................... 				case 's':  
.................... 					fuzzy.fparamTemp.stepPD = fnumber;  
6958:  MOVFF  1C0,137
695C:  MOVFF  1BF,136
6960:  MOVFF  1BE,135
6964:  MOVFF  1BD,134
.................... 					fuzzy.fparamTemp.gstepPD = TRUE; 
6968:  MOVLB  1
696A:  BSF    x3E.3
.................... 					break; 
696C:  MOVLB  0
696E:  BRA    69DC
.................... 				case 'S':  
.................... 					fuzzy.fparamTemp.stepPI = fnumber;  
6970:  MOVFF  1C0,13B
6974:  MOVFF  1BF,13A
6978:  MOVFF  1BE,139
697C:  MOVFF  1BD,138
.................... 					fuzzy.fparamTemp.gstepPI = TRUE; 
6980:  MOVLB  1
6982:  BSF    x3E.2
.................... 					break; 
6984:  MOVLB  0
6986:  BRA    69DC
.................... 				case 'z':  
.................... 					fuzzy.fparamTemp.Kpi = fnumber; 
6988:  MOVFF  1C0,12B
698C:  MOVFF  1BF,12A
6990:  MOVFF  1BE,129
6994:  MOVFF  1BD,128
.................... 					tgk = TRUE; 
6998:  MOVLB  1
699A:  BSF    xC1.0
.................... 					break; 
699C:  MOVLB  0
699E:  BRA    69DC
.................... 				case 'G': 
69A0:  CLRF   19
69A2:  BTFSC  FF2.6
69A4:  BSF    19.6
69A6:  BCF    FF2.6
69A8:  BTFSC  FF2.7
69AA:  BSF    19.7
69AC:  BCF    FF2.7
.................... 					Tsupervision = fnumber; 
69AE:  MOVFF  1C0,21C
69B2:  MOVFF  1BF,21B
69B6:  MOVFF  1BE,21A
69BA:  MOVFF  1BD,219
69BE:  CALL   08F2
69C2:  BTFSC  19.6
69C4:  BSF    FF2.6
69C6:  BTFSC  19.7
69C8:  BSF    FF2.7
69CA:  MOVFF  02,181
69CE:  MOVFF  01,180
.................... 					break; 
69D2:  BRA    69DC
....................         default: putc(caracter_no_valido); break; 
69D4:  MOVLW  3F
69D6:  CALL   4F82
69DA:  BRA    69DC
....................       } 
.................... } 
69DC:  GOTO   70C8 (RETURN)
....................  
.................... #separate 
.................... void estado_pid_function() 
.................... { 
.................... 		if(fFirst_time_pid==FALSE)  
69E0:  MOVLB  1
69E2:  BTFSC  x7F.6
69E4:  BRA    69F6
.................... 		{ 
.................... 			fFirst_time_pid=TRUE; 
69E6:  BSF    x7F.6
.................... 			fprintPIDini=TRUE; 
69E8:  BSF    x77.0
.................... 			enable_timer0(FALSE); 
69EA:  CLRF   xCA
69EC:  MOVLB  0
69EE:  CALL   59AC
.................... 		} 
.................... 		else 
69F2:  BRA    6A00
69F4:  MOVLB  1
.................... 			enable_timer0(TRUE); 
69F6:  MOVLW  01
69F8:  MOVWF  xCA
69FA:  MOVLB  0
69FC:  CALL   59AC
.................... 	 
.................... 		pid_selected=TRUE; 
6A00:  BSF    36.3
.................... 		fuzzy_selected=FALSE; 
6A02:  BCF    36.2
.................... 		fFirst_time_fuzzy=FALSE; 
6A04:  MOVLB  1
6A06:  BCF    x7F.7
.................... } 
6A08:  MOVLB  0
6A0A:  RETLW  00
....................  
.................... #separate 
.................... void estado_fuzzy_function() 
.................... { 
.................... 		if(fFirst_time_fuzzy==FALSE)  
6A0C:  MOVLB  1
6A0E:  BTFSC  x7F.7
6A10:  BRA    6A3A
.................... 		{ 
.................... 			fFirst_time_fuzzy=TRUE; 
6A12:  BSF    x7F.7
.................... 			fprintFUZZYini=TRUE; 
6A14:  BSF    x77.1
6A16:  CLRF   19
6A18:  BTFSC  FF2.6
6A1A:  BSF    19.6
6A1C:  BCF    FF2.6
6A1E:  BTFSC  FF2.7
6A20:  BSF    19.7
6A22:  BCF    FF2.7
.................... 			enable_timer1(FALSE); 
6A24:  MOVLB  2
6A26:  CLRF   x13
6A28:  MOVLB  0
6A2A:  CALL   34BE
6A2E:  BTFSC  19.6
6A30:  BSF    FF2.6
6A32:  BTFSC  19.7
6A34:  BSF    FF2.7
.................... 		}	 
.................... 		else 
6A36:  BRA    6A5C
6A38:  MOVLB  1
6A3A:  CLRF   19
6A3C:  BTFSC  FF2.6
6A3E:  BSF    19.6
6A40:  BCF    FF2.6
6A42:  BTFSC  FF2.7
6A44:  BSF    19.7
6A46:  BCF    FF2.7
.................... 			enable_timer1(TRUE); 
6A48:  MOVLW  01
6A4A:  MOVLB  2
6A4C:  MOVWF  x13
6A4E:  MOVLB  0
6A50:  CALL   34BE
6A54:  BTFSC  19.6
6A56:  BSF    FF2.6
6A58:  BTFSC  19.7
6A5A:  BSF    FF2.7
.................... 				 
.................... 		set_timer1(tmr1);		 
6A5C:  MOVFF  179,FCF
6A60:  MOVFF  178,FCE
.................... 		fuzzy_selected=TRUE; 
6A64:  BSF    36.2
.................... 		pid_selected=FALSE; 
6A66:  BCF    36.3
.................... 		fFirst_time_pid=FALSE; 
6A68:  MOVLB  1
6A6A:  BCF    x7F.6
.................... } 
6A6C:  MOVLB  0
6A6E:  RETLW  00
....................  
.................... #separate 
.................... void end_of_Tx_function() 
.................... { 
....................      		if(pid_selected) 
6A70:  BTFSS  36.3
6A72:  BRA    6AE4
.................... 				{ 
.................... 					pid.param.Kp = pid.paramTemp.Kp; 
6A74:  MOVFF  D8,CA
6A78:  MOVFF  D7,C9
6A7C:  MOVFF  D6,C8
6A80:  MOVFF  D5,C7
.................... 					pid.param.Ki = pid.paramTemp.Ki; 
6A84:  MOVFF  E0,D2
6A88:  MOVFF  DF,D1
6A8C:  MOVFF  DE,D0
6A90:  MOVFF  DD,CF
.................... 					pid.param.Kd = pid.paramTemp.Kd; 
6A94:  MOVFF  DC,CE
6A98:  MOVFF  DB,CD
6A9C:  MOVFF  DA,CC
6AA0:  MOVFF  D9,CB
.................... 					pid.param.Tc = pid.paramTemp.Tc; 
6AA4:  MOVFF  E2,D4
6AA8:  MOVFF  E1,D3
6AAC:  CLRF   19
6AAE:  BTFSC  FF2.6
6AB0:  BSF    19.6
6AB2:  BCF    FF2.6
6AB4:  BTFSC  FF2.7
6AB6:  BSF    19.7
6AB8:  BCF    FF2.7
....................  
.................... 					tmr0 = calc_tmr(pid.param.Tc); 
6ABA:  MOVFF  D4,214
6ABE:  MOVFF  D3,213
6AC2:  CALL   3428
6AC6:  BTFSC  19.6
6AC8:  BSF    FF2.6
6ACA:  BTFSC  19.7
6ACC:  BSF    FF2.7
6ACE:  MOVFF  02,17B
6AD2:  MOVFF  01,17A
.................... 					     
.................... 					if(modo==manual) 
6AD6:  BTFSS  36.1
6AD8:  BRA    6AE2
.................... 						pid.u=tu; 
6ADA:  MOVFF  1C4,E4
6ADE:  MOVFF  1C3,E3
....................         }   
.................... 				else if(fuzzy_selected) 
6AE2:  BRA    6BF8
6AE4:  BTFSS  36.2
6AE6:  BRA    6BF8
.................... 				{ 
.................... 					fuzzy.fparam.Kp = fuzzy.fparamTemp.Kp; 
6AE8:  MOVFF  11F,FC
6AEC:  MOVFF  11E,FB
6AF0:  MOVFF  11D,FA
6AF4:  MOVFF  11C,F9
.................... 					fuzzy.fparam.Ki = fuzzy.fparamTemp.Ki; 
6AF8:  MOVFF  127,104
6AFC:  MOVFF  126,103
6B00:  MOVFF  125,102
6B04:  MOVFF  124,101
.................... 					fuzzy.fparam.Kd = fuzzy.fparamTemp.Kd; 
6B08:  MOVFF  123,100
6B0C:  MOVFF  122,FF
6B10:  MOVFF  121,FE
6B14:  MOVFF  120,FD
.................... 					fuzzy.fparam.Kpi = fuzzy.fparamTemp.Kpi; 
6B18:  MOVFF  12B,108
6B1C:  MOVFF  12A,107
6B20:  MOVFF  129,106
6B24:  MOVFF  128,105
.................... 					fuzzy.fparam.universo_duPI_max = fuzzy.fparamTemp.universo_duPI_max; 
6B28:  MOVFF  12F,10C
6B2C:  MOVFF  12E,10B
.................... 					fuzzy.fparam.universo_duPI_min = fuzzy.fparamTemp.universo_duPI_min; 
6B30:  MOVFF  12D,10A
6B34:  MOVFF  12C,109
.................... 					fuzzy.fparam.universo_uPD_max = fuzzy.fparamTemp.universo_uPD_max; 
6B38:  MOVFF  133,110
6B3C:  MOVFF  132,10F
.................... 					fuzzy.fparam.universo_uPD_min = fuzzy.fparamTemp.universo_uPD_min; 
6B40:  MOVFF  131,10E
6B44:  MOVFF  130,10D
.................... 					fuzzy.fparam.Tc = fuzzy.fparamTemp.Tc; 
6B48:  MOVFF  13D,11A
6B4C:  MOVFF  13C,119
.................... 					fuzzy.fparam.stepPD = fuzzy.fparamTemp.stepPD; 
6B50:  MOVFF  137,114
6B54:  MOVFF  136,113
6B58:  MOVFF  135,112
6B5C:  MOVFF  134,111
.................... 					fuzzy.fparam.stepPI = fuzzy.fparamTemp.stepPI; 
6B60:  MOVFF  13B,118
6B64:  MOVFF  13A,117
6B68:  MOVFF  139,116
6B6C:  MOVFF  138,115
6B70:  CLRF   19
6B72:  BTFSC  FF2.6
6B74:  BSF    19.6
6B76:  BCF    FF2.6
6B78:  BTFSC  FF2.7
6B7A:  BSF    19.7
6B7C:  BCF    FF2.7
.................... 					 
.................... 					tmr1 = calc_tmr(fuzzy.fparam.Tc); 
6B7E:  MOVFF  11A,214
6B82:  MOVFF  119,213
6B86:  CALL   3428
6B8A:  BTFSC  19.6
6B8C:  BSF    FF2.6
6B8E:  BTFSC  19.7
6B90:  BSF    FF2.7
6B92:  MOVFF  02,179
6B96:  MOVFF  01,178
.................... 					 
.................... 				  initialize_Fuzzy(); 
6B9A:  CALL   4D5A
.................... 								 
.................... 					if(modo==manual) 
6B9E:  BTFSS  36.1
6BA0:  BRA    6BD4
6BA2:  CLRF   19
6BA4:  BTFSC  FF2.6
6BA6:  BSF    19.6
6BA8:  BCF    FF2.6
6BAA:  BTFSC  FF2.7
6BAC:  BSF    19.7
6BAE:  BCF    FF2.7
.................... 						fuzzy.u=tu; 
6BB0:  MOVFF  1C4,216
6BB4:  MOVFF  1C3,215
6BB8:  CALL   04D4
6BBC:  BTFSC  19.6
6BBE:  BSF    FF2.6
6BC0:  BTFSC  19.7
6BC2:  BSF    FF2.7
6BC4:  MOVFF  03,152
6BC8:  MOVFF  02,151
6BCC:  MOVFF  01,150
6BD0:  MOVFF  00,14F
.................... 						 
.................... 					fuzzy.fparam.gstepPD = fuzzy.fparamTemp.gstepPD; 
6BD4:  MOVLB  1
6BD6:  BCF    x1B.3
6BD8:  BTFSC  x3E.3
6BDA:  BSF    x1B.3
.................... 					fuzzy.fparam.gstepPI = fuzzy.fparamTemp.gstepPI; 
6BDC:  BCF    x1B.2
6BDE:  BTFSC  x3E.2
6BE0:  BSF    x1B.2
.................... 					fuzzy.fparam.guniversoPI = fuzzy.fparamTemp.guniversoPI; 
6BE2:  BCF    x1B.0
6BE4:  BTFSC  x3E.0
6BE6:  BSF    x1B.0
.................... 					fuzzy.fparam.guniversoPD = fuzzy.fparamTemp.guniversoPD; 
6BE8:  BCF    x1B.1
6BEA:  BTFSC  x3E.1
6BEC:  BSF    x1B.1
....................  
.................... 					fuzzy.fparamTemp.gstepPD = FALSE; 
6BEE:  BCF    x3E.3
.................... 					fuzzy.fparamTemp.gstepPI = FALSE; 
6BF0:  BCF    x3E.2
.................... 					fuzzy.fparamTemp.guniversoPI = FALSE; 
6BF2:  BCF    x3E.0
.................... 					fuzzy.fparamTemp.guniversoPD = FALSE; 
6BF4:  BCF    x3E.1
6BF6:  MOVLB  0
.................... 				} 
.................... 					 
.................... 				cantM = tcantM; 
6BF8:  MOVFF  1C2,182
.................... 				if(cantM>16)  
6BFC:  MOVLB  1
6BFE:  MOVF   x82,W
6C00:  SUBLW  10
6C02:  BC    6C08
.................... 					cantM=16;       
6C04:  MOVLW  10
6C06:  MOVWF  x82
....................  
.................... 				gk = tgk; 
6C08:  BCF    x77.4
6C0A:  BTFSC  xC1.0
6C0C:  BSF    x77.4
.................... 				gcantM = tgcantM; 
6C0E:  BCF    x7F.4
6C10:  BTFSC  xC1.1
6C12:  BSF    x7F.4
.................... 				tgk = FALSE; 
6C14:  BCF    xC1.0
.................... 				tgcantM = FALSE; 
6C16:  BCF    xC1.1
.................... 				gTc = tgTc;					 
6C18:  BCF    x77.5
6C1A:  BTFSC  xC1.2
6C1C:  BSF    x77.5
.................... 				tgTc = FALSE; 
6C1E:  BCF    xC1.2
.................... } 
6C20:  MOVLB  0
6C22:  GOTO   70EE (RETURN)
....................  
.................... #separate 
.................... void escritura_configuracion_function() 
.................... { 
.................... 				switch(bRx[0]) 
....................         { 
*
6E2E:  MOVLW  01
6E30:  MOVLB  1
6E32:  SUBWF  xA7,W
6E34:  ADDLW  F9
6E36:  BC    6EE0
6E38:  ADDLW  07
6E3A:  MOVLB  0
6E3C:  GOTO   6F2A
....................         //case 0: solo para RS485 
....................           case 1:  //cambiar baud rate 
....................           //guardar en EEPROM un identificador y actualizar en setup() al reiniciar el micro 
....................             gBR=1;  //habilita guardar el Baud Rate en memoria 
6E40:  BSF    36.5
....................             seleccionBR=bRx[1]; 
6E42:  MOVFF  1A8,175
....................           break; 
6E46:  MOVLB  1
6E48:  BRA    6EE0
....................           case 2:  //cambiar frecuencia del PWM 
....................           //guardar en EEPROM un identificador y actualizar en setup() al reiniciar el micro 
....................             gPWMf=1;  //habilita guardar frecuencia del PWM en memoria             
6E4A:  BSF    36.6
....................             seleccionPWMf=bRx[1]; 
6E4C:  MOVFF  1A8,176
....................           break; 
6E50:  MOVLB  1
6E52:  BRA    6EE0
....................           case 3: //tipo de procesamiento 
....................           //guardar en EEPROM un identificador y actualizar en setup() al reiniciar el micro 
....................             gTP=1;  //habilita guardar el tipo de procesamiento en memoria 
6E54:  BSF    36.7
....................             tipo_procesamiento=bRx[1];   
6E56:  MOVFF  1A8,1A3
....................             switch(tipo_procesamiento) 
....................             { 
6E5A:  MOVLB  1
6E5C:  MOVF   xA3,W
6E5E:  ADDLW  FC
6E60:  BC    6E84
6E62:  ADDLW  04
6E64:  MOVLB  0
6E66:  GOTO   6EE6
....................               case 0: fcantM=FALSE; break; 
6E6A:  MOVLB  1
6E6C:  BCF    x7F.3
6E6E:  BRA    6E84
....................               case 1: fcantM=TRUE; break; 
6E70:  MOVLB  1
6E72:  BSF    x7F.3
6E74:  BRA    6E84
....................               case 2: fcantM=FALSE; break; 
6E76:  MOVLB  1
6E78:  BCF    x7F.3
6E7A:  BRA    6E84
....................               case 3: fcantM=TRUE; break; 
6E7C:  MOVLB  1
6E7E:  BSF    x7F.3
6E80:  BRA    6E84
6E82:  MOVLB  1
....................             }           
....................           break; 
6E84:  BRA    6EE0
....................           case 4: //cantidad de terminos del filtro promedio 
....................             gcantM=TRUE; 
6E86:  MOVLB  1
6E88:  BSF    x7F.4
....................             switch(bRx[1]) 
....................             { 
6E8A:  MOVF   xA8,W
6E8C:  ADDLW  FC
6E8E:  BC    6EBA
6E90:  ADDLW  04
6E92:  MOVLB  0
6E94:  GOTO   6F08
....................               case 0: cantM=2; break; 
6E98:  MOVLW  02
6E9A:  MOVLB  1
6E9C:  MOVWF  x82
6E9E:  BRA    6EBA
....................               case 1: cantM=4; break; 
6EA0:  MOVLW  04
6EA2:  MOVLB  1
6EA4:  MOVWF  x82
6EA6:  BRA    6EBA
....................               case 2: cantM=8; break; 
6EA8:  MOVLW  08
6EAA:  MOVLB  1
6EAC:  MOVWF  x82
6EAE:  BRA    6EBA
....................               case 3: cantM=16; break; 
6EB0:  MOVLW  10
6EB2:  MOVLB  1
6EB4:  MOVWF  x82
6EB6:  BRA    6EBA
6EB8:  MOVLB  1
....................             } 
....................           break; 
6EBA:  BRA    6EE0
.................... 					case 5: 
.................... 						gPWMseleccion=TRUE; 
6EBC:  MOVLB  1
6EBE:  BSF    x77.7
.................... 						fPWM1=bRx[1]; 
6EC0:  BCF    x77.6
6EC2:  BTFSC  xA8.0
6EC4:  BSF    x77.6
.................... 						break; 
6EC6:  BRA    6EE0
.................... 					case 6: 
.................... 						gADseleccion=TRUE; 
6EC8:  MOVLB  1
6ECA:  BSF    x7F.0
.................... 						ADselected=bRx[1]; 
6ECC:  MOVFF  1A8,17E
.................... 						break; 
6ED0:  BRA    6EE0
.................... 					case 7: 
.................... 						gTipoAccion=TRUE; 
6ED2:  MOVLB  1
6ED4:  BSF    x7F.2
.................... 						fTipoAccion=bRx[1]; 
6ED6:  BCF    x7F.1
6ED8:  BTFSC  xA8.0
6EDA:  BSF    x7F.1
.................... 						break; 
6EDC:  BRA    6EE0
6EDE:  MOVLB  1
....................         } 
.................... } 
6EE0:  MOVLB  0
6EE2:  GOTO   716C (RETURN)
....................  
.................... #separate 
.................... void entrada_digital_function() 
.................... { 
....................         switch(bRx[0]) 
....................         { 
*
6C26:  MOVLB  1
6C28:  MOVF   xA7,W
6C2A:  XORLW  00
6C2C:  MOVLB  0
6C2E:  BZ    6C46
6C30:  XORLW  01
6C32:  BZ    6C60
6C34:  XORLW  03
6C36:  BZ    6C7A
6C38:  XORLW  01
6C3A:  BZ    6C94
6C3C:  XORLW  07
6C3E:  BZ    6CAE
6C40:  XORLW  01
6C42:  BZ    6CC8
6C44:  BRA    6CE2
....................           case 0: printf("%d",input(PIN_B4)); break; 
6C46:  BSF    F93.4
6C48:  MOVLW  00
6C4A:  BTFSC  F81.4
6C4C:  MOVLW  01
6C4E:  MOVLB  1
6C50:  MOVWF  xCA
6C52:  MOVWF  xCB
6C54:  MOVLW  1F
6C56:  MOVWF  xCC
6C58:  MOVLB  0
6C5A:  CALL   54C4
6C5E:  BRA    6CE4
....................           case 1: printf("%d",input(PIN_B5)); break; 
6C60:  BSF    F93.5
6C62:  MOVLW  00
6C64:  BTFSC  F81.5
6C66:  MOVLW  01
6C68:  MOVLB  1
6C6A:  MOVWF  xCA
6C6C:  MOVWF  xCB
6C6E:  MOVLW  1F
6C70:  MOVWF  xCC
6C72:  MOVLB  0
6C74:  CALL   54C4
6C78:  BRA    6CE4
....................           case 2: printf("%d",input(PIN_B6)); break; 
6C7A:  BSF    F93.6
6C7C:  MOVLW  00
6C7E:  BTFSC  F81.6
6C80:  MOVLW  01
6C82:  MOVLB  1
6C84:  MOVWF  xCA
6C86:  MOVWF  xCB
6C88:  MOVLW  1F
6C8A:  MOVWF  xCC
6C8C:  MOVLB  0
6C8E:  CALL   54C4
6C92:  BRA    6CE4
....................           case 3: printf("%d",input(PIN_B7)); break; 
6C94:  BSF    F93.7
6C96:  MOVLW  00
6C98:  BTFSC  F81.7
6C9A:  MOVLW  01
6C9C:  MOVLB  1
6C9E:  MOVWF  xCA
6CA0:  MOVWF  xCB
6CA2:  MOVLW  1F
6CA4:  MOVWF  xCC
6CA6:  MOVLB  0
6CA8:  CALL   54C4
6CAC:  BRA    6CE4
....................           case 4: printf("%d",input(PIN_B0)); break; 
6CAE:  BSF    F93.0
6CB0:  MOVLW  00
6CB2:  BTFSC  F81.0
6CB4:  MOVLW  01
6CB6:  MOVLB  1
6CB8:  MOVWF  xCA
6CBA:  MOVWF  xCB
6CBC:  MOVLW  1F
6CBE:  MOVWF  xCC
6CC0:  MOVLB  0
6CC2:  CALL   54C4
6CC6:  BRA    6CE4
....................           case 5: printf("%d",input(PIN_A4)); break; 
6CC8:  BSF    F92.4
6CCA:  MOVLW  00
6CCC:  BTFSC  F80.4
6CCE:  MOVLW  01
6CD0:  MOVLB  1
6CD2:  MOVWF  xCA
6CD4:  MOVWF  xCB
6CD6:  MOVLW  1F
6CD8:  MOVWF  xCC
6CDA:  MOVLB  0
6CDC:  CALL   54C4
6CE0:  BRA    6CE4
....................           default: break; 
6CE2:  BRA    6CE4
....................         } 
.................... } 
6CE4:  GOTO   7180 (RETURN)
....................  
.................... #separate 
.................... void ciclo_util_PWM_function() 
.................... { 
....................      //   get_string(bRx,buffer_size); 
....................         fnumber = strtod(bRx,&buffer); 
6CE8:  MOVLW  01
6CEA:  MOVLB  1
6CEC:  MOVWF  xCB
6CEE:  MOVLW  A7
6CF0:  MOVWF  xCA
6CF2:  MOVLW  01
6CF4:  MOVWF  xCD
6CF6:  MOVLW  A5
6CF8:  MOVWF  xCC
6CFA:  MOVLB  0
6CFC:  CALL   61EA
6D00:  MOVFF  03,1C0
6D04:  MOVFF  02,1BF
6D08:  MOVFF  01,1BE
6D0C:  MOVFF  00,1BD
....................         switch(buffer[0]) 
....................         { 
6D10:  MOVLB  1
6D12:  MOVF   xA5,W
6D14:  MOVWF  FE9
6D16:  MOVF   xA6,W
6D18:  MOVWF  FEA
6D1A:  MOVF   FEF,W
6D1C:  XORLW  75
6D1E:  MOVLB  0
6D20:  BZ    6D28
6D22:  XORLW  11
6D24:  BZ    6D7E
6D26:  BRA    6DD4
....................           case 'u':               
6D28:  CLRF   19
6D2A:  BTFSC  FF2.6
6D2C:  BSF    19.6
6D2E:  BCF    FF2.6
6D30:  BTFSC  FF2.7
6D32:  BSF    19.7
6D34:  BCF    FF2.7
....................             set_pwm1_duty((int16)fnumber); 
6D36:  MOVFF  1C0,21C
6D3A:  MOVFF  1BF,21B
6D3E:  MOVFF  1BE,21A
6D42:  MOVFF  1BD,219
6D46:  CALL   08F2
6D4A:  BTFSC  19.6
6D4C:  BSF    FF2.6
6D4E:  BTFSC  19.7
6D50:  BSF    FF2.7
6D52:  MOVFF  02,1CB
6D56:  MOVFF  01,1CA
6D5A:  MOVLB  1
6D5C:  RRCF   xCB,F
6D5E:  RRCF   xCA,F
6D60:  RRCF   xCB,F
6D62:  RRCF   xCA,F
6D64:  RRCF   xCB,F
6D66:  MOVFF  1CA,FBE
6D6A:  RRCF   xCB,F
6D6C:  RRCF   xCB,W
6D6E:  ANDLW  30
6D70:  MOVWF  00
6D72:  MOVF   FBD,W
6D74:  ANDLW  CF
6D76:  IORWF  00,W
6D78:  MOVWF  FBD
....................             break; 
6D7A:  MOVLB  0
6D7C:  BRA    6DD4
....................           case 'd':  
6D7E:  CLRF   19
6D80:  BTFSC  FF2.6
6D82:  BSF    19.6
6D84:  BCF    FF2.6
6D86:  BTFSC  FF2.7
6D88:  BSF    19.7
6D8A:  BCF    FF2.7
....................             set_pwm2_duty((int16)fnumber); 
6D8C:  MOVFF  1C0,21C
6D90:  MOVFF  1BF,21B
6D94:  MOVFF  1BE,21A
6D98:  MOVFF  1BD,219
6D9C:  CALL   08F2
6DA0:  BTFSC  19.6
6DA2:  BSF    FF2.6
6DA4:  BTFSC  19.7
6DA6:  BSF    FF2.7
6DA8:  MOVFF  02,1CB
6DAC:  MOVFF  01,1CA
6DB0:  MOVLB  1
6DB2:  RRCF   xCB,F
6DB4:  RRCF   xCA,F
6DB6:  RRCF   xCB,F
6DB8:  RRCF   xCA,F
6DBA:  RRCF   xCB,F
6DBC:  MOVFF  1CA,FBB
6DC0:  RRCF   xCB,F
6DC2:  RRCF   xCB,W
6DC4:  ANDLW  30
6DC6:  MOVWF  00
6DC8:  MOVF   FBA,W
6DCA:  ANDLW  CF
6DCC:  IORWF  00,W
6DCE:  MOVWF  FBA
....................             break; 
6DD0:  MOVLB  0
6DD2:  BRA    6DD4
....................         } 
.................... } 
6DD4:  GOTO   7154 (RETURN)
....................  
.................... #separate 
.................... void salida_digital_function() 
.................... { 
....................         switch(bRx[0]) 
....................         { 
6DD8:  MOVLB  1
6DDA:  MOVF   xA7,W
6DDC:  XORLW  00
6DDE:  MOVLB  0
6DE0:  BZ    6DEC
6DE2:  XORLW  01
6DE4:  BZ    6DFC
6DE6:  XORLW  03
6DE8:  BZ    6E0C
6DEA:  BRA    6E1E
....................           case 0: output_bit(PIN_B1,bRx[1]); break; //(pin,value) 
6DEC:  MOVLB  1
6DEE:  MOVF   xA8,F
6DF0:  BNZ   6DF6
6DF2:  BCF    F8A.1
6DF4:  BRA    6DF8
6DF6:  BSF    F8A.1
6DF8:  BCF    F93.1
6DFA:  BRA    6E28
....................           case 1: output_bit(PIN_B2,bRx[1]); break; //(pin,value) 
6DFC:  MOVLB  1
6DFE:  MOVF   xA8,F
6E00:  BNZ   6E06
6E02:  BCF    F8A.2
6E04:  BRA    6E08
6E06:  BSF    F8A.2
6E08:  BCF    F93.2
6E0A:  BRA    6E28
....................           case 2: output_bit(PIN_B3,bRx[1]); break; //(pin,value) 
6E0C:  MOVLB  1
6E0E:  MOVF   xA8,F
6E10:  BNZ   6E16
6E12:  BCF    F8A.3
6E14:  BRA    6E18
6E16:  BSF    F8A.3
6E18:  BCF    F93.3
6E1A:  BRA    6E28
6E1C:  MOVLB  0
....................           default: putc(caracter_no_valido); break; 
6E1E:  MOVLW  3F
6E20:  CALL   4F82
6E24:  MOVLB  1
6E26:  BRA    6E28
....................         } 
.................... } 
6E28:  MOVLB  0
6E2A:  GOTO   715E (RETURN)
....................  
.................... #separate 
.................... void lectura_configuracion_function() 
.................... { 
....................         switch(bRx[0]) 
....................         { 
*
6F52:  MOVLW  01
6F54:  MOVLB  1
6F56:  SUBWF  xA7,W
6F58:  ADDLW  F9
6F5A:  BC    6FFA
6F5C:  ADDLW  07
6F5E:  MOVLB  0
6F60:  GOTO   7000
....................         //case 0: solo en caso de RS485 
....................         case 1:  //valor de velocidad de comunicacion segun la tabla 
.................... 				putc(1); 
6F64:  MOVLW  01
6F66:  CALL   4F82
.................... 				putc(seleccionBR); 
6F6A:  MOVLB  1
6F6C:  MOVF   x75,W
6F6E:  MOVLB  0
6F70:  CALL   4F82
....................           /*   
.................... 						switch(seleccionBR) 
....................             { 
....................               case 0: printf("9600bps\r"); break; 
....................               case 1: printf("1200bps\r"); break; 
....................               case 2: printf("2400bps\r"); break; 
....................               case 3: printf("4800bps\r"); break; 
....................               case 4: printf("19200bps\r"); break; 
....................               case 5: printf("28800bps\r"); break; 
....................               case 6: printf("33600bps\r"); break; 
....................               case 7: printf("38400bps\r"); break; 
....................               default: printf("9600bps\r"); break; 
....................             } 
.................... 					*/ 
....................             break; 
6F74:  MOVLB  1
6F76:  BRA    6FFA
....................         case 2: //periodo de los PWM 0 y 1 
.................... 						putc(2); 
6F78:  MOVLW  02
6F7A:  CALL   4F82
.................... 						putc(seleccionPWMf); 
6F7E:  MOVLB  1
6F80:  MOVF   x76,W
6F82:  MOVLB  0
6F84:  CALL   4F82
.................... 					/*	 
....................             switch(seleccionPWMf) 
....................             { 
....................               case 0: printf("1.22KHz [0.82ms]\r"); break; 
....................               case 1: printf("2.44KHz [0.41ms]\r"); break; 
....................               case 2: printf("4.88KHz [0.20ms]\r"); break; 
....................               case 3: printf("7.32KHz [0.14ms]\r"); break; 
....................               case 4: printf("9.76KHz [0.10ms]\r"); break; 
....................               case 5: printf("12.20KHz [81.9us]\r"); break; 
....................               case 6: printf("17.08KHz [58.5us]\r"); break; 
....................               case 7: printf("19.53KHz [51.2us]\r"); break; 
....................               case 8: printf("30.00KHz [33us]\r"); break; 
....................               default: printf("30.00KHz [33us]\r"); break; 
....................             } 
.................... 					*/ 
....................             break;   
6F88:  MOVLB  1
6F8A:  BRA    6FFA
....................         case 3: //tipo de procesamiento 
.................... 						putc(3); 
6F8C:  MOVLW  03
6F8E:  CALL   4F82
.................... 						putc(tipo_procesamiento); 
6F92:  MOVLB  1
6F94:  MOVF   xA3,W
6F96:  MOVLB  0
6F98:  CALL   4F82
....................           /*   
.................... 						switch(tipo_procesamiento) 
....................             { 
....................               case 0: printf("SIN PROCESAMIENTO\r"); break; 
....................               case 1: printf("FILTRO PROMEDIO\r"); break; 
....................               case 2: printf("CONVERSION A u.i.\r"); break; 
....................               case 3: printf("FILTRO Y CONVERSION\r"); break; 
....................             } 
.................... 					*/ 
....................             break; 
6F9C:  MOVLB  1
6F9E:  BRA    6FFA
....................         case 4: //printf("Cantidad de muestras: %d\r",cantM);  
.................... 					putc(4); 
6FA0:  MOVLW  04
6FA2:  CALL   4F82
.................... 					putc(cantM); 
6FA6:  MOVLB  1
6FA8:  MOVF   x82,W
6FAA:  MOVLB  0
6FAC:  CALL   4F82
.................... 					break;  //cantidad de muestras del filtro promedio 
6FB0:  MOVLB  1
6FB2:  BRA    6FFA
.................... 				case 5:  //SeleccionPWM 
.................... 					putc(5); 
6FB4:  MOVLW  05
6FB6:  CALL   4F82
.................... 					putc(fPWM1); 
6FBA:  MOVLW  00
6FBC:  MOVLB  1
6FBE:  BTFSC  x77.6
6FC0:  MOVLW  01
6FC2:  MOVLB  0
6FC4:  CALL   4F82
.................... 					break; 
6FC8:  MOVLB  1
6FCA:  BRA    6FFA
.................... 				case 6:  //SeleccionAD 
.................... 					putc(6); 
6FCC:  MOVLW  06
6FCE:  CALL   4F82
.................... 					putc(ADselected); 
6FD2:  MOVLB  1
6FD4:  MOVF   x7E,W
6FD6:  MOVLB  0
6FD8:  CALL   4F82
.................... 					break; 
6FDC:  MOVLB  1
6FDE:  BRA    6FFA
.................... 			  case 7:  //Tipo de accion 
.................... 			  	putc(7); 
6FE0:  MOVLW  07
6FE2:  CALL   4F82
.................... 			  	putc(fTipoAccion); 
6FE6:  MOVLW  00
6FE8:  MOVLB  1
6FEA:  BTFSC  x7F.1
6FEC:  MOVLW  01
6FEE:  MOVLB  0
6FF0:  CALL   4F82
.................... 			  	break; 
6FF4:  MOVLB  1
6FF6:  BRA    6FFA
6FF8:  MOVLB  1
....................         } 
.................... } 
6FFA:  MOVLB  0
6FFC:  GOTO   7180 (RETURN)
....................  
....................  
.................... /////////////////////////////*FUNCTIONS*//////////////////////////////////////// 
....................  
.................... #INT_default 
.................... void default_interrupt() 
.................... { 
.................... /* 
.................... 	Esta interrupcion se activa cuando se resetea el micro, 
.................... 	por lo que hay que deshabilitarla. 
.................... */ 
.................... 	if(interrupt_active(INT_USB)) 
*
01E8:  BTFSS  FA1.5
01EA:  BRA    01EE
.................... 		disable_interrupts(INT_USB);  
01EC:  BCF    FA0.5
.................... } 
....................  
01EE:  GOTO   0080
.................... #INT_TIMER0  
.................... void TIMER0()  
.................... {	 
....................   set_timer0(tmr0); 
*
0D3E:  MOVFF  17B,FD7
0D42:  MOVFF  17A,FD6
....................       
.................... 	algoritmo_PID(); 
0D46:  BRA    0986
.................... 	 
.................... 	print_enabled(); 
0D48:  RCALL  0D1E
.................... } 
....................  
0D4A:  BCF    FF2.2
0D4C:  GOTO   0080
.................... #int_TIMER1  
.................... void TIMER1() 
.................... {   
*
34E8:  MOVLB  2
34EA:  CLRF   x0A
34EC:  CLRF   x09
34EE:  CLRF   x0E
34F0:  CLRF   x0D
34F2:  CLRF   x0C
34F4:  CLRF   x0B
34F6:  CLRF   x12
34F8:  CLRF   x11
34FA:  CLRF   x10
34FC:  CLRF   x0F
.................... 	int16 contms=0; 
.................... 	float contms1=0,contms2=0; 
....................  
.................... 	set_timer1(tmr1);   
34FE:  MOVFF  179,FCF
3502:  MOVFF  178,FCE
.................... 	 
.................... 	contms1=get_timer1(); 			 
3506:  MOVF   FCE,W
3508:  MOVFF  FCF,03
350C:  MOVWF  x15
350E:  MOVFF  FCF,216
3512:  MOVLB  0
3514:  CALL   04D4
3518:  MOVFF  03,20E
351C:  MOVFF  02,20D
3520:  MOVFF  01,20C
3524:  MOVFF  00,20B
.................... 	algoritmo_Fuzzy();			 
3528:  BRA    2EAE
.................... 	contms2=get_timer1(); 
352A:  MOVF   FCE,W
352C:  MOVFF  FCF,03
3530:  MOVLB  2
3532:  MOVWF  x15
3534:  MOVFF  FCF,216
3538:  MOVLB  0
353A:  CALL   04D4
353E:  MOVFF  03,212
3542:  MOVFF  02,211
3546:  MOVFF  01,210
354A:  MOVFF  00,20F
.................... 	 
.................... 	if(contms1 > contms2) 
354E:  MOVFF  212,382
3552:  MOVFF  211,381
3556:  MOVFF  210,380
355A:  MOVFF  20F,37F
355E:  MOVFF  20E,386
3562:  MOVFF  20D,385
3566:  MOVFF  20C,384
356A:  MOVFF  20B,383
356E:  CALL   0878
3572:  BNC   3658
.................... 		contms = (contms2 + 65536 - contms1) * conv_tiempo * 100; 
3574:  BCF    FD8.1
3576:  MOVFF  212,386
357A:  MOVFF  211,385
357E:  MOVFF  210,384
3582:  MOVFF  20F,383
3586:  MOVLB  3
3588:  CLRF   x8A
358A:  CLRF   x89
358C:  CLRF   x88
358E:  MOVLW  8F
3590:  MOVWF  x87
3592:  MOVLB  0
3594:  CALL   0600
3598:  MOVFF  00,213
359C:  MOVFF  01,214
35A0:  MOVFF  02,215
35A4:  MOVFF  03,216
35A8:  BSF    FD8.1
35AA:  MOVFF  03,386
35AE:  MOVFF  02,385
35B2:  MOVFF  01,384
35B6:  MOVFF  00,383
35BA:  MOVFF  20E,38A
35BE:  MOVFF  20D,389
35C2:  MOVFF  20C,388
35C6:  MOVFF  20B,387
35CA:  CALL   0600
35CE:  MOVFF  00,213
35D2:  MOVFF  01,214
35D6:  MOVFF  02,215
35DA:  MOVFF  03,216
35DE:  MOVFF  03,331
35E2:  MOVFF  02,330
35E6:  MOVFF  01,32F
35EA:  MOVFF  00,32E
35EE:  MOVLW  95
35F0:  MOVLB  3
35F2:  MOVWF  x35
35F4:  MOVLW  BF
35F6:  MOVWF  x34
35F8:  MOVLW  56
35FA:  MOVWF  x33
35FC:  MOVLW  6B
35FE:  MOVWF  x32
3600:  MOVLB  0
3602:  CALL   050A
3606:  MOVFF  00,213
360A:  MOVFF  01,214
360E:  MOVFF  02,215
3612:  MOVFF  03,216
3616:  MOVFF  03,331
361A:  MOVFF  02,330
361E:  MOVFF  01,32F
3622:  MOVFF  00,32E
3626:  MOVLB  3
3628:  CLRF   x35
362A:  CLRF   x34
362C:  MOVLW  48
362E:  MOVWF  x33
3630:  MOVLW  85
3632:  MOVWF  x32
3634:  MOVLB  0
3636:  CALL   050A
363A:  MOVFF  03,21C
363E:  MOVFF  02,21B
3642:  MOVFF  01,21A
3646:  MOVFF  00,219
364A:  CALL   08F2
364E:  MOVFF  02,20A
3652:  MOVFF  01,209
.................... 	else 
3656:  BRA    3706
.................... 		contms = (contms2 - contms1) * conv_tiempo * 100; 
3658:  BSF    FD8.1
365A:  MOVFF  212,386
365E:  MOVFF  211,385
3662:  MOVFF  210,384
3666:  MOVFF  20F,383
366A:  MOVFF  20E,38A
366E:  MOVFF  20D,389
3672:  MOVFF  20C,388
3676:  MOVFF  20B,387
367A:  CALL   0600
367E:  MOVFF  00,213
3682:  MOVFF  01,214
3686:  MOVFF  02,215
368A:  MOVFF  03,216
368E:  MOVFF  03,331
3692:  MOVFF  02,330
3696:  MOVFF  01,32F
369A:  MOVFF  00,32E
369E:  MOVLW  95
36A0:  MOVLB  3
36A2:  MOVWF  x35
36A4:  MOVLW  BF
36A6:  MOVWF  x34
36A8:  MOVLW  56
36AA:  MOVWF  x33
36AC:  MOVLW  6B
36AE:  MOVWF  x32
36B0:  MOVLB  0
36B2:  CALL   050A
36B6:  MOVFF  00,213
36BA:  MOVFF  01,214
36BE:  MOVFF  02,215
36C2:  MOVFF  03,216
36C6:  MOVFF  03,331
36CA:  MOVFF  02,330
36CE:  MOVFF  01,32F
36D2:  MOVFF  00,32E
36D6:  MOVLB  3
36D8:  CLRF   x35
36DA:  CLRF   x34
36DC:  MOVLW  48
36DE:  MOVWF  x33
36E0:  MOVLW  85
36E2:  MOVWF  x32
36E4:  MOVLB  0
36E6:  CALL   050A
36EA:  MOVFF  03,21C
36EE:  MOVFF  02,21B
36F2:  MOVFF  01,21A
36F6:  MOVFF  00,219
36FA:  CALL   08F2
36FE:  MOVFF  02,20A
3702:  MOVFF  01,209
.................... 				 
.................... 	if((contms+2) > fuzzy.fparam.Tc)  
3706:  MOVLW  02
3708:  MOVLB  2
370A:  ADDWF  x09,W
370C:  MOVWF  x13
370E:  MOVLW  00
3710:  ADDWFC x0A,W
3712:  MOVWF  x14
3714:  MOVLB  1
3716:  MOVF   x1A,W
3718:  MOVLB  2
371A:  SUBWF  x14,W
371C:  BNC   376A
371E:  BNZ   3730
3720:  MOVF   x13,W
3722:  MOVLB  1
3724:  SUBWF  x19,W
3726:  BTFSS  FD8.0
3728:  BRA    372E
372A:  MOVLB  2
372C:  BRA    376A
372E:  MOVLB  2
.................... 	{ 
.................... 		fuzzy.fparam.Tc=contms+2; 
3730:  MOVLW  02
3732:  ADDWF  x09,W
3734:  MOVLB  1
3736:  MOVWF  x19
3738:  MOVLW  00
373A:  MOVLB  2
373C:  ADDWFC x0A,W
373E:  MOVLB  1
3740:  MOVWF  x1A
.................... 		fuzzy.fparamTemp.Tc=fuzzy.fparam.Tc; 
3742:  MOVFF  11A,13D
3746:  MOVFF  119,13C
.................... 		tmr1 = calc_tmr(fuzzy.fparam.Tc); 
374A:  MOVFF  11A,214
374E:  MOVFF  119,213
3752:  MOVLB  0
3754:  RCALL  3428
3756:  MOVFF  02,179
375A:  MOVFF  01,178
.................... 		fprintTc = TRUE; 
375E:  MOVLB  1
3760:  BSF    x77.2
.................... 		enable_timer1(FALSE); 
3762:  MOVLB  2
3764:  CLRF   x13
3766:  MOVLB  0
3768:  RCALL  34BE
.................... 	}	 
.................... 	 
.................... 	print_enabled(); 
376A:  MOVLB  0
376C:  CALL   0D1E
.................... } 
....................  
3770:  BCF    F9E.0
3772:  GOTO   0080
.................... #separate 
.................... void print_enabled() 
.................... { 
.................... 	if(!count_timer)         
*
0D1E:  MOVLB  1
0D20:  MOVF   x7C,W
0D22:  IORWF  x7D,W
0D24:  BNZ   0D32
....................   {   
.................... 		count_timer=Tsupervision;  
0D26:  MOVFF  181,17D
0D2A:  MOVFF  180,17C
....................  
.................... 		fprint = TRUE; 
0D2E:  BSF    x77.3
....................   } 
....................   else count_timer--; 
0D30:  BRA    0D3A
0D32:  MOVF   x7C,W
0D34:  BTFSC  FD8.2
0D36:  DECF   x7D,F
0D38:  DECF   x7C,F
.................... } 
0D3A:  MOVLB  0
0D3C:  RETLW  00
....................  
.................... #separate 
.................... int16 ADC_Read(int8 pin) 
.................... { 
....................   set_adc_channel(pin); 
*
01F2:  MOVLB  2
01F4:  RLCF   x19,W
01F6:  MOVWF  00
01F8:  RLCF   00,F
01FA:  MOVLW  FC
01FC:  ANDWF  00,F
01FE:  MOVF   FC2,W
0200:  ANDLW  C3
0202:  IORWF  00,W
0204:  MOVWF  FC2
....................   delay_us(10); 
0206:  MOVLW  10
0208:  MOVWF  00
020A:  DECFSZ 00,F
020C:  BRA    020A
020E:  NOP   
....................   return read_adc(); 
0210:  BSF    FC2.1
0212:  BTFSC  FC2.1
0214:  BRA    0212
0216:  MOVFF  FC4,03
021A:  MOVFF  FC3,01
021E:  MOVFF  FC4,02
.................... } 
0222:  MOVLB  0
0224:  RETLW  00
....................  
.................... #separate 
.................... int16 promedio(int16 valor)  //filto promedio para las muestras 
.................... { 
*
026E:  MOVLB  2
0270:  CLRF   x1F
0272:  CLRF   x1E
....................   int8 i; 
....................   int16 suma=0; 
....................   static int8 cont=0; 
....................     
....................   if(cantM!=0 && fcantM==TRUE) 
0274:  MOVLB  1
0276:  MOVF   x82,F
0278:  BZ    02FA
027A:  BTFSS  x7F.3
027C:  BRA    02FA
....................   {   
....................     promM[cont++] = valor; 
027E:  MOVF   xC8,W
0280:  INCF   xC8,F
0282:  MOVWF  00
0284:  BCF    FD8.0
0286:  RLCF   00,F
0288:  MOVF   00,W
028A:  CLRF   03
028C:  ADDLW  83
028E:  MOVWF  FE9
0290:  MOVLW  01
0292:  ADDWFC 03,W
0294:  MOVWF  FEA
0296:  MOVFF  21C,FEC
029A:  MOVF   FED,F
029C:  MOVFF  21B,FEF
....................    
....................     for(i=0;i<cantM;i++) 
02A0:  MOVLB  2
02A2:  CLRF   x1D
02A4:  MOVLB  1
02A6:  MOVF   x82,W
02A8:  MOVLB  2
02AA:  SUBWF  x1D,W
02AC:  BC    02D0
....................       suma+=promM[i]; 
02AE:  BCF    FD8.0
02B0:  RLCF   x1D,W
02B2:  CLRF   03
02B4:  ADDLW  83
02B6:  MOVWF  FE9
02B8:  MOVLW  01
02BA:  ADDWFC 03,W
02BC:  MOVWF  FEA
02BE:  MOVFF  FEC,03
02C2:  MOVF   FED,F
02C4:  MOVF   FEF,W
02C6:  ADDWF  x1E,F
02C8:  MOVF   03,W
02CA:  ADDWFC x1F,F
02CC:  INCF   x1D,F
02CE:  BRA    02A4
....................        
....................     if(cont==cantM) 
02D0:  MOVLB  1
02D2:  MOVF   x82,W
02D4:  SUBWF  xC8,W
02D6:  BNZ   02DA
....................       cont=0; 
02D8:  CLRF   xC8
....................        
....................     return suma/cantM; 
02DA:  MOVFF  21F,221
02DE:  MOVFF  21E,220
02E2:  MOVLB  2
02E4:  CLRF   x23
02E6:  MOVFF  182,222
02EA:  MOVLB  0
02EC:  BRA    0226
02EE:  MOVFF  02,03
02F2:  MOVFF  02,02
02F6:  BRA    0306
....................   } 
....................   else 
02F8:  BRA    0306
....................     return valor; 
02FA:  MOVFF  21B,01
02FE:  MOVFF  21C,02
0302:  MOVLB  0
0304:  BRA    0306
.................... } 
0306:  GOTO   0322 (RETURN)
....................  
.................... #separate 
.................... void set_PWM_period() 
.................... { 
.................... 	//Resolucion maxima = 10bits 
....................   switch(seleccionPWMf) 
....................   { 
*
4EDC:  MOVLB  1
4EDE:  MOVF   x76,W
4EE0:  XORLW  00
4EE2:  MOVLB  0
4EE4:  BZ    4F08
4EE6:  XORLW  01
4EE8:  BZ    4F14
4EEA:  XORLW  03
4EEC:  BZ    4F20
4EEE:  XORLW  01
4EF0:  BZ    4F2C
4EF2:  XORLW  07
4EF4:  BZ    4F38
4EF6:  XORLW  01
4EF8:  BZ    4F44
4EFA:  XORLW  03
4EFC:  BZ    4F50
4EFE:  XORLW  01
4F00:  BZ    4F5C
4F02:  XORLW  0F
4F04:  BZ    4F68
4F06:  BRA    4F74
....................     case 0: setup_timer_2(T2_DIV_BY_16,255,1); break;   //1.22KHz [0.82ms] Resolucion=14bits 
4F08:  MOVLW  00
4F0A:  IORLW  06
4F0C:  MOVWF  FCA
4F0E:  MOVLW  FF
4F10:  MOVWF  FCB
4F12:  BRA    4F80
....................     case 1: setup_timer_2(T2_DIV_BY_16,127,1); break;   //2.44KHz [0.41ms] Resolucion=13bits 
4F14:  MOVLW  00
4F16:  IORLW  06
4F18:  MOVWF  FCA
4F1A:  MOVLW  7F
4F1C:  MOVWF  FCB
4F1E:  BRA    4F80
....................     case 2: setup_timer_2(T2_DIV_BY_16,63,1); break;  //4.88KHz [0.20ms] Resolucion=12bits 
4F20:  MOVLW  00
4F22:  IORLW  06
4F24:  MOVWF  FCA
4F26:  MOVLW  3F
4F28:  MOVWF  FCB
4F2A:  BRA    4F80
....................     case 3: setup_timer_2(T2_DIV_BY_4,170,1); break;  //7.32KHz [0.14ms] Resolucion=11.42bits 
4F2C:  MOVLW  00
4F2E:  IORLW  05
4F30:  MOVWF  FCA
4F32:  MOVLW  AA
4F34:  MOVWF  FCB
4F36:  BRA    4F80
....................     case 4: setup_timer_2(T2_DIV_BY_4,127,1); break;  //9.76KHz [0.10ms] Resolucion=11bits 
4F38:  MOVLW  00
4F3A:  IORLW  05
4F3C:  MOVWF  FCA
4F3E:  MOVLW  7F
4F40:  MOVWF  FCB
4F42:  BRA    4F80
....................     case 5: setup_timer_2(T2_DIV_BY_4,101,1); break;  //12.20KHz [81.9us] Resolucion=10.67bits 
4F44:  MOVLW  00
4F46:  IORLW  05
4F48:  MOVWF  FCA
4F4A:  MOVLW  65
4F4C:  MOVWF  FCB
4F4E:  BRA    4F80
....................     case 6: setup_timer_2(T2_DIV_BY_4,72,1); break;  //17.08KHz [58.5us] Resolucion=10.19bits 
4F50:  MOVLW  00
4F52:  IORLW  05
4F54:  MOVWF  FCA
4F56:  MOVLW  48
4F58:  MOVWF  FCB
4F5A:  BRA    4F80
....................     case 7: setup_timer_2(T2_DIV_BY_1,255,1); break;  //19.53KHz [51.2us] Resolucion=10bits 
4F5C:  MOVLW  00
4F5E:  IORLW  04
4F60:  MOVWF  FCA
4F62:  MOVLW  FF
4F64:  MOVWF  FCB
4F66:  BRA    4F80
....................     case 8: setup_timer_2(T2_DIV_BY_1,165,1); break;  //30.12KHz [33.2us] Resolucion=9.37bits 
4F68:  MOVLW  00
4F6A:  IORLW  04
4F6C:  MOVWF  FCA
4F6E:  MOVLW  A5
4F70:  MOVWF  FCB
4F72:  BRA    4F80
....................     default: setup_timer_2(T2_DIV_BY_1,255,1); break; //19.53KHz [51.2us] Resolucion=10bits  
4F74:  MOVLW  00
4F76:  IORLW  04
4F78:  MOVWF  FCA
4F7A:  MOVLW  FF
4F7C:  MOVWF  FCB
4F7E:  BRA    4F80
.................... 	//PR2=(Tpwm/(Tclk*4*T2DIV))-1=255 [Tpwm=1/19.53KHz=51.2us, Tclk=1/20MHz=50ns, T2DIV=1]  
....................   } 
.................... } 
4F80:  RETLW  00
....................  
.................... #separate  
.................... void setup() 
.................... { 
.................... //PORTS 
....................   set_tris_a(0x3F);  //0b00111111 
*
3776:  MOVLW  3F
3778:  MOVWF  F92
....................   set_tris_b(0xF1);  //0b11110001  
377A:  MOVLW  F1
377C:  MOVWF  F93
....................   set_tris_c(0x80);  //0b10000000   
377E:  MOVLW  80
3780:  MOVWF  F94
....................   set_tris_d(0x00);  
3782:  MOVLW  00
3784:  MOVWF  F95
....................   set_tris_e(0x01);  //E0 -> AN5 
3786:  MOVLW  01
3788:  MOVWF  F96
.................... //ADC 
....................   setup_adc_ports(AN0_TO_AN5|VSS_VDD); 
378A:  MOVF   FC1,W
378C:  ANDLW  C0
378E:  IORLW  09
3790:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_INTERNAL);  
3792:  BSF    FC0.0
3794:  BSF    FC0.1
3796:  BSF    FC0.2
3798:  BSF    FC0.7
379A:  BSF    FC2.0
.................... //Timer 0                     
....................   setup_timer_0(RTCC_INTERNAL | RTCC_DIV_8); //RTCC and Timer0 are the same 
379C:  MOVLW  82
379E:  MOVWF  FD5
.................... //  set_timer0(tmr0); //para 10ms : TMR0=65536 - overflow_time/(4*Tosc*prescaler)=59286 [en este caso overflow_time=10ms, Tosc=1/20MHz=50ns, prescaler=8] 
....................   //como TMR0=59286 -> overflow_time=(65536-TMR0)*(4*Tosc*prescaler)=(65536-59286)*(4*50ns*8)=10ms 
.................... //  enable_interrupts(INT_TIMER0);  
.................... //Timer 1 
....................   setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);  //104.896 milisegundos maximo 
37A0:  MOVLW  B5
37A2:  MOVWF  FCD
.................... //  set_timer1(tmr1);  //para 100ms : TMR0=65536 - overflow_time/(4*Tosc*prescaler)=3036 [en este caso overflow_time=100ms, Tosc=1/20MHz=50ns, prescaler=8] 
....................   //como TMR1=3036 -> overflow_time=(65536-TMR1)*(4*Tosc*prescaler)=(65536-3036)*(4*50ns*8)=0.1s 
.................... //  enable_interrupts(INT_TIMER1); 
....................  
.................... //INTERRUPTS                       
....................   enable_interrupts(GLOBAL);  //Permite activarse las interrupciones definidas previamente 
37A4:  MOVLW  C0
37A6:  IORWF  FF2,F
.................... 	 
.................... //UART 
....................   enable_interrupts(INT_RDA);  //Rx via puerto serie 
37A8:  BSF    F9D.5
.................... } 
37AA:  GOTO   7234 (RETURN)
....................  
.................... #separate 
.................... void initialize()  
.................... {   
.................... //Inicializando variables 
....................   pid.Integral_1=0; yf_1=0;  
*
4F8A:  CLRF   xF0
4F8C:  CLRF   xEF
4F8E:  CLRF   xEE
4F90:  CLRF   xED
4F92:  MOVLB  1
4F94:  CLRF   x74
4F96:  CLRF   x73
.................... 	fuzzy.u_PI_1=0; fuzzy.error_1=0;  
4F98:  CLRF   x4A
4F9A:  CLRF   x49
4F9C:  CLRF   x48
4F9E:  CLRF   x47
4FA0:  CLRF   x5A
4FA2:  CLRF   x59
4FA4:  CLRF   x58
4FA6:  CLRF   x57
....................   fuzzy.fparam.guniversoPI=FALSE;  
4FA8:  BCF    x1B.0
.................... 	fuzzy.fparam.guniversoPD=FALSE;  
4FAA:  BCF    x1B.1
.................... 	fuzzy.fparam.gstepPD=FALSE; 
4FAC:  BCF    x1B.3
.................... 	fuzzy.fparam.gstepPI=FALSE; 
4FAE:  BCF    x1B.2
.................... 	 
.................... 	modo=automatico; 
4FB0:  BCF    36.1
....................   fuzzy_selected=FALSE; 
4FB2:  BCF    36.2
....................   pid_selected=FALSE; 
4FB4:  BCF    36.3
....................   grf=FALSE;gBR=FALSE;gPWMf=FALSE;gTP=FALSE;  //TP->tipo de procesamiento 
4FB6:  BCF    36.4
4FB8:  BCF    36.5
4FBA:  BCF    36.6
4FBC:  BCF    36.7
....................   fprintPIDini=FALSE;fprintFUZZYini=FALSE;fprintTc=FALSE;fprint = FALSE;  
4FBE:  BCF    x77.0
4FC0:  BCF    x77.1
4FC2:  BCF    x77.2
4FC4:  BCF    x77.3
....................   gk=FALSE; 
4FC6:  BCF    x77.4
....................   gTc=FALSE; //Para guardar en EEPROM 
4FC8:  BCF    x77.5
....................   gcantM=FALSE; 
4FCA:  BCF    x7F.4
....................   fentrada_analogica=FALSE; 
4FCC:  BCF    x7F.5
....................   fFirst_time_pid=FALSE; 
4FCE:  BCF    x7F.6
.................... 	fFirst_time_fuzzy=FALSE; 
4FD0:  BCF    x7F.7
.................... 	gPWMseleccion=FALSE; 
4FD2:  BCF    x77.7
.................... 	gADseleccion=FALSE; 
4FD4:  BCF    x7F.0
.................... 	gTipoAccion=FALSE; 
4FD6:  BCF    x7F.2
.................... 	 
.................... 	fTipoAccion = directa; 
4FD8:  BCF    x7F.1
.................... 	 
.................... 	Tsupervision = 1; 
4FDA:  CLRF   x81
4FDC:  MOVLW  01
4FDE:  MOVWF  x80
.................... 	 
.................... 	ADselected=read_eeprom(address_ADselected); 
4FE0:  MOVFF  FF2,1C9
4FE4:  BCF    FF2.6
4FE6:  BCF    FF2.7
4FE8:  MOVLW  37
4FEA:  MOVWF  FA9
4FEC:  BCF    FA6.6
4FEE:  BCF    FA6.7
4FF0:  BSF    FA6.0
4FF2:  MOVF   FA8,W
4FF4:  BTFSC  xC9.6
4FF6:  BSF    FF2.6
4FF8:  BTFSC  xC9.7
4FFA:  BSF    FF2.7
4FFC:  MOVWF  x7E
.................... 	fPWM1=read_eeprom(address_fPWM1);   
4FFE:  MOVFF  FF2,1C9
5002:  BCF    FF2.6
5004:  BCF    FF2.7
5006:  MOVLW  36
5008:  MOVWF  FA9
500A:  BCF    FA6.6
500C:  BCF    FA6.7
500E:  BSF    FA6.0
5010:  MOVF   FA8,W
5012:  BTFSC  xC9.6
5014:  BSF    FF2.6
5016:  BTFSC  xC9.7
5018:  BSF    FF2.7
501A:  MOVWF  01
501C:  BCF    x77.6
501E:  BTFSC  01.0
5020:  BSF    x77.6
.................... 	 
.................... //Cargando de la EEPROM 
....................   pid.param.Kp=read_float_eeprom(address_Kp);  
5022:  CLRF   xC9
5024:  MOVLB  0
5026:  CALL   37AE
502A:  MOVFF  03,CA
502E:  MOVFF  02,C9
5032:  MOVFF  01,C8
5036:  MOVFF  00,C7
....................   pid.param.Kd=read_float_eeprom(address_Kd);  
503A:  MOVLW  08
503C:  MOVLB  1
503E:  MOVWF  xC9
5040:  MOVLB  0
5042:  CALL   37AE
5046:  MOVFF  03,CE
504A:  MOVFF  02,CD
504E:  MOVFF  01,CC
5052:  MOVFF  00,CB
....................   pid.param.Ki=read_float_eeprom(address_Ki); 
5056:  MOVLW  04
5058:  MOVLB  1
505A:  MOVWF  xC9
505C:  MOVLB  0
505E:  CALL   37AE
5062:  MOVFF  03,D2
5066:  MOVFF  02,D1
506A:  MOVFF  01,D0
506E:  MOVFF  00,CF
....................   pid.param.Tc=read_int16_eeprom(address_Tc); 
5072:  MOVLW  0C
5074:  MOVLB  1
5076:  MOVWF  xC9
5078:  MOVLB  0
507A:  CALL   3810
507E:  MOVFF  02,D4
5082:  MOVFF  01,D3
5086:  CLRF   19
5088:  BTFSC  FF2.6
508A:  BSF    19.6
508C:  BCF    FF2.6
508E:  BTFSC  FF2.7
5090:  BSF    19.7
5092:  BCF    FF2.7
....................  
.................... 	tmr0 = calc_tmr(pid.param.Tc); 
5094:  MOVFF  D4,214
5098:  MOVFF  D3,213
509C:  CALL   3428
50A0:  BTFSC  19.6
50A2:  BSF    FF2.6
50A4:  BTFSC  19.7
50A6:  BSF    FF2.7
50A8:  MOVFF  02,17B
50AC:  MOVFF  01,17A
.................... 	set_timer1(tmr0); 
50B0:  MOVFF  17B,FCF
50B4:  MOVFF  17A,FCE
....................    
....................   rf=read_int16_eeprom(address_rf); 
50B8:  MOVLW  0E
50BA:  MOVLB  1
50BC:  MOVWF  xC9
50BE:  MOVLB  0
50C0:  CALL   3810
50C4:  MOVFF  02,170
50C8:  MOVFF  01,16F
....................   cantM=read_eeprom(address_cantM); 
50CC:  MOVFF  FF2,1C9
50D0:  BCF    FF2.6
50D2:  BCF    FF2.7
50D4:  MOVLW  10
50D6:  MOVWF  FA9
50D8:  BCF    FA6.6
50DA:  BCF    FA6.7
50DC:  BSF    FA6.0
50DE:  MOVF   FA8,W
50E0:  MOVLB  1
50E2:  BTFSC  xC9.6
50E4:  BSF    FF2.6
50E6:  BTFSC  xC9.7
50E8:  BSF    FF2.7
50EA:  MOVWF  x82
.................... 	 
.................... 	fuzzy.fparam.universo_duPI_max=read_int16_eeprom(address_universoPI); 
50EC:  MOVLW  26
50EE:  MOVWF  xC9
50F0:  MOVLB  0
50F2:  CALL   3810
50F6:  MOVFF  02,10C
50FA:  MOVFF  01,10B
.................... 	fuzzy.fparam.universo_duPI_min=fuzzy.fparam.universo_duPI_max * (-1); 
50FE:  MOVFF  10C,1CA
5102:  MOVFF  10B,1C9
5106:  MOVLW  FF
5108:  MOVLB  1
510A:  MOVWF  xCC
510C:  MOVWF  xCB
510E:  MOVLB  0
5110:  CALL   389A
5114:  MOVFF  02,10A
5118:  MOVFF  01,109
.................... 	fuzzy.fparam.universo_uPD_max=read_int16_eeprom(address_universoPD);	 
511C:  MOVLW  24
511E:  MOVLB  1
5120:  MOVWF  xC9
5122:  MOVLB  0
5124:  CALL   3810
5128:  MOVFF  02,110
512C:  MOVFF  01,10F
.................... 	fuzzy.fparam.universo_uPD_min=fuzzy.fparam.universo_uPD_max * (-1);	 
5130:  MOVFF  110,1CA
5134:  MOVFF  10F,1C9
5138:  MOVLW  FF
513A:  MOVLB  1
513C:  MOVWF  xCC
513E:  MOVWF  xCB
5140:  MOVLB  0
5142:  CALL   389A
5146:  MOVFF  02,10E
514A:  MOVFF  01,10D
.................... 	fuzzy.fparam.Kp=read_float_eeprom(address_Kp_Fuzzy);  
514E:  MOVLW  18
5150:  MOVLB  1
5152:  MOVWF  xC9
5154:  MOVLB  0
5156:  CALL   37AE
515A:  MOVFF  03,FC
515E:  MOVFF  02,FB
5162:  MOVFF  01,FA
5166:  MOVFF  00,F9
.................... 	fuzzy.fparam.Ki=read_float_eeprom(address_Ki_Fuzzy); 
516A:  MOVLW  1C
516C:  MOVLB  1
516E:  MOVWF  xC9
5170:  MOVLB  0
5172:  CALL   37AE
5176:  MOVFF  03,104
517A:  MOVFF  02,103
517E:  MOVFF  01,102
5182:  MOVFF  00,101
....................   fuzzy.fparam.Kd=read_float_eeprom(address_Kd_Fuzzy);  
5186:  MOVLW  20
5188:  MOVLB  1
518A:  MOVWF  xC9
518C:  MOVLB  0
518E:  CALL   37AE
5192:  MOVFF  03,100
5196:  MOVFF  02,FF
519A:  MOVFF  01,FE
519E:  MOVFF  00,FD
.................... 	fuzzy.fparam.Kpi=read_float_eeprom(address_Kpi_Fuzzy);  
51A2:  MOVLW  32
51A4:  MOVLB  1
51A6:  MOVWF  xC9
51A8:  MOVLB  0
51AA:  CALL   37AE
51AE:  MOVFF  03,108
51B2:  MOVFF  02,107
51B6:  MOVFF  01,106
51BA:  MOVFF  00,105
.................... 	fuzzy.fparam.Tc=read_int16_eeprom(address_Tc_Fuzzy);  
51BE:  MOVLW  28
51C0:  MOVLB  1
51C2:  MOVWF  xC9
51C4:  MOVLB  0
51C6:  CALL   3810
51CA:  MOVFF  02,11A
51CE:  MOVFF  01,119
.................... 	fuzzy.fparam.stepPD=read_float_eeprom(address_stepPD);  
51D2:  MOVLW  2A
51D4:  MOVLB  1
51D6:  MOVWF  xC9
51D8:  MOVLB  0
51DA:  CALL   37AE
51DE:  MOVFF  03,114
51E2:  MOVFF  02,113
51E6:  MOVFF  01,112
51EA:  MOVFF  00,111
.................... 	fuzzy.fparam.stepPI=read_float_eeprom(address_stepPI); 
51EE:  MOVLW  2E
51F0:  MOVLB  1
51F2:  MOVWF  xC9
51F4:  MOVLB  0
51F6:  CALL   37AE
51FA:  MOVFF  03,118
51FE:  MOVFF  02,117
5202:  MOVFF  01,116
5206:  MOVFF  00,115
520A:  CLRF   19
520C:  BTFSC  FF2.6
520E:  BSF    19.6
5210:  BCF    FF2.6
5212:  BTFSC  FF2.7
5214:  BSF    19.7
5216:  BCF    FF2.7
....................  
.................... 	tmr1 = calc_tmr(fuzzy.fparam.Tc); 
5218:  MOVFF  11A,214
521C:  MOVFF  119,213
5220:  CALL   3428
5224:  BTFSC  19.6
5226:  BSF    FF2.6
5228:  BTFSC  19.7
522A:  BSF    FF2.7
522C:  MOVFF  02,179
5230:  MOVFF  01,178
.................... 	set_timer1(tmr1); 
5234:  MOVFF  179,FCF
5238:  MOVFF  178,FCE
.................... 	 
.................... 	initialize_Fuzzy(); 
523C:  RCALL  4D5A
.................... 	 
.................... 	seleccionBR=read_eeprom(address_BaudRate); 
523E:  MOVFF  FF2,1C9
5242:  BCF    FF2.6
5244:  BCF    FF2.7
5246:  MOVLW  12
5248:  MOVWF  FA9
524A:  BCF    FA6.6
524C:  BCF    FA6.7
524E:  BSF    FA6.0
5250:  MOVF   FA8,W
5252:  MOVLB  1
5254:  BTFSC  xC9.6
5256:  BSF    FF2.6
5258:  BTFSC  xC9.7
525A:  BSF    FF2.7
525C:  MOVWF  x75
....................   switch(seleccionBR) 
....................   { 
525E:  MOVF   x75,W
5260:  XORLW  00
5262:  MOVLB  0
5264:  BZ    5284
5266:  XORLW  01
5268:  BZ    5294
526A:  XORLW  03
526C:  BZ    52A4
526E:  XORLW  01
5270:  BZ    52B4
5272:  XORLW  07
5274:  BZ    52C4
5276:  XORLW  01
5278:  BZ    52D0
527A:  XORLW  03
527C:  BZ    52E0
527E:  XORLW  01
5280:  BZ    52F0
5282:  BRA    5300
....................     case 0: set_uart_speed(9600); break; 
5284:  BSF    FB8.3
5286:  MOVLW  08
5288:  MOVWF  FAF
528A:  MOVLW  02
528C:  MOVWF  FB0
528E:  MOVLW  A6
5290:  MOVWF  FAC
5292:  BRA    5310
....................     case 1: set_uart_speed(1200); break; 
5294:  BSF    FB8.3
5296:  MOVLW  46
5298:  MOVWF  FAF
529A:  MOVLW  10
529C:  MOVWF  FB0
529E:  MOVLW  A6
52A0:  MOVWF  FAC
52A2:  BRA    5310
....................     case 2: set_uart_speed(2400); break; 
52A4:  BSF    FB8.3
52A6:  MOVLW  22
52A8:  MOVWF  FAF
52AA:  MOVLW  08
52AC:  MOVWF  FB0
52AE:  MOVLW  A6
52B0:  MOVWF  FAC
52B2:  BRA    5310
....................     case 3: set_uart_speed(4800); break; 
52B4:  BSF    FB8.3
52B6:  MOVLW  11
52B8:  MOVWF  FAF
52BA:  MOVLW  04
52BC:  MOVWF  FB0
52BE:  MOVLW  A6
52C0:  MOVWF  FAC
52C2:  BRA    5310
....................     case 4: set_uart_speed(19200); break; 
52C4:  BCF    FB8.3
52C6:  MOVLW  40
52C8:  MOVWF  FAF
52CA:  MOVLW  A6
52CC:  MOVWF  FAC
52CE:  BRA    5310
....................     case 5: set_uart_speed(28800); break; 
52D0:  BSF    FB8.3
52D2:  MOVLW  AD
52D4:  MOVWF  FAF
52D6:  MOVLW  00
52D8:  MOVWF  FB0
52DA:  MOVLW  A6
52DC:  MOVWF  FAC
52DE:  BRA    5310
....................     case 6: set_uart_speed(33600); break; 
52E0:  BSF    FB8.3
52E2:  MOVLW  94
52E4:  MOVWF  FAF
52E6:  MOVLW  00
52E8:  MOVWF  FB0
52EA:  MOVLW  A6
52EC:  MOVWF  FAC
52EE:  BRA    5310
....................     case 7: set_uart_speed(38400); break; 
52F0:  BSF    FB8.3
52F2:  MOVLW  81
52F4:  MOVWF  FAF
52F6:  MOVLW  00
52F8:  MOVWF  FB0
52FA:  MOVLW  A6
52FC:  MOVWF  FAC
52FE:  BRA    5310
....................     default: set_uart_speed(9600); break; 
5300:  BSF    FB8.3
5302:  MOVLW  08
5304:  MOVWF  FAF
5306:  MOVLW  02
5308:  MOVWF  FB0
530A:  MOVLW  A6
530C:  MOVWF  FAC
530E:  BRA    5310
....................   } 
.................... 	 
.................... 	//Tipo de procesamiento 
....................   tipo_procesamiento=read_eeprom(address_tipoProcesamiento); 
5310:  MOVFF  FF2,1C9
5314:  BCF    FF2.6
5316:  BCF    FF2.7
5318:  MOVLW  16
531A:  MOVWF  FA9
531C:  BCF    FA6.6
531E:  BCF    FA6.7
5320:  BSF    FA6.0
5322:  MOVF   FA8,W
5324:  MOVLB  1
5326:  BTFSC  xC9.6
5328:  BSF    FF2.6
532A:  BTFSC  xC9.7
532C:  BSF    FF2.7
532E:  MOVWF  xA3
....................   switch(tipo_procesamiento) 
....................   { 
5330:  MOVF   xA3,W
5332:  XORLW  00
5334:  MOVLB  0
5336:  BZ    5346
5338:  XORLW  01
533A:  BZ    534C
533C:  XORLW  03
533E:  BZ    5352
5340:  XORLW  01
5342:  BZ    5358
5344:  BRA    535E
....................     case 0: fcantM=FALSE; break; 
5346:  MOVLB  1
5348:  BCF    x7F.3
534A:  BRA    5364
....................     case 1: fcantM=TRUE; break; 
534C:  MOVLB  1
534E:  BSF    x7F.3
5350:  BRA    5364
....................     case 2: fcantM=FALSE; break; 
5352:  MOVLB  1
5354:  BCF    x7F.3
5356:  BRA    5364
....................     case 3: fcantM=TRUE; break; 
5358:  MOVLB  1
535A:  BSF    x7F.3
535C:  BRA    5364
....................     default: fcantM=TRUE; break; 
535E:  MOVLB  1
5360:  BSF    x7F.3
5362:  BRA    5364
....................   } 
....................        
.................... 	//PWM 
....................   seleccionPWMf=read_eeprom(address_PWMf); 
5364:  MOVFF  FF2,1C9
5368:  BCF    FF2.6
536A:  BCF    FF2.7
536C:  MOVLW  14
536E:  MOVWF  FA9
5370:  BCF    FA6.6
5372:  BCF    FA6.7
5374:  BSF    FA6.0
5376:  MOVF   FA8,W
5378:  BTFSC  xC9.6
537A:  BSF    FF2.6
537C:  BTFSC  xC9.7
537E:  BSF    FF2.7
5380:  MOVWF  x76
....................    
....................   set_PWM_period();	//configurando Timer 2  
5382:  MOVLB  0
5384:  RCALL  4EDC
....................  
....................   setup_ccp1(CCP_PWM);	   
5386:  BCF    F94.2
5388:  BCF    F8B.2
538A:  BCF    F96.6
538C:  MOVLW  0C
538E:  MOVWF  FBD
5390:  CLRF   FB7
5392:  CLRF   FB6
....................   setup_ccp2(CCP_PWM); 
5394:  BCF    F94.1
5396:  BCF    F8B.1
5398:  MOVWF  FBA
.................... 	 
....................   set_pwm1_duty(0); 
539A:  CLRF   FBE
....................   set_pwm2_duty(0);  
539C:  CLRF   FBB
.................... 		 
.................... 		//Inicializando variables temporales 
.................... 		pid.paramTemp.Kp = pid.param.Kp; 
539E:  MOVFF  CA,D8
53A2:  MOVFF  C9,D7
53A6:  MOVFF  C8,D6
53AA:  MOVFF  C7,D5
.................... 		pid.paramTemp.Ki = pid.param.Ki; 
53AE:  MOVFF  D2,E0
53B2:  MOVFF  D1,DF
53B6:  MOVFF  D0,DE
53BA:  MOVFF  CF,DD
.................... 		pid.paramTemp.Kd = pid.param.Kd; 
53BE:  MOVFF  CE,DC
53C2:  MOVFF  CD,DB
53C6:  MOVFF  CC,DA
53CA:  MOVFF  CB,D9
.................... 		pid.paramTemp.Tc = pid.param.Tc; 
53CE:  MOVFF  D4,E2
53D2:  MOVFF  D3,E1
.................... 		tcantM = cantM; 
53D6:  MOVFF  182,1C2
.................... 	 
.................... 		tgk = gk; 
53DA:  MOVLB  1
53DC:  BCF    xC1.0
53DE:  BTFSC  x77.4
53E0:  BSF    xC1.0
.................... 		tgTc = gTc; 
53E2:  BCF    xC1.2
53E4:  BTFSC  x77.5
53E6:  BSF    xC1.2
.................... 		tgcantM = gcantM; 
53E8:  BCF    xC1.1
53EA:  BTFSC  x7F.4
53EC:  BSF    xC1.1
.................... 		 
.................... 		fuzzy.fparamTemp.gstepPD = fuzzy.fparam.gstepPD; 
53EE:  BCF    x3E.3
53F0:  BTFSC  x1B.3
53F2:  BSF    x3E.3
.................... 		fuzzy.fparamTemp.gstepPI = fuzzy.fparam.gstepPI; 
53F4:  BCF    x3E.2
53F6:  BTFSC  x1B.2
53F8:  BSF    x3E.2
.................... 		fuzzy.fparamTemp.guniversoPI = fuzzy.fparam.guniversoPI; 
53FA:  BCF    x3E.0
53FC:  BTFSC  x1B.0
53FE:  BSF    x3E.0
.................... 		fuzzy.fparamTemp.guniversoPD = fuzzy.fparam.guniversoPD; 
5400:  BCF    x3E.1
5402:  BTFSC  x1B.1
5404:  BSF    x3E.1
.................... 	 
.................... 		fuzzy.fparamTemp.Kp = fuzzy.fparam.Kp; 
5406:  MOVFF  FC,11F
540A:  MOVFF  FB,11E
540E:  MOVFF  FA,11D
5412:  MOVFF  F9,11C
.................... 		fuzzy.fparamTemp.Ki = fuzzy.fparam.Ki; 
5416:  MOVFF  104,127
541A:  MOVFF  103,126
541E:  MOVFF  102,125
5422:  MOVFF  101,124
.................... 		fuzzy.fparamTemp.Kd = fuzzy.fparam.Kd; 
5426:  MOVFF  100,123
542A:  MOVFF  FF,122
542E:  MOVFF  FE,121
5432:  MOVFF  FD,120
.................... 		fuzzy.fparamTemp.Kpi = fuzzy.fparam.Kpi; 
5436:  MOVFF  108,12B
543A:  MOVFF  107,12A
543E:  MOVFF  106,129
5442:  MOVFF  105,128
.................... 		fuzzy.fparamTemp.Tc = fuzzy.fparam.Tc; 
5446:  MOVFF  11A,13D
544A:  MOVFF  119,13C
.................... 		fuzzy.fparamTemp.universo_duPI_min = fuzzy.fparam.universo_duPI_min; 
544E:  MOVFF  10A,12D
5452:  MOVFF  109,12C
.................... 		fuzzy.fparamTemp.universo_duPI_max = fuzzy.fparam.universo_duPI_max; 
5456:  MOVFF  10C,12F
545A:  MOVFF  10B,12E
.................... 		fuzzy.fparamTemp.universo_uPD_min = fuzzy.fparam.universo_uPD_min; 
545E:  MOVFF  10E,131
5462:  MOVFF  10D,130
.................... 		fuzzy.fparamTemp.universo_uPD_max = fuzzy.fparam.universo_uPD_max; 
5466:  MOVFF  110,133
546A:  MOVFF  10F,132
.................... 		fuzzy.fparamTemp.stepPD = fuzzy.fparam.stepPD; 
546E:  MOVFF  114,137
5472:  MOVFF  113,136
5476:  MOVFF  112,135
547A:  MOVFF  111,134
.................... 		fuzzy.fparamTemp.stepPI = fuzzy.fparam.stepPI; 
547E:  MOVFF  118,13B
5482:  MOVFF  117,13A
5486:  MOVFF  116,139
548A:  MOVFF  115,138
.................... 			 
.................... //Para iniciar el Software 
....................   putc('!'); 
548E:  MOVLW  21
5490:  MOVLB  0
5492:  RCALL  4F82
.................... } 
5494:  GOTO   7238 (RETURN)
....................  
.................... #separate 
.................... int16 calc_tmr(int16 Tc) 
.................... { 
.................... 	return (65536 - (float)(Tc*10)/(conv_tiempo*1000)); 
*
3428:  MOVFF  214,216
342C:  MOVFF  213,215
3430:  MOVLB  2
3432:  CLRF   x18
3434:  MOVLW  0A
3436:  MOVWF  x17
3438:  MOVLB  0
343A:  RCALL  3406
343C:  MOVFF  02,216
3440:  MOVFF  01,215
3444:  MOVLB  0
3446:  CALL   04D4
344A:  MOVFF  00,215
344E:  MOVFF  01,216
3452:  MOVFF  02,217
3456:  MOVFF  03,218
345A:  MOVFF  03,386
345E:  MOVFF  02,385
3462:  MOVFF  01,384
3466:  MOVFF  00,383
346A:  MOVLW  18
346C:  MOVLB  3
346E:  MOVWF  x8A
3470:  MOVLW  B7
3472:  MOVWF  x89
3474:  MOVLW  51
3476:  MOVWF  x88
3478:  MOVLW  75
347A:  MOVWF  x87
347C:  MOVLB  0
347E:  CALL   0376
3482:  BSF    FD8.1
3484:  MOVLB  3
3486:  CLRF   x86
3488:  CLRF   x85
348A:  CLRF   x84
348C:  MOVLW  8F
348E:  MOVWF  x83
3490:  MOVFF  03,38A
3494:  MOVFF  02,389
3498:  MOVFF  01,388
349C:  MOVFF  00,387
34A0:  MOVLB  0
34A2:  CALL   0600
34A6:  MOVFF  03,21C
34AA:  MOVFF  02,21B
34AE:  MOVFF  01,21A
34B2:  MOVFF  00,219
34B6:  CALL   08F2
34BA:  MOVF   02,W
.................... } 
34BC:  RETLW  00
....................  
.................... #separate  
.................... void initialize_Fuzzy() 
.................... { 
*
4D5A:  CLRF   19
4D5C:  BTFSC  FF2.6
4D5E:  BSF    19.6
4D60:  BCF    FF2.6
4D62:  BTFSC  FF2.7
4D64:  BSF    19.7
4D66:  BCF    FF2.7
.................... 	//A mayor paso mas rapido es el algoritmo pero menos exacto 
.................... 	initialize_PI_Fuzzy(fuzzy.fparam.universo_duPI_min,  //default=-20 
.................... 											fuzzy.fparam.universo_duPI_max,  //default=20 
.................... 											fuzzy.fparam.stepPI);  //default=10											 
4D68:  MOVFF  118,21C
4D6C:  MOVFF  117,21B
4D70:  MOVFF  116,21A
4D74:  MOVFF  115,219
4D78:  CALL   08F2
4D7C:  BTFSC  19.6
4D7E:  BSF    FF2.6
4D80:  BTFSC  19.7
4D82:  BSF    FF2.7
4D84:  MOVFF  02,1CB
4D88:  MOVFF  01,1CA
4D8C:  MOVFF  10A,1CD
4D90:  MOVFF  109,1CC
4D94:  MOVFF  10C,1CF
4D98:  MOVFF  10B,1CE
4D9C:  MOVFF  02,1D1
4DA0:  MOVFF  01,1D0
4DA4:  BRA    487A
4DA6:  CLRF   19
4DA8:  BTFSC  FF2.6
4DAA:  BSF    19.6
4DAC:  BCF    FF2.6
4DAE:  BTFSC  FF2.7
4DB0:  BSF    19.7
4DB2:  BCF    FF2.7
.................... 	initialize_PD_Fuzzy(fuzzy.fparam.universo_uPD_min,  //default=-600 
.................... 											fuzzy.fparam.universo_uPD_max,  //default=600 
.................... 											fuzzy.fparam.stepPD);  //default=300 
4DB4:  MOVFF  114,21C
4DB8:  MOVFF  113,21B
4DBC:  MOVFF  112,21A
4DC0:  MOVFF  111,219
4DC4:  CALL   08F2
4DC8:  BTFSC  19.6
4DCA:  BSF    FF2.6
4DCC:  BTFSC  19.7
4DCE:  BSF    FF2.7
4DD0:  MOVFF  02,1CB
4DD4:  MOVFF  01,1CA
4DD8:  MOVFF  10E,1CD
4DDC:  MOVFF  10D,1CC
4DE0:  MOVFF  110,1CF
4DE4:  MOVFF  10F,1CE
4DE8:  MOVFF  02,1D1
4DEC:  MOVFF  01,1D0
4DF0:  BRA    4AE2
4DF2:  CLRF   19
4DF4:  BTFSC  FF2.6
4DF6:  BSF    19.6
4DF8:  BCF    FF2.6
4DFA:  BTFSC  FF2.7
4DFC:  BSF    19.7
4DFE:  BCF    FF2.7
.................... 												  
.................... 	//Si los valores estan en el rango permisible los parametros no cambiaran 
.................... 	fuzzy.fparam.universo_duPI_min=PI_salida.min; 
4E00:  MOVFF  46,21C
4E04:  MOVFF  45,21B
4E08:  MOVFF  44,21A
4E0C:  MOVFF  43,219
4E10:  CALL   08F2
4E14:  BTFSC  19.6
4E16:  BSF    FF2.6
4E18:  BTFSC  19.7
4E1A:  BSF    FF2.7
4E1C:  MOVFF  02,10A
4E20:  MOVFF  01,109
4E24:  CLRF   19
4E26:  BTFSC  FF2.6
4E28:  BSF    19.6
4E2A:  BCF    FF2.6
4E2C:  BTFSC  FF2.7
4E2E:  BSF    19.7
4E30:  BCF    FF2.7
.................... 	fuzzy.fparam.universo_duPI_max=PI_salida.max; 
4E32:  MOVFF  4A,21C
4E36:  MOVFF  49,21B
4E3A:  MOVFF  48,21A
4E3E:  MOVFF  47,219
4E42:  CALL   08F2
4E46:  BTFSC  19.6
4E48:  BSF    FF2.6
4E4A:  BTFSC  19.7
4E4C:  BSF    FF2.7
4E4E:  MOVFF  02,10C
4E52:  MOVFF  01,10B
.................... 	fuzzy.fparam.stepPI=PI_salida.step;	 
4E56:  MOVFF  4E,118
4E5A:  MOVFF  4D,117
4E5E:  MOVFF  4C,116
4E62:  MOVFF  4B,115
4E66:  CLRF   19
4E68:  BTFSC  FF2.6
4E6A:  BSF    19.6
4E6C:  BCF    FF2.6
4E6E:  BTFSC  FF2.7
4E70:  BSF    19.7
4E72:  BCF    FF2.7
.................... 	fuzzy.fparam.universo_uPD_min=PD_salida.min; 
4E74:  MOVFF  3A,21C
4E78:  MOVFF  39,21B
4E7C:  MOVFF  38,21A
4E80:  MOVFF  37,219
4E84:  CALL   08F2
4E88:  BTFSC  19.6
4E8A:  BSF    FF2.6
4E8C:  BTFSC  19.7
4E8E:  BSF    FF2.7
4E90:  MOVFF  02,10E
4E94:  MOVFF  01,10D
4E98:  CLRF   19
4E9A:  BTFSC  FF2.6
4E9C:  BSF    19.6
4E9E:  BCF    FF2.6
4EA0:  BTFSC  FF2.7
4EA2:  BSF    19.7
4EA4:  BCF    FF2.7
.................... 	fuzzy.fparam.universo_uPD_max=PD_salida.max; 
4EA6:  MOVFF  3E,21C
4EAA:  MOVFF  3D,21B
4EAE:  MOVFF  3C,21A
4EB2:  MOVFF  3B,219
4EB6:  CALL   08F2
4EBA:  BTFSC  19.6
4EBC:  BSF    FF2.6
4EBE:  BTFSC  19.7
4EC0:  BSF    FF2.7
4EC2:  MOVFF  02,110
4EC6:  MOVFF  01,10F
.................... 	fuzzy.fparam.stepPD=PD_salida.step; 
4ECA:  MOVFF  42,114
4ECE:  MOVFF  41,113
4ED2:  MOVFF  40,112
4ED6:  MOVFF  3F,111
.................... } 
4EDA:  RETLW  00
....................  
.................... #separate 
.................... int16 filtro_promedio() 
.................... { 
.................... 	return promedio(ADC_Read(ADselected)); 
*
030A:  MOVFF  17E,219
030E:  RCALL  01F2
0310:  MOVFF  02,21A
0314:  MOVFF  01,219
0318:  MOVFF  02,21C
031C:  MOVFF  01,21B
0320:  BRA    026E
0322:  MOVF   02,W
.................... } 
0324:  RETLW  00
....................  
.................... #separate 
.................... void algoritmo_PID() 
.................... { 
.................... 	yf = filtro_promedio(); 
*
0986:  RCALL  030A
0988:  MOVFF  02,172
098C:  MOVFF  01,171
.................... 	 
.................... 	//Algoritmo PID PROFESIONAL 
.................... 	if(fTipoAccion==directa)			//Accion Directa 
0990:  MOVLB  1
0992:  BTFSC  x7F.1
0994:  BRA    09F6
....................   	pid.en = (float)(rf-yf)/Ry;        
0996:  MOVF   x71,W
0998:  SUBWF  x6F,W
099A:  MOVWF  00
099C:  MOVF   x72,W
099E:  SUBWFB x70,W
09A0:  MOVWF  03
09A2:  MOVFF  00,219
09A6:  MOVLB  2
09A8:  MOVWF  x1A
09AA:  MOVLB  0
09AC:  RCALL  0326
09AE:  MOVFF  00,209
09B2:  MOVFF  01,20A
09B6:  MOVFF  02,20B
09BA:  MOVFF  03,20C
09BE:  MOVFF  03,386
09C2:  MOVFF  02,385
09C6:  MOVFF  01,384
09CA:  MOVFF  00,383
09CE:  MOVLB  3
09D0:  CLRF   x8A
09D2:  MOVLW  C0
09D4:  MOVWF  x89
09D6:  MOVLW  7F
09D8:  MOVWF  x88
09DA:  MOVLW  88
09DC:  MOVWF  x87
09DE:  MOVLB  0
09E0:  RCALL  0376
09E2:  MOVFF  03,E8
09E6:  MOVFF  02,E7
09EA:  MOVFF  01,E6
09EE:  MOVFF  00,E5
....................   else													//Accion Inversa 
09F2:  BRA    0A52
09F4:  MOVLB  1
....................   	pid.en = (float)(yf-rf)/Ry;  
09F6:  MOVF   x6F,W
09F8:  SUBWF  x71,W
09FA:  MOVWF  00
09FC:  MOVF   x70,W
09FE:  SUBWFB x72,W
0A00:  MOVWF  03
0A02:  MOVFF  00,219
0A06:  MOVLB  2
0A08:  MOVWF  x1A
0A0A:  MOVLB  0
0A0C:  RCALL  0326
0A0E:  MOVFF  00,209
0A12:  MOVFF  01,20A
0A16:  MOVFF  02,20B
0A1A:  MOVFF  03,20C
0A1E:  MOVFF  03,386
0A22:  MOVFF  02,385
0A26:  MOVFF  01,384
0A2A:  MOVFF  00,383
0A2E:  MOVLB  3
0A30:  CLRF   x8A
0A32:  MOVLW  C0
0A34:  MOVWF  x89
0A36:  MOVLW  7F
0A38:  MOVWF  x88
0A3A:  MOVLW  88
0A3C:  MOVWF  x87
0A3E:  MOVLB  0
0A40:  RCALL  0376
0A42:  MOVFF  03,E8
0A46:  MOVFF  02,E7
0A4A:  MOVFF  01,E6
0A4E:  MOVFF  00,E5
....................  
....................   if(modo==automatico) 
0A52:  BTFSC  36.1
0A54:  BRA    0CF4
....................   {  
....................     pid.Integral = pid.Integral_1 + pid.param.Tc*0.01*pid.en*pid.param.Ki;  //Ki=Kp/Ti 
0A56:  MOVFF  D4,216
0A5A:  MOVFF  D3,215
0A5E:  RCALL  04D4
0A60:  MOVFF  03,331
0A64:  MOVFF  02,330
0A68:  MOVFF  01,32F
0A6C:  MOVFF  00,32E
0A70:  MOVLW  0A
0A72:  MOVLB  3
0A74:  MOVWF  x35
0A76:  MOVLW  D7
0A78:  MOVWF  x34
0A7A:  MOVLW  23
0A7C:  MOVWF  x33
0A7E:  MOVLW  78
0A80:  MOVWF  x32
0A82:  MOVLB  0
0A84:  RCALL  050A
0A86:  MOVFF  00,209
0A8A:  MOVFF  01,20A
0A8E:  MOVFF  02,20B
0A92:  MOVFF  03,20C
0A96:  MOVFF  03,331
0A9A:  MOVFF  02,330
0A9E:  MOVFF  01,32F
0AA2:  MOVFF  00,32E
0AA6:  MOVFF  E8,335
0AAA:  MOVFF  E7,334
0AAE:  MOVFF  E6,333
0AB2:  MOVFF  E5,332
0AB6:  RCALL  050A
0AB8:  MOVFF  00,209
0ABC:  MOVFF  01,20A
0AC0:  MOVFF  02,20B
0AC4:  MOVFF  03,20C
0AC8:  MOVFF  03,331
0ACC:  MOVFF  02,330
0AD0:  MOVFF  01,32F
0AD4:  MOVFF  00,32E
0AD8:  MOVFF  D2,335
0ADC:  MOVFF  D1,334
0AE0:  MOVFF  D0,333
0AE4:  MOVFF  CF,332
0AE8:  RCALL  050A
0AEA:  BCF    FD8.1
0AEC:  MOVFF  F0,386
0AF0:  MOVFF  EF,385
0AF4:  MOVFF  EE,384
0AF8:  MOVFF  ED,383
0AFC:  MOVFF  03,38A
0B00:  MOVFF  02,389
0B04:  MOVFF  01,388
0B08:  MOVFF  00,387
0B0C:  RCALL  0600
0B0E:  MOVFF  03,EC
0B12:  MOVFF  02,EB
0B16:  MOVFF  01,EA
0B1A:  MOVFF  00,E9
....................     //controlando windup con Int 
....................     if(pid.Integral > 1023)  pid.Integral = 1023;                                                  
0B1E:  MOVLB  3
0B20:  CLRF   x82
0B22:  MOVLW  C0
0B24:  MOVWF  x81
0B26:  MOVLW  7F
0B28:  MOVWF  x80
0B2A:  MOVLW  88
0B2C:  MOVWF  x7F
0B2E:  MOVFF  EC,386
0B32:  MOVFF  EB,385
0B36:  MOVFF  EA,384
0B3A:  MOVFF  E9,383
0B3E:  MOVLB  0
0B40:  RCALL  0878
0B42:  BNC   0B52
0B44:  CLRF   xEC
0B46:  MOVLW  C0
0B48:  MOVWF  xEB
0B4A:  MOVLW  7F
0B4C:  MOVWF  xEA
0B4E:  MOVLW  88
0B50:  MOVWF  xE9
....................       
....................     pid.Derivativo = pid.param.Kd*(yf-yf_1)/(pid.param.Tc*0.01*Ry);  //Kd=Kp*Td 
0B52:  MOVLB  1
0B54:  MOVF   x73,W
0B56:  SUBWF  x71,W
0B58:  MOVWF  00
0B5A:  MOVF   x74,W
0B5C:  SUBWFB x72,W
0B5E:  MOVWF  03
0B60:  MOVFF  00,219
0B64:  MOVLB  2
0B66:  MOVWF  x1A
0B68:  MOVLB  0
0B6A:  CALL   0326
0B6E:  MOVFF  CE,331
0B72:  MOVFF  CD,330
0B76:  MOVFF  CC,32F
0B7A:  MOVFF  CB,32E
0B7E:  MOVFF  03,335
0B82:  MOVFF  02,334
0B86:  MOVFF  01,333
0B8A:  MOVFF  00,332
0B8E:  RCALL  050A
0B90:  MOVFF  00,209
0B94:  MOVFF  01,20A
0B98:  MOVFF  02,20B
0B9C:  MOVFF  03,20C
0BA0:  MOVFF  D4,216
0BA4:  MOVFF  D3,215
0BA8:  RCALL  04D4
0BAA:  MOVFF  03,331
0BAE:  MOVFF  02,330
0BB2:  MOVFF  01,32F
0BB6:  MOVFF  00,32E
0BBA:  MOVLW  0A
0BBC:  MOVLB  3
0BBE:  MOVWF  x35
0BC0:  MOVLW  D7
0BC2:  MOVWF  x34
0BC4:  MOVLW  23
0BC6:  MOVWF  x33
0BC8:  MOVLW  78
0BCA:  MOVWF  x32
0BCC:  MOVLB  0
0BCE:  RCALL  050A
0BD0:  MOVFF  00,20D
0BD4:  MOVFF  01,20E
0BD8:  MOVFF  02,20F
0BDC:  MOVFF  03,210
0BE0:  MOVFF  03,331
0BE4:  MOVFF  02,330
0BE8:  MOVFF  01,32F
0BEC:  MOVFF  00,32E
0BF0:  MOVLB  3
0BF2:  CLRF   x35
0BF4:  MOVLW  C0
0BF6:  MOVWF  x34
0BF8:  MOVLW  7F
0BFA:  MOVWF  x33
0BFC:  MOVLW  88
0BFE:  MOVWF  x32
0C00:  MOVLB  0
0C02:  RCALL  050A
0C04:  MOVFF  20C,386
0C08:  MOVFF  20B,385
0C0C:  MOVFF  20A,384
0C10:  MOVFF  209,383
0C14:  MOVFF  03,38A
0C18:  MOVFF  02,389
0C1C:  MOVFF  01,388
0C20:  MOVFF  00,387
0C24:  CALL   0376
0C28:  MOVFF  03,F4
0C2C:  MOVFF  02,F3
0C30:  MOVFF  01,F2
0C34:  MOVFF  00,F1
....................      
....................     pid.Proporcional = pid.param.Kp*pid.en; 
0C38:  MOVFF  CA,331
0C3C:  MOVFF  C9,330
0C40:  MOVFF  C8,32F
0C44:  MOVFF  C7,32E
0C48:  MOVFF  E8,335
0C4C:  MOVFF  E7,334
0C50:  MOVFF  E6,333
0C54:  MOVFF  E5,332
0C58:  RCALL  050A
0C5A:  MOVFF  03,F8
0C5E:  MOVFF  02,F7
0C62:  MOVFF  01,F6
0C66:  MOVFF  00,F5
....................      
....................     pid.u = pid.Proporcional - pid.Derivativo + pid.Integral; 
0C6A:  BSF    FD8.1
0C6C:  MOVFF  F8,386
0C70:  MOVFF  F7,385
0C74:  MOVFF  F6,384
0C78:  MOVFF  F5,383
0C7C:  MOVFF  F4,38A
0C80:  MOVFF  F3,389
0C84:  MOVFF  F2,388
0C88:  MOVFF  F1,387
0C8C:  RCALL  0600
0C8E:  MOVFF  00,209
0C92:  MOVFF  01,20A
0C96:  MOVFF  02,20B
0C9A:  MOVFF  03,20C
0C9E:  BCF    FD8.1
0CA0:  MOVFF  03,386
0CA4:  MOVFF  02,385
0CA8:  MOVFF  01,384
0CAC:  MOVFF  00,383
0CB0:  MOVFF  EC,38A
0CB4:  MOVFF  EB,389
0CB8:  MOVFF  EA,388
0CBC:  MOVFF  E9,387
0CC0:  RCALL  0600
0CC2:  MOVFF  03,21C
0CC6:  MOVFF  02,21B
0CCA:  MOVFF  01,21A
0CCE:  MOVFF  00,219
0CD2:  RCALL  08F2
0CD4:  MOVFF  02,E4
0CD8:  MOVFF  01,E3
....................        
....................     //Updating 
....................     yf_1=yf; 
0CDC:  MOVFF  172,174
0CE0:  MOVFF  171,173
....................     pid.Integral_1=pid.Integral; 
0CE4:  MOVFF  EC,F0
0CE8:  MOVFF  EB,EF
0CEC:  MOVFF  EA,EE
0CF0:  MOVFF  E9,ED
....................   } 
.................... 	 
....................   //Por precaucion se controla la variable de control en modo automatico 
....................   //En modo manual es obligatorio controlarla 
....................   if(pid.u > 1023) pid.u=1023; 
0CF4:  BTFSC  xE4.7
0CF6:  BRA    0D08
0CF8:  MOVF   xE4,W
0CFA:  SUBLW  03
0CFC:  BC    0D08
0CFE:  MOVLW  03
0D00:  MOVWF  xE4
0D02:  MOVLW  FF
0D04:  MOVWF  xE3
....................   else if(pid.u < 0) pid.u=0; 
0D06:  BRA    0D10
0D08:  BTFSS  xE4.7
0D0A:  BRA    0D10
0D0C:  CLRF   xE4
0D0E:  CLRF   xE3
....................       
....................   //Pasando variable de control a PWM 
....................   set_PWM(pid.u); 
0D10:  MOVFF  E4,21A
0D14:  MOVFF  E3,219
0D18:  RCALL  092E
.................... } 
0D1A:  GOTO   0D48 (RETURN)
....................  
.................... #separate 
.................... void algoritmo_Fuzzy() 
.................... { 
.................... 	float T1temp; 
.................... 	int16 utemp; 
.................... 	 
.................... 	yf = filtro_promedio(); 
*
2EAE:  CALL   030A
2EB2:  MOVFF  02,172
2EB6:  MOVFF  01,171
.................... 	 
.................... 	if(fTipoAccion==directa)	//Accion Directa 
2EBA:  MOVLB  1
2EBC:  BTFSC  x7F.1
2EBE:  BRA    2EEE
.................... 		fuzzy.error = rf - yf; 
2EC0:  MOVF   x71,W
2EC2:  SUBWF  x6F,W
2EC4:  MOVWF  00
2EC6:  MOVF   x72,W
2EC8:  SUBWFB x70,W
2ECA:  MOVWF  03
2ECC:  MOVFF  00,219
2ED0:  MOVLB  2
2ED2:  MOVWF  x1A
2ED4:  MOVLB  0
2ED6:  CALL   0326
2EDA:  MOVFF  03,156
2EDE:  MOVFF  02,155
2EE2:  MOVFF  01,154
2EE6:  MOVFF  00,153
.................... 	else											//Accion Inversa 
2EEA:  BRA    2F18
2EEC:  MOVLB  1
.................... 		fuzzy.error = yf - rf; 
2EEE:  MOVF   x6F,W
2EF0:  SUBWF  x71,W
2EF2:  MOVWF  00
2EF4:  MOVF   x70,W
2EF6:  SUBWFB x72,W
2EF8:  MOVWF  03
2EFA:  MOVFF  00,219
2EFE:  MOVLB  2
2F00:  MOVWF  x1A
2F02:  MOVLB  0
2F04:  CALL   0326
2F08:  MOVFF  03,156
2F0C:  MOVFF  02,155
2F10:  MOVFF  01,154
2F14:  MOVFF  00,153
.................... 	 
.................... 	fuzzy.derror = fabs(fuzzy.error) - fabs(fuzzy.error_1); 
2F18:  MOVFF  154,01
2F1C:  BCF    01.7
2F1E:  MOVFF  153,219
2F22:  MOVFF  01,21A
2F26:  MOVFF  155,21B
2F2A:  MOVFF  156,21C
2F2E:  MOVFF  157,00
2F32:  MOVFF  158,01
2F36:  MOVFF  159,02
2F3A:  MOVFF  15A,03
2F3E:  BCF    01.7
2F40:  BSF    FD8.1
2F42:  MOVFF  156,386
2F46:  MOVFF  155,385
2F4A:  MOVFF  21A,384
2F4E:  MOVFF  153,383
2F52:  MOVFF  15A,38A
2F56:  MOVFF  159,389
2F5A:  MOVFF  01,388
2F5E:  MOVFF  157,387
2F62:  CALL   0600
2F66:  MOVFF  03,15E
2F6A:  MOVFF  02,15D
2F6E:  MOVFF  01,15C
2F72:  MOVFF  00,15B
....................        
.................... 	if(modo==automatico) 
2F76:  BTFSC  36.1
2F78:  BRA    3372
.................... 	{		 
.................... 		T1temp = fuzzy.error * fuzzy.fparam.Kp; 
2F7A:  MOVFF  156,331
2F7E:  MOVFF  155,330
2F82:  MOVFF  154,32F
2F86:  MOVFF  153,32E
2F8A:  MOVFF  FC,335
2F8E:  MOVFF  FB,334
2F92:  MOVFF  FA,333
2F96:  MOVFF  F9,332
2F9A:  CALL   050A
2F9E:  MOVFF  03,216
2FA2:  MOVFF  02,215
2FA6:  MOVFF  01,214
2FAA:  MOVFF  00,213
.................... 		fuzzy.e_P = (T1temp > 1023 ? 1023 : (T1temp < -1023 ? -1023 : T1temp)); 
2FAE:  MOVLB  3
2FB0:  CLRF   x82
2FB2:  MOVLW  C0
2FB4:  MOVWF  x81
2FB6:  MOVLW  7F
2FB8:  MOVWF  x80
2FBA:  MOVLW  88
2FBC:  MOVWF  x7F
2FBE:  MOVFF  216,386
2FC2:  MOVFF  215,385
2FC6:  MOVFF  214,384
2FCA:  MOVFF  213,383
2FCE:  MOVLB  0
2FD0:  CALL   0878
2FD4:  BNC   2FE6
2FD6:  MOVLW  88
2FD8:  MOVWF  00
2FDA:  MOVLW  7F
2FDC:  MOVWF  01
2FDE:  MOVLW  C0
2FE0:  MOVWF  02
2FE2:  CLRF   03
2FE4:  BRA    302E
2FE6:  MOVFF  216,382
2FEA:  MOVFF  215,381
2FEE:  MOVFF  214,380
2FF2:  MOVFF  213,37F
2FF6:  MOVLB  3
2FF8:  CLRF   x86
2FFA:  MOVLW  C0
2FFC:  MOVWF  x85
2FFE:  MOVLW  FF
3000:  MOVWF  x84
3002:  MOVLW  88
3004:  MOVWF  x83
3006:  MOVLB  0
3008:  CALL   0878
300C:  BNC   301E
300E:  MOVLW  88
3010:  MOVWF  00
3012:  MOVLW  FF
3014:  MOVWF  01
3016:  MOVLW  C0
3018:  MOVWF  02
301A:  CLRF   03
301C:  BRA    302E
301E:  MOVFF  213,00
3022:  MOVFF  214,01
3026:  MOVFF  215,02
302A:  MOVFF  216,03
302E:  MOVFF  03,162
3032:  MOVFF  02,161
3036:  MOVFF  01,160
303A:  MOVFF  00,15F
.................... 			 
.................... 		T1temp = fuzzy.derror * fuzzy.fparam.Kd; 
303E:  MOVFF  15E,331
3042:  MOVFF  15D,330
3046:  MOVFF  15C,32F
304A:  MOVFF  15B,32E
304E:  MOVFF  100,335
3052:  MOVFF  FF,334
3056:  MOVFF  FE,333
305A:  MOVFF  FD,332
305E:  CALL   050A
3062:  MOVFF  03,216
3066:  MOVFF  02,215
306A:  MOVFF  01,214
306E:  MOVFF  00,213
.................... 		fuzzy.de_D = (T1temp > 1023 ? 1023 : (T1temp < -1023 ? -1023 : T1temp)); 
3072:  MOVLB  3
3074:  CLRF   x82
3076:  MOVLW  C0
3078:  MOVWF  x81
307A:  MOVLW  7F
307C:  MOVWF  x80
307E:  MOVLW  88
3080:  MOVWF  x7F
3082:  MOVFF  216,386
3086:  MOVFF  215,385
308A:  MOVFF  214,384
308E:  MOVFF  213,383
3092:  MOVLB  0
3094:  CALL   0878
3098:  BNC   30AA
309A:  MOVLW  88
309C:  MOVWF  00
309E:  MOVLW  7F
30A0:  MOVWF  01
30A2:  MOVLW  C0
30A4:  MOVWF  02
30A6:  CLRF   03
30A8:  BRA    30F2
30AA:  MOVFF  216,382
30AE:  MOVFF  215,381
30B2:  MOVFF  214,380
30B6:  MOVFF  213,37F
30BA:  MOVLB  3
30BC:  CLRF   x86
30BE:  MOVLW  C0
30C0:  MOVWF  x85
30C2:  MOVLW  FF
30C4:  MOVWF  x84
30C6:  MOVLW  88
30C8:  MOVWF  x83
30CA:  MOVLB  0
30CC:  CALL   0878
30D0:  BNC   30E2
30D2:  MOVLW  88
30D4:  MOVWF  00
30D6:  MOVLW  FF
30D8:  MOVWF  01
30DA:  MOVLW  C0
30DC:  MOVWF  02
30DE:  CLRF   03
30E0:  BRA    30F2
30E2:  MOVFF  213,00
30E6:  MOVFF  214,01
30EA:  MOVFF  215,02
30EE:  MOVFF  216,03
30F2:  MOVFF  03,166
30F6:  MOVFF  02,165
30FA:  MOVFF  01,164
30FE:  MOVFF  00,163
....................        
.................... 		T1temp = fuzzy.error * fuzzy.fparam.Ki; 
3102:  MOVFF  156,331
3106:  MOVFF  155,330
310A:  MOVFF  154,32F
310E:  MOVFF  153,32E
3112:  MOVFF  104,335
3116:  MOVFF  103,334
311A:  MOVFF  102,333
311E:  MOVFF  101,332
3122:  CALL   050A
3126:  MOVFF  03,216
312A:  MOVFF  02,215
312E:  MOVFF  01,214
3132:  MOVFF  00,213
.................... 		fuzzy.e_I = (T1temp > 1023 ? 1023 : (T1temp < -1023 ? -1023 : T1temp)); 
3136:  MOVLB  3
3138:  CLRF   x82
313A:  MOVLW  C0
313C:  MOVWF  x81
313E:  MOVLW  7F
3140:  MOVWF  x80
3142:  MOVLW  88
3144:  MOVWF  x7F
3146:  MOVFF  216,386
314A:  MOVFF  215,385
314E:  MOVFF  214,384
3152:  MOVFF  213,383
3156:  MOVLB  0
3158:  CALL   0878
315C:  BNC   316E
315E:  MOVLW  88
3160:  MOVWF  00
3162:  MOVLW  7F
3164:  MOVWF  01
3166:  MOVLW  C0
3168:  MOVWF  02
316A:  CLRF   03
316C:  BRA    31B6
316E:  MOVFF  216,382
3172:  MOVFF  215,381
3176:  MOVFF  214,380
317A:  MOVFF  213,37F
317E:  MOVLB  3
3180:  CLRF   x86
3182:  MOVLW  C0
3184:  MOVWF  x85
3186:  MOVLW  FF
3188:  MOVWF  x84
318A:  MOVLW  88
318C:  MOVWF  x83
318E:  MOVLB  0
3190:  CALL   0878
3194:  BNC   31A6
3196:  MOVLW  88
3198:  MOVWF  00
319A:  MOVLW  FF
319C:  MOVWF  01
319E:  MOVLW  C0
31A0:  MOVWF  02
31A2:  CLRF   03
31A4:  BRA    31B6
31A6:  MOVFF  213,00
31AA:  MOVFF  214,01
31AE:  MOVFF  215,02
31B2:  MOVFF  216,03
31B6:  MOVFF  03,16A
31BA:  MOVFF  02,169
31BE:  MOVFF  01,168
31C2:  MOVFF  00,167
.................... 			 
.................... 		T1temp = fuzzy.derror * fuzzy.fparam.Kpi; 
31C6:  MOVFF  15E,331
31CA:  MOVFF  15D,330
31CE:  MOVFF  15C,32F
31D2:  MOVFF  15B,32E
31D6:  MOVFF  108,335
31DA:  MOVFF  107,334
31DE:  MOVFF  106,333
31E2:  MOVFF  105,332
31E6:  CALL   050A
31EA:  MOVFF  03,216
31EE:  MOVFF  02,215
31F2:  MOVFF  01,214
31F6:  MOVFF  00,213
.................... 		fuzzy.de_P = (T1temp > 1023 ? 1023 : (T1temp < -1023 ? -1023 : T1temp)); 
31FA:  MOVLB  3
31FC:  CLRF   x82
31FE:  MOVLW  C0
3200:  MOVWF  x81
3202:  MOVLW  7F
3204:  MOVWF  x80
3206:  MOVLW  88
3208:  MOVWF  x7F
320A:  MOVFF  216,386
320E:  MOVFF  215,385
3212:  MOVFF  214,384
3216:  MOVFF  213,383
321A:  MOVLB  0
321C:  CALL   0878
3220:  BNC   3232
3222:  MOVLW  88
3224:  MOVWF  00
3226:  MOVLW  7F
3228:  MOVWF  01
322A:  MOVLW  C0
322C:  MOVWF  02
322E:  CLRF   03
3230:  BRA    327A
3232:  MOVFF  216,382
3236:  MOVFF  215,381
323A:  MOVFF  214,380
323E:  MOVFF  213,37F
3242:  MOVLB  3
3244:  CLRF   x86
3246:  MOVLW  C0
3248:  MOVWF  x85
324A:  MOVLW  FF
324C:  MOVWF  x84
324E:  MOVLW  88
3250:  MOVWF  x83
3252:  MOVLB  0
3254:  CALL   0878
3258:  BNC   326A
325A:  MOVLW  88
325C:  MOVWF  00
325E:  MOVLW  FF
3260:  MOVWF  01
3262:  MOVLW  C0
3264:  MOVWF  02
3266:  CLRF   03
3268:  BRA    327A
326A:  MOVFF  213,00
326E:  MOVFF  214,01
3272:  MOVFF  215,02
3276:  MOVFF  216,03
327A:  MOVFF  03,16E
327E:  MOVFF  02,16D
3282:  MOVFF  01,16C
3286:  MOVFF  00,16B
....................  
.................... 		//Algoritmo Fuzzy 
.................... 		PDInferenceEngine(fuzzy.e_P, fuzzy.de_D, &fuzzy.u_PD); 
328A:  MOVFF  162,21C
328E:  MOVFF  161,21B
3292:  MOVFF  160,21A
3296:  MOVFF  15F,219
329A:  MOVFF  166,220
329E:  MOVFF  165,21F
32A2:  MOVFF  164,21E
32A6:  MOVFF  163,21D
32AA:  MOVLW  01
32AC:  MOVLB  2
32AE:  MOVWF  x22
32B0:  MOVLW  4B
32B2:  MOVWF  x21
32B4:  MOVLB  0
32B6:  BRA    2D8E
.................... 	  PIInferenceEngine(fuzzy.e_I, fuzzy.de_P, &fuzzy.du_PI); 
32B8:  MOVFF  16A,21C
32BC:  MOVFF  169,21B
32C0:  MOVFF  168,21A
32C4:  MOVFF  167,219
32C8:  MOVFF  16E,220
32CC:  MOVFF  16D,21F
32D0:  MOVFF  16C,21E
32D4:  MOVFF  16B,21D
32D8:  MOVLW  01
32DA:  MOVLB  2
32DC:  MOVWF  x22
32DE:  MOVLW  43
32E0:  MOVWF  x21
32E2:  MOVLB  0
32E4:  BRA    2E5E
....................        
.................... 		fuzzy.u_PI = fuzzy.du_PI + fuzzy.u_PI_1; 
32E6:  BCF    FD8.1
32E8:  MOVFF  146,386
32EC:  MOVFF  145,385
32F0:  MOVFF  144,384
32F4:  MOVFF  143,383
32F8:  MOVFF  14A,38A
32FC:  MOVFF  149,389
3300:  MOVFF  148,388
3304:  MOVFF  147,387
3308:  CALL   0600
330C:  MOVFF  03,142
3310:  MOVFF  02,141
3314:  MOVFF  01,140
3318:  MOVFF  00,13F
....................        
.................... 		fuzzy.u = fuzzy.u_PD + fuzzy.u_PI; 
331C:  BCF    FD8.1
331E:  MOVFF  14E,386
3322:  MOVFF  14D,385
3326:  MOVFF  14C,384
332A:  MOVFF  14B,383
332E:  MOVFF  142,38A
3332:  MOVFF  141,389
3336:  MOVFF  140,388
333A:  MOVFF  13F,387
333E:  CALL   0600
3342:  MOVFF  03,152
3346:  MOVFF  02,151
334A:  MOVFF  01,150
334E:  MOVFF  00,14F
....................  
.................... 		//Updating 
.................... 		fuzzy.error_1 = fuzzy.error; 
3352:  MOVFF  156,15A
3356:  MOVFF  155,159
335A:  MOVFF  154,158
335E:  MOVFF  153,157
.................... 		fuzzy.u_PI_1 = fuzzy.u_PI; 
3362:  MOVFF  142,14A
3366:  MOVFF  141,149
336A:  MOVFF  140,148
336E:  MOVFF  13F,147
....................   } 
.................... 		 
.................... 	if(fuzzy.u<0) fuzzy.u=0; 
3372:  MOVFF  152,382
3376:  MOVFF  151,381
337A:  MOVFF  150,380
337E:  MOVFF  14F,37F
3382:  MOVLB  3
3384:  CLRF   x86
3386:  CLRF   x85
3388:  CLRF   x84
338A:  CLRF   x83
338C:  MOVLB  0
338E:  CALL   0878
3392:  BNC   33A0
3394:  MOVLB  1
3396:  CLRF   x52
3398:  CLRF   x51
339A:  CLRF   x50
339C:  CLRF   x4F
.................... 	else if(fuzzy.u>1023) fuzzy.u=1023; 
339E:  BRA    33D8
33A0:  MOVLB  3
33A2:  CLRF   x82
33A4:  MOVLW  C0
33A6:  MOVWF  x81
33A8:  MOVLW  7F
33AA:  MOVWF  x80
33AC:  MOVLW  88
33AE:  MOVWF  x7F
33B0:  MOVFF  152,386
33B4:  MOVFF  151,385
33B8:  MOVFF  150,384
33BC:  MOVFF  14F,383
33C0:  MOVLB  0
33C2:  CALL   0878
33C6:  BNC   33DA
33C8:  MOVLB  1
33CA:  CLRF   x52
33CC:  MOVLW  C0
33CE:  MOVWF  x51
33D0:  MOVLW  7F
33D2:  MOVWF  x50
33D4:  MOVLW  88
33D6:  MOVWF  x4F
33D8:  MOVLB  0
.................... 	//Pasando variable de control a PWM 
.................... 	 
.................... 	utemp = (int16)fuzzy.u; 
33DA:  MOVFF  152,21C
33DE:  MOVFF  151,21B
33E2:  MOVFF  150,21A
33E6:  MOVFF  14F,219
33EA:  CALL   08F2
33EE:  MOVFF  02,218
33F2:  MOVFF  01,217
.................... 	set_PWM(utemp); 
33F6:  MOVFF  218,21A
33FA:  MOVFF  217,219
33FE:  CALL   092E
.................... } 
3402:  GOTO   352A (RETURN)
....................  
.................... #separate 
.................... void set_PWM(int16 pwm) 
.................... { 
.................... 	if(fPWM1) set_pwm1_duty(pwm); 
*
092E:  MOVLB  1
0930:  BTFSS  x77.6
0932:  BRA    095C
0934:  MOVFF  21A,02
0938:  MOVFF  219,01
093C:  RRCF   02,F
093E:  RRCF   01,F
0940:  RRCF   02,F
0942:  RRCF   01,F
0944:  RRCF   02,F
0946:  MOVFF  01,FBE
094A:  RRCF   02,F
094C:  RRCF   02,W
094E:  ANDLW  30
0950:  MOVWF  00
0952:  MOVF   FBD,W
0954:  ANDLW  CF
0956:  IORWF  00,W
0958:  MOVWF  FBD
.................... 	else set_pwm2_duty(pwm); 
095A:  BRA    0982
095C:  MOVFF  21A,02
0960:  MOVFF  219,01
0964:  RRCF   02,F
0966:  RRCF   01,F
0968:  RRCF   02,F
096A:  RRCF   01,F
096C:  RRCF   02,F
096E:  MOVFF  01,FBB
0972:  RRCF   02,F
0974:  RRCF   02,W
0976:  ANDLW  30
0978:  MOVWF  00
097A:  MOVF   FBA,W
097C:  ANDLW  CF
097E:  IORWF  00,W
0980:  MOVWF  FBA
.................... } 
0982:  MOVLB  0
0984:  RETLW  00
....................  
.................... #separate 
.................... void enable_timer0(BOOLEAN ON) 
.................... { 
.................... 	if(ON) 
*
59AC:  MOVLB  1
59AE:  MOVF   xCA,F
59B0:  BZ    59CA
.................... 	{ 
.................... 		set_timer0(tmr0); 
59B2:  MOVFF  17B,FD7
59B6:  MOVFF  17A,FD6
.................... 		enable_interrupts(INT_TIMER0); 
59BA:  BSF    FF2.5
.................... 		disable_interrupts(INT_TIMER1);	 
59BC:  BCF    F9D.0
.................... 		count_timer=9;	  //1 segundo (99) 
59BE:  CLRF   x7D
59C0:  MOVLW  09
59C2:  MOVWF  x7C
.................... 		Tsupervision=9; 
59C4:  CLRF   x81
59C6:  MOVWF  x80
.................... 	} 
.................... 	else 
59C8:  BRA    59CC
.................... 		disable_interrupts(INT_TIMER0); 
59CA:  BCF    FF2.5
.................... } 
59CC:  MOVLB  0
59CE:  RETLW  00
....................  
.................... #separate 
.................... void enable_timer1(BOOLEAN ON) 
.................... { 
.................... 	if(ON) 
*
34BE:  MOVLB  2
34C0:  MOVF   x13,F
34C2:  BZ    34E0
.................... 	{ 
.................... 		set_timer1(tmr1); 
34C4:  MOVFF  179,FCF
34C8:  MOVFF  178,FCE
.................... 		enable_interrupts(INT_TIMER1); 
34CC:  BSF    F9D.0
.................... 		disable_interrupts(INT_TIMER0);	 
34CE:  BCF    FF2.5
.................... 		count_timer=2;	//+-1 segundo (9) 
34D0:  MOVLB  1
34D2:  CLRF   x7D
34D4:  MOVLW  02
34D6:  MOVWF  x7C
.................... 		Tsupervision=2; 
34D8:  CLRF   x81
34DA:  MOVWF  x80
.................... 	} 
.................... 	else 
34DC:  BRA    34E4
34DE:  MOVLB  2
.................... 		disable_interrupts(INT_TIMER1); 
34E0:  BCF    F9D.0
34E2:  MOVLB  1
.................... } 
34E4:  MOVLB  0
34E6:  RETLW  00
....................  
.................... #separate  
.................... void printRS232() 
.................... {		 
.................... 		if(fprintPIDini) 
*
59D0:  MOVLB  1
59D2:  BTFSS  x77.0
59D4:  BRA    5ABE
.................... 		{ 
.................... 			putc('@');  
59D6:  MOVLW  40
59D8:  MOVLB  0
59DA:  CALL   4F82
.................... 			printf("%01d,%04Ld,%4.3f,%4.3f,%4.3f,%02d,%03Lu,\r", 
.................... 						tipo_procesamiento,rf, 
.................... 						pid.param.Kp,pid.param.Ki,pid.param.Kd,cantM,pid.param.Tc); 
59DE:  MOVFF  1A3,1CB
59E2:  MOVLW  08
59E4:  MOVLB  1
59E6:  MOVWF  xCC
59E8:  MOVLB  0
59EA:  RCALL  54C4
59EC:  MOVLW  2C
59EE:  BTFSS  F9E.4
59F0:  BRA    59EE
59F2:  MOVWF  FAD
59F4:  MOVLW  0A
59F6:  MOVWF  FE9
59F8:  MOVFF  170,1CC
59FC:  MOVFF  16F,1CB
5A00:  RCALL  55A0
5A02:  MOVLW  2C
5A04:  BTFSS  F9E.4
5A06:  BRA    5A04
5A08:  MOVWF  FAD
5A0A:  MOVLW  03
5A0C:  MOVWF  FE9
5A0E:  MOVFF  CA,1CC
5A12:  MOVFF  C9,1CB
5A16:  MOVFF  C8,1CA
5A1A:  MOVFF  C7,1C9
5A1E:  MOVLB  1
5A20:  MOVWF  xCD
5A22:  MOVLB  0
5A24:  RCALL  5746
5A26:  MOVLW  2C
5A28:  BTFSS  F9E.4
5A2A:  BRA    5A28
5A2C:  MOVWF  FAD
5A2E:  MOVLW  03
5A30:  MOVWF  FE9
5A32:  MOVFF  D2,1CC
5A36:  MOVFF  D1,1CB
5A3A:  MOVFF  D0,1CA
5A3E:  MOVFF  CF,1C9
5A42:  MOVLB  1
5A44:  MOVWF  xCD
5A46:  MOVLB  0
5A48:  RCALL  5746
5A4A:  MOVLW  2C
5A4C:  BTFSS  F9E.4
5A4E:  BRA    5A4C
5A50:  MOVWF  FAD
5A52:  MOVLW  03
5A54:  MOVWF  FE9
5A56:  MOVFF  CE,1CC
5A5A:  MOVFF  CD,1CB
5A5E:  MOVFF  CC,1CA
5A62:  MOVFF  CB,1C9
5A66:  MOVLB  1
5A68:  MOVWF  xCD
5A6A:  MOVLB  0
5A6C:  RCALL  5746
5A6E:  MOVLW  2C
5A70:  BTFSS  F9E.4
5A72:  BRA    5A70
5A74:  MOVWF  FAD
5A76:  MOVFF  182,1CB
5A7A:  MOVLW  01
5A7C:  MOVLB  1
5A7E:  MOVWF  xCC
5A80:  MOVLB  0
5A82:  RCALL  54C4
5A84:  MOVLW  2C
5A86:  BTFSS  F9E.4
5A88:  BRA    5A86
5A8A:  MOVWF  FAD
5A8C:  MOVLW  0A
5A8E:  MOVWF  FE9
5A90:  MOVFF  D4,1CA
5A94:  MOVFF  D3,1C9
5A98:  RCALL  5902
5A9A:  MOVLW  2C
5A9C:  BTFSS  F9E.4
5A9E:  BRA    5A9C
5AA0:  MOVWF  FAD
5AA2:  MOVLW  0D
5AA4:  BTFSS  F9E.4
5AA6:  BRA    5AA4
5AA8:  MOVWF  FAD
.................... 			fprintPIDini=FALSE; 
5AAA:  MOVLB  1
5AAC:  BCF    x77.0
.................... 			enable_timer0(TRUE); 
5AAE:  MOVLW  01
5AB0:  MOVWF  xCA
5AB2:  MOVLB  0
5AB4:  RCALL  59AC
.................... 			putc('<'); 
5AB6:  MOVLW  3C
5AB8:  CALL   4F82
5ABC:  MOVLB  1
.................... 		} 
.................... 		 
.................... 		if(fprintFUZZYini) 
5ABE:  BTFSS  x77.1
5AC0:  BRA    5C60
.................... 		{ 
.................... 			putc('@');  
5AC2:  MOVLW  40
5AC4:  MOVLB  0
5AC6:  CALL   4F82
.................... 			printf("%01d,%04Ld,%4.3f,%4.3f,%4.3f,%02d,%03Lu,%04Ld,%04Ld,%3.3f,%3.3f,%4.3f,\r", 
.................... 						tipo_procesamiento,rf, 
.................... 						fuzzy.fparam.Kp,fuzzy.fparam.Ki,fuzzy.fparam.Kd,cantM,fuzzy.fparam.Tc, 
.................... 						fuzzy.fparam.universo_duPI_max,fuzzy.fparam.universo_uPD_max, 
.................... 						fuzzy.fparam.stepPD,fuzzy.fparam.stepPI,fuzzy.fparam.Kpi); 
5ACA:  MOVFF  1A3,1CB
5ACE:  MOVLW  08
5AD0:  MOVLB  1
5AD2:  MOVWF  xCC
5AD4:  MOVLB  0
5AD6:  RCALL  54C4
5AD8:  MOVLW  2C
5ADA:  BTFSS  F9E.4
5ADC:  BRA    5ADA
5ADE:  MOVWF  FAD
5AE0:  MOVLW  0A
5AE2:  MOVWF  FE9
5AE4:  MOVFF  170,1CC
5AE8:  MOVFF  16F,1CB
5AEC:  RCALL  55A0
5AEE:  MOVLW  2C
5AF0:  BTFSS  F9E.4
5AF2:  BRA    5AF0
5AF4:  MOVWF  FAD
5AF6:  MOVLW  03
5AF8:  MOVWF  FE9
5AFA:  MOVFF  FC,1CC
5AFE:  MOVFF  FB,1CB
5B02:  MOVFF  FA,1CA
5B06:  MOVFF  F9,1C9
5B0A:  MOVLB  1
5B0C:  MOVWF  xCD
5B0E:  MOVLB  0
5B10:  RCALL  5746
5B12:  MOVLW  2C
5B14:  BTFSS  F9E.4
5B16:  BRA    5B14
5B18:  MOVWF  FAD
5B1A:  MOVLW  03
5B1C:  MOVWF  FE9
5B1E:  MOVFF  104,1CC
5B22:  MOVFF  103,1CB
5B26:  MOVFF  102,1CA
5B2A:  MOVFF  101,1C9
5B2E:  MOVLB  1
5B30:  MOVWF  xCD
5B32:  MOVLB  0
5B34:  RCALL  5746
5B36:  MOVLW  2C
5B38:  BTFSS  F9E.4
5B3A:  BRA    5B38
5B3C:  MOVWF  FAD
5B3E:  MOVLW  03
5B40:  MOVWF  FE9
5B42:  MOVFF  100,1CC
5B46:  MOVFF  FF,1CB
5B4A:  MOVFF  FE,1CA
5B4E:  MOVFF  FD,1C9
5B52:  MOVLB  1
5B54:  MOVWF  xCD
5B56:  MOVLB  0
5B58:  RCALL  5746
5B5A:  MOVLW  2C
5B5C:  BTFSS  F9E.4
5B5E:  BRA    5B5C
5B60:  MOVWF  FAD
5B62:  MOVFF  182,1CB
5B66:  MOVLW  01
5B68:  MOVLB  1
5B6A:  MOVWF  xCC
5B6C:  MOVLB  0
5B6E:  RCALL  54C4
5B70:  MOVLW  2C
5B72:  BTFSS  F9E.4
5B74:  BRA    5B72
5B76:  MOVWF  FAD
5B78:  MOVLW  0A
5B7A:  MOVWF  FE9
5B7C:  MOVFF  11A,1CA
5B80:  MOVFF  119,1C9
5B84:  RCALL  5902
5B86:  MOVLW  2C
5B88:  BTFSS  F9E.4
5B8A:  BRA    5B88
5B8C:  MOVWF  FAD
5B8E:  MOVLW  0A
5B90:  MOVWF  FE9
5B92:  MOVFF  10C,1CC
5B96:  MOVFF  10B,1CB
5B9A:  RCALL  55A0
5B9C:  MOVLW  2C
5B9E:  BTFSS  F9E.4
5BA0:  BRA    5B9E
5BA2:  MOVWF  FAD
5BA4:  MOVLW  0A
5BA6:  MOVWF  FE9
5BA8:  MOVFF  110,1CC
5BAC:  MOVFF  10F,1CB
5BB0:  RCALL  55A0
5BB2:  MOVLW  2C
5BB4:  BTFSS  F9E.4
5BB6:  BRA    5BB4
5BB8:  MOVWF  FAD
5BBA:  MOVLW  89
5BBC:  MOVWF  FE9
5BBE:  MOVFF  114,1CC
5BC2:  MOVFF  113,1CB
5BC6:  MOVFF  112,1CA
5BCA:  MOVFF  111,1C9
5BCE:  MOVLW  03
5BD0:  MOVLB  1
5BD2:  MOVWF  xCD
5BD4:  MOVLB  0
5BD6:  RCALL  5746
5BD8:  MOVLW  2C
5BDA:  BTFSS  F9E.4
5BDC:  BRA    5BDA
5BDE:  MOVWF  FAD
5BE0:  MOVLW  89
5BE2:  MOVWF  FE9
5BE4:  MOVFF  118,1CC
5BE8:  MOVFF  117,1CB
5BEC:  MOVFF  116,1CA
5BF0:  MOVFF  115,1C9
5BF4:  MOVLW  03
5BF6:  MOVLB  1
5BF8:  MOVWF  xCD
5BFA:  MOVLB  0
5BFC:  RCALL  5746
5BFE:  MOVLW  2C
5C00:  BTFSS  F9E.4
5C02:  BRA    5C00
5C04:  MOVWF  FAD
5C06:  MOVLW  03
5C08:  MOVWF  FE9
5C0A:  MOVFF  108,1CC
5C0E:  MOVFF  107,1CB
5C12:  MOVFF  106,1CA
5C16:  MOVFF  105,1C9
5C1A:  MOVLB  1
5C1C:  MOVWF  xCD
5C1E:  MOVLB  0
5C20:  RCALL  5746
5C22:  MOVLW  2C
5C24:  BTFSS  F9E.4
5C26:  BRA    5C24
5C28:  MOVWF  FAD
5C2A:  MOVLW  0D
5C2C:  BTFSS  F9E.4
5C2E:  BRA    5C2C
5C30:  MOVWF  FAD
.................... 			fprintFUZZYini=FALSE; 
5C32:  MOVLB  1
5C34:  BCF    x77.1
5C36:  CLRF   19
5C38:  BTFSC  FF2.6
5C3A:  BSF    19.6
5C3C:  BCF    FF2.6
5C3E:  BTFSC  FF2.7
5C40:  BSF    19.7
5C42:  BCF    FF2.7
.................... 			enable_timer1(TRUE); 
5C44:  MOVLW  01
5C46:  MOVLB  2
5C48:  MOVWF  x13
5C4A:  MOVLB  0
5C4C:  CALL   34BE
5C50:  BTFSC  19.6
5C52:  BSF    FF2.6
5C54:  BTFSC  19.7
5C56:  BSF    FF2.7
.................... 			putc('<'); 
5C58:  MOVLW  3C
5C5A:  CALL   4F82
5C5E:  MOVLB  1
.................... 		} 
.................... 		 
.................... 		if(fprintTc) 
5C60:  BTFSS  x77.2
5C62:  BRA    5CBA
.................... 		{ 
.................... 			putc('|'); 
5C64:  MOVLW  7C
5C66:  MOVLB  0
5C68:  CALL   4F82
.................... 			printf("%03Lu,\r",fuzzy.fparam.Tc);			 
5C6C:  MOVLW  0A
5C6E:  MOVWF  FE9
5C70:  MOVFF  11A,1CA
5C74:  MOVFF  119,1C9
5C78:  RCALL  5902
5C7A:  MOVLW  2C
5C7C:  BTFSS  F9E.4
5C7E:  BRA    5C7C
5C80:  MOVWF  FAD
5C82:  MOVLW  0D
5C84:  BTFSS  F9E.4
5C86:  BRA    5C84
5C88:  MOVWF  FAD
.................... 			fprintTc = FALSE; 
5C8A:  MOVLB  1
5C8C:  BCF    x77.2
.................... 			gTc = TRUE; 
5C8E:  BSF    x77.5
5C90:  CLRF   19
5C92:  BTFSC  FF2.6
5C94:  BSF    19.6
5C96:  BCF    FF2.6
5C98:  BTFSC  FF2.7
5C9A:  BSF    19.7
5C9C:  BCF    FF2.7
.................... 			enable_timer1(TRUE); 
5C9E:  MOVLW  01
5CA0:  MOVLB  2
5CA2:  MOVWF  x13
5CA4:  MOVLB  0
5CA6:  CALL   34BE
5CAA:  BTFSC  19.6
5CAC:  BSF    FF2.6
5CAE:  BTFSC  19.7
5CB0:  BSF    FF2.7
.................... 			putc('<'); 
5CB2:  MOVLW  3C
5CB4:  CALL   4F82
5CB8:  MOVLB  1
.................... 		} 
.................... 		 
.................... 		if(fprint) 
5CBA:  BTFSS  x77.3
5CBC:  BRA    5D7C
.................... 		{ 
.................... 			fprint = FALSE; 
5CBE:  BCF    x77.3
.................... 			 
.................... 			putc('*'); 
5CC0:  MOVLW  2A
5CC2:  MOVLB  0
5CC4:  CALL   4F82
....................      
.................... 			printf("Y%04Ld,\r",yf); 
5CC8:  MOVLW  59
5CCA:  BTFSS  F9E.4
5CCC:  BRA    5CCA
5CCE:  MOVWF  FAD
5CD0:  MOVLW  0A
5CD2:  MOVWF  FE9
5CD4:  MOVFF  172,1CC
5CD8:  MOVFF  171,1CB
5CDC:  RCALL  55A0
5CDE:  MOVLW  2C
5CE0:  BTFSS  F9E.4
5CE2:  BRA    5CE0
5CE4:  MOVWF  FAD
5CE6:  MOVLW  0D
5CE8:  BTFSS  F9E.4
5CEA:  BRA    5CE8
5CEC:  MOVWF  FAD
....................            
....................       if(modo==automatico) 
5CEE:  BTFSC  36.1
5CF0:  BRA    5D7A
....................       { 
.................... 				if(pid_selected) printf("U%04Ld,\r",pid.u); 
5CF2:  BTFSS  36.3
5CF4:  BRA    5D1E
5CF6:  MOVLW  55
5CF8:  BTFSS  F9E.4
5CFA:  BRA    5CF8
5CFC:  MOVWF  FAD
5CFE:  MOVLW  0A
5D00:  MOVWF  FE9
5D02:  MOVFF  E4,1CC
5D06:  MOVFF  E3,1CB
5D0A:  RCALL  55A0
5D0C:  MOVLW  2C
5D0E:  BTFSS  F9E.4
5D10:  BRA    5D0E
5D12:  MOVWF  FAD
5D14:  MOVLW  0D
5D16:  BTFSS  F9E.4
5D18:  BRA    5D16
5D1A:  MOVWF  FAD
.................... 				else if(fuzzy_selected) printf("U%04Ld,\r",(signed int16)fuzzy.u); 
5D1C:  BRA    5D7A
5D1E:  BTFSS  36.2
5D20:  BRA    5D7A
5D22:  CLRF   19
5D24:  BTFSC  FF2.6
5D26:  BSF    19.6
5D28:  BCF    FF2.6
5D2A:  BTFSC  FF2.7
5D2C:  BSF    19.7
5D2E:  BCF    FF2.7
5D30:  MOVFF  152,21C
5D34:  MOVFF  151,21B
5D38:  MOVFF  150,21A
5D3C:  MOVFF  14F,219
5D40:  CALL   08F2
5D44:  BTFSC  19.6
5D46:  BSF    FF2.6
5D48:  BTFSC  19.7
5D4A:  BSF    FF2.7
5D4C:  MOVFF  02,1CA
5D50:  MOVFF  01,1C9
5D54:  MOVLW  55
5D56:  BTFSS  F9E.4
5D58:  BRA    5D56
5D5A:  MOVWF  FAD
5D5C:  MOVLW  0A
5D5E:  MOVWF  FE9
5D60:  MOVFF  1CA,1CC
5D64:  MOVFF  1C9,1CB
5D68:  RCALL  55A0
5D6A:  MOVLW  2C
5D6C:  BTFSS  F9E.4
5D6E:  BRA    5D6C
5D70:  MOVWF  FAD
5D72:  MOVLW  0D
5D74:  BTFSS  F9E.4
5D76:  BRA    5D74
5D78:  MOVWF  FAD
5D7A:  MOVLB  1
....................       } 
.................... 		} 
.................... 		 
....................     if(fentrada_analogica) 
5D7C:  BTFSS  x7F.5
5D7E:  BRA    5DC4
5D80:  CLRF   19
5D82:  BTFSC  FF2.6
5D84:  BSF    19.6
5D86:  BCF    FF2.6
5D88:  BTFSC  FF2.7
5D8A:  BSF    19.7
5D8C:  BCF    FF2.7
....................     { 
....................         printf("%04Ld\r",ADC_Read(analog_value)); 
5D8E:  MOVFF  1A4,219
5D92:  MOVLB  0
5D94:  CALL   01F2
5D98:  BTFSC  19.6
5D9A:  BSF    FF2.6
5D9C:  BTFSC  19.7
5D9E:  BSF    FF2.7
5DA0:  MOVFF  02,1CA
5DA4:  MOVFF  01,1C9
5DA8:  MOVLW  0A
5DAA:  MOVWF  FE9
5DAC:  MOVFF  02,1CC
5DB0:  MOVFF  01,1CB
5DB4:  CALL   55A0
5DB8:  MOVLW  0D
5DBA:  BTFSS  F9E.4
5DBC:  BRA    5DBA
5DBE:  MOVWF  FAD
....................         fentrada_analogica=FALSE; 
5DC0:  MOVLB  1
5DC2:  BCF    x7F.5
....................     } 
.................... } 
5DC4:  MOVLB  0
5DC6:  GOTO   723C (RETURN)
....................  
.................... #separate 
.................... void saveToEEPROM() 
.................... { 
....................     //Guardando en EEPROM         
....................     if(grf) 
*
5E9A:  BTFSS  36.4
5E9C:  BRA    5EB2
....................   	{ 
....................     	write_int16_eeprom(address_rf,rf); 
5E9E:  MOVLW  0E
5EA0:  MOVLB  1
5EA2:  MOVWF  xC9
5EA4:  MOVFF  170,1CB
5EA8:  MOVFF  16F,1CA
5EAC:  MOVLB  0
5EAE:  RCALL  5DCA
....................        
....................     	grf=FALSE; 
5EB0:  BCF    36.4
....................   	} 
....................      
....................     if(gk) 
5EB2:  MOVLB  1
5EB4:  BTFSS  x77.4
5EB6:  BRA    5F78
....................     { 
.................... 			if(pid_selected) 
5EB8:  BTFSS  36.3
5EBA:  BRA    5F0A
.................... 			{ 
.................... 				write_float_eeprom(address_Kp,pid.param.Kp); 
5EBC:  CLRF   xC9
5EBE:  MOVFF  CA,1CD
5EC2:  MOVFF  C9,1CC
5EC6:  MOVFF  C8,1CB
5ECA:  MOVFF  C7,1CA
5ECE:  MOVLB  0
5ED0:  RCALL  5E34
.................... 				write_float_eeprom(address_Ki,pid.param.Ki); 
5ED2:  MOVLW  04
5ED4:  MOVLB  1
5ED6:  MOVWF  xC9
5ED8:  MOVFF  D2,1CD
5EDC:  MOVFF  D1,1CC
5EE0:  MOVFF  D0,1CB
5EE4:  MOVFF  CF,1CA
5EE8:  MOVLB  0
5EEA:  RCALL  5E34
.................... 				write_float_eeprom(address_Kd,pid.param.Kd); 
5EEC:  MOVLW  08
5EEE:  MOVLB  1
5EF0:  MOVWF  xC9
5EF2:  MOVFF  CE,1CD
5EF6:  MOVFF  CD,1CC
5EFA:  MOVFF  CC,1CB
5EFE:  MOVFF  CB,1CA
5F02:  MOVLB  0
5F04:  RCALL  5E34
....................       } 
.................... 			else if(fuzzy_selected) 
5F06:  BRA    5F74
5F08:  MOVLB  1
5F0A:  BTFSS  36.2
5F0C:  BRA    5F76
.................... 			{ 
.................... 				write_float_eeprom(address_Kp_Fuzzy,fuzzy.fparam.Kp); 
5F0E:  MOVLW  18
5F10:  MOVWF  xC9
5F12:  MOVFF  FC,1CD
5F16:  MOVFF  FB,1CC
5F1A:  MOVFF  FA,1CB
5F1E:  MOVFF  F9,1CA
5F22:  MOVLB  0
5F24:  RCALL  5E34
.................... 				write_float_eeprom(address_Ki_Fuzzy,fuzzy.fparam.Ki); 
5F26:  MOVLW  1C
5F28:  MOVLB  1
5F2A:  MOVWF  xC9
5F2C:  MOVFF  104,1CD
5F30:  MOVFF  103,1CC
5F34:  MOVFF  102,1CB
5F38:  MOVFF  101,1CA
5F3C:  MOVLB  0
5F3E:  RCALL  5E34
.................... 				write_float_eeprom(address_Kd_Fuzzy,fuzzy.fparam.Kd); 
5F40:  MOVLW  20
5F42:  MOVLB  1
5F44:  MOVWF  xC9
5F46:  MOVFF  100,1CD
5F4A:  MOVFF  FF,1CC
5F4E:  MOVFF  FE,1CB
5F52:  MOVFF  FD,1CA
5F56:  MOVLB  0
5F58:  RCALL  5E34
.................... 				write_float_eeprom(address_Kpi_Fuzzy,fuzzy.fparam.Kpi); 
5F5A:  MOVLW  32
5F5C:  MOVLB  1
5F5E:  MOVWF  xC9
5F60:  MOVFF  108,1CD
5F64:  MOVFF  107,1CC
5F68:  MOVFF  106,1CB
5F6C:  MOVFF  105,1CA
5F70:  MOVLB  0
5F72:  RCALL  5E34
5F74:  MOVLB  1
.................... 			} 
....................       gk=0; 
5F76:  BCF    x77.4
....................     } 
....................          
....................     if(gTc) 
5F78:  BTFSS  x77.5
5F7A:  BRA    5FAC
....................     { 
.................... 			if(pid_selected)  
5F7C:  BTFSS  36.3
5F7E:  BRA    5F94
.................... 				write_int16_eeprom(address_Tc,pid.param.Tc); 
5F80:  MOVLW  0C
5F82:  MOVWF  xC9
5F84:  MOVFF  D4,1CB
5F88:  MOVFF  D3,1CA
5F8C:  MOVLB  0
5F8E:  RCALL  5DCA
....................       else if(fuzzy_selected)  
5F90:  BRA    5FA8
5F92:  MOVLB  1
5F94:  BTFSS  36.2
5F96:  BRA    5FAA
.................... 				write_int16_eeprom(address_Tc_Fuzzy,fuzzy.fparam.Tc); 
5F98:  MOVLW  28
5F9A:  MOVWF  xC9
5F9C:  MOVFF  11A,1CB
5FA0:  MOVFF  119,1CA
5FA4:  MOVLB  0
5FA6:  RCALL  5DCA
5FA8:  MOVLB  1
.................... 			 
....................       gTc=FALSE; 
5FAA:  BCF    x77.5
....................     } 
....................      
....................     if(gcantM) 
5FAC:  BTFSS  x7F.4
5FAE:  BRA    5FE0
....................     { 
....................       write_eeprom(address_cantM,cantM); 
5FB0:  BTFSC  FA6.1
5FB2:  BRA    5FB0
5FB4:  BCF    FA6.2
5FB6:  MOVLW  10
5FB8:  MOVWF  FA9
5FBA:  MOVFF  182,FA8
5FBE:  BCF    FA6.6
5FC0:  BCF    FA6.7
5FC2:  BSF    FA6.2
5FC4:  MOVF   FF2,W
5FC6:  MOVWF  00
5FC8:  BCF    FF2.6
5FCA:  BCF    FF2.7
5FCC:  MOVLB  F
5FCE:  MOVLW  55
5FD0:  MOVWF  FA7
5FD2:  MOVLW  AA
5FD4:  MOVWF  FA7
5FD6:  BSF    FA6.1
5FD8:  MOVF   00,W
5FDA:  IORWF  FF2,F
....................        
....................       gcantM=FALSE; 
5FDC:  MOVLB  1
5FDE:  BCF    x7F.4
....................     } 
....................      
....................     if(gBR) 
5FE0:  BTFSS  36.5
5FE2:  BRA    6014
....................     { 
....................       write_eeprom(address_BaudRate,seleccionBR); 
5FE4:  BTFSC  FA6.1
5FE6:  BRA    5FE4
5FE8:  BCF    FA6.2
5FEA:  MOVLW  12
5FEC:  MOVWF  FA9
5FEE:  MOVFF  175,FA8
5FF2:  BCF    FA6.6
5FF4:  BCF    FA6.7
5FF6:  BSF    FA6.2
5FF8:  MOVF   FF2,W
5FFA:  MOVWF  00
5FFC:  BCF    FF2.6
5FFE:  BCF    FF2.7
6000:  MOVLB  F
6002:  MOVLW  55
6004:  MOVWF  FA7
6006:  MOVLW  AA
6008:  MOVWF  FA7
600A:  BSF    FA6.1
600C:  MOVF   00,W
600E:  IORWF  FF2,F
....................        
....................       gBR=FALSE; 
6010:  BCF    36.5
6012:  MOVLB  1
....................     } 
....................          
....................     if(gPWMf) 
6014:  BTFSS  36.6
6016:  BRA    604E
....................     { 
....................       write_eeprom(address_PWMf,seleccionPWMf); 
6018:  BTFSC  FA6.1
601A:  BRA    6018
601C:  BCF    FA6.2
601E:  MOVLW  14
6020:  MOVWF  FA9
6022:  MOVFF  176,FA8
6026:  BCF    FA6.6
6028:  BCF    FA6.7
602A:  BSF    FA6.2
602C:  MOVF   FF2,W
602E:  MOVWF  00
6030:  BCF    FF2.6
6032:  BCF    FF2.7
6034:  MOVLB  F
6036:  MOVLW  55
6038:  MOVWF  FA7
603A:  MOVLW  AA
603C:  MOVWF  FA7
603E:  BSF    FA6.1
6040:  MOVF   00,W
6042:  IORWF  FF2,F
....................        
....................       gPWMf=FALSE; 
6044:  BCF    36.6
.................... 	   
.................... 	  	set_PWM_period();	//configurando Timer 2 
6046:  MOVLB  0
6048:  CALL   4EDC
604C:  MOVLB  1
....................     } 
....................       
....................     if(gTP) 
604E:  BTFSS  36.7
6050:  BRA    6082
....................     { 
....................       write_eeprom(address_tipoProcesamiento,tipo_procesamiento); 
6052:  BTFSC  FA6.1
6054:  BRA    6052
6056:  BCF    FA6.2
6058:  MOVLW  16
605A:  MOVWF  FA9
605C:  MOVFF  1A3,FA8
6060:  BCF    FA6.6
6062:  BCF    FA6.7
6064:  BSF    FA6.2
6066:  MOVF   FF2,W
6068:  MOVWF  00
606A:  BCF    FF2.6
606C:  BCF    FF2.7
606E:  MOVLB  F
6070:  MOVLW  55
6072:  MOVWF  FA7
6074:  MOVLW  AA
6076:  MOVWF  FA7
6078:  BSF    FA6.1
607A:  MOVF   00,W
607C:  IORWF  FF2,F
....................         
....................       gTP=FALSE; 
607E:  BCF    36.7
6080:  MOVLB  1
....................     } 
....................         
.................... 		if(fuzzy.fparam.guniversoPI) 
6082:  BTFSS  x1B.0
6084:  BRA    609A
.................... 		{ 
.................... 			write_int16_eeprom(address_universoPI,fuzzy.fparam.universo_duPI_max); 
6086:  MOVLW  26
6088:  MOVWF  xC9
608A:  MOVFF  10C,1CB
608E:  MOVFF  10B,1CA
6092:  MOVLB  0
6094:  RCALL  5DCA
.................... 			 
.................... 			fuzzy.fparam.guniversoPI = FALSE; 
6096:  MOVLB  1
6098:  BCF    x1B.0
.................... 		} 
.................... 		 
.................... 		if(fuzzy.fparam.guniversoPD) 
609A:  BTFSS  x1B.1
609C:  BRA    60B2
.................... 		{ 
.................... 			write_int16_eeprom(address_universoPD,fuzzy.fparam.universo_uPD_max); 
609E:  MOVLW  24
60A0:  MOVWF  xC9
60A2:  MOVFF  110,1CB
60A6:  MOVFF  10F,1CA
60AA:  MOVLB  0
60AC:  RCALL  5DCA
.................... 			 
.................... 			fuzzy.fparam.guniversoPD = FALSE; 
60AE:  MOVLB  1
60B0:  BCF    x1B.1
.................... 		} 
.................... 		 
.................... 		if(fuzzy.fparam.gstepPD) 
60B2:  BTFSS  x1B.3
60B4:  BRA    60D2
.................... 		{ 
.................... 			write_float_eeprom(address_stepPD,fuzzy.fparam.stepPD); 
60B6:  MOVLW  2A
60B8:  MOVWF  xC9
60BA:  MOVFF  114,1CD
60BE:  MOVFF  113,1CC
60C2:  MOVFF  112,1CB
60C6:  MOVFF  111,1CA
60CA:  MOVLB  0
60CC:  RCALL  5E34
.................... 			 
.................... 			fuzzy.fparam.gstepPD = FALSE; 
60CE:  MOVLB  1
60D0:  BCF    x1B.3
.................... 		} 
.................... 		 
.................... 		if(fuzzy.fparam.gstepPI) 
60D2:  BTFSS  x1B.2
60D4:  BRA    60F2
.................... 		{ 
.................... 			write_float_eeprom(address_stepPI,fuzzy.fparam.stepPI); 
60D6:  MOVLW  2E
60D8:  MOVWF  xC9
60DA:  MOVFF  118,1CD
60DE:  MOVFF  117,1CC
60E2:  MOVFF  116,1CB
60E6:  MOVFF  115,1CA
60EA:  MOVLB  0
60EC:  RCALL  5E34
.................... 			 
.................... 			fuzzy.fparam.gstepPI = FALSE; 
60EE:  MOVLB  1
60F0:  BCF    x1B.2
.................... 		} 
.................... 		 
.................... 		if(gPWMseleccion) 
60F2:  BTFSS  x77.7
60F4:  BRA    612E
.................... 		{ 
.................... 			write_eeprom(address_fPWM1,fPWM1); 
60F6:  MOVLW  00
60F8:  BTFSC  x77.6
60FA:  MOVLW  01
60FC:  MOVWF  xC9
60FE:  BTFSC  FA6.1
6100:  BRA    60FE
6102:  BCF    FA6.2
6104:  MOVLW  36
6106:  MOVWF  FA9
6108:  MOVFF  1C9,FA8
610C:  BCF    FA6.6
610E:  BCF    FA6.7
6110:  BSF    FA6.2
6112:  MOVF   FF2,W
6114:  MOVWF  00
6116:  BCF    FF2.6
6118:  BCF    FF2.7
611A:  MOVLB  F
611C:  MOVLW  55
611E:  MOVWF  FA7
6120:  MOVLW  AA
6122:  MOVWF  FA7
6124:  BSF    FA6.1
6126:  MOVF   00,W
6128:  IORWF  FF2,F
....................  
.................... 			gPWMseleccion = FALSE; 
612A:  MOVLB  1
612C:  BCF    x77.7
.................... 		} 
.................... 		 
.................... 		if(gADseleccion) 
612E:  BTFSS  x7F.0
6130:  BRA    6162
.................... 		{ 
.................... 			write_eeprom(address_ADselected,ADselected); 
6132:  BTFSC  FA6.1
6134:  BRA    6132
6136:  BCF    FA6.2
6138:  MOVLW  37
613A:  MOVWF  FA9
613C:  MOVFF  17E,FA8
6140:  BCF    FA6.6
6142:  BCF    FA6.7
6144:  BSF    FA6.2
6146:  MOVF   FF2,W
6148:  MOVWF  00
614A:  BCF    FF2.6
614C:  BCF    FF2.7
614E:  MOVLB  F
6150:  MOVLW  55
6152:  MOVWF  FA7
6154:  MOVLW  AA
6156:  MOVWF  FA7
6158:  BSF    FA6.1
615A:  MOVF   00,W
615C:  IORWF  FF2,F
....................  
.................... 			gADseleccion = FALSE; 
615E:  MOVLB  1
6160:  BCF    x7F.0
.................... 		}		 
.................... 		 
.................... 		if(gTipoAccion) 
6162:  BTFSS  x7F.2
6164:  BRA    619E
.................... 		{ 
.................... 			write_eeprom(address_TipoAccion,fTipoAccion); 
6166:  MOVLW  00
6168:  BTFSC  x7F.1
616A:  MOVLW  01
616C:  MOVWF  xC9
616E:  BTFSC  FA6.1
6170:  BRA    616E
6172:  BCF    FA6.2
6174:  MOVLW  38
6176:  MOVWF  FA9
6178:  MOVFF  1C9,FA8
617C:  BCF    FA6.6
617E:  BCF    FA6.7
6180:  BSF    FA6.2
6182:  MOVF   FF2,W
6184:  MOVWF  00
6186:  BCF    FF2.6
6188:  BCF    FF2.7
618A:  MOVLB  F
618C:  MOVLW  55
618E:  MOVWF  FA7
6190:  MOVLW  AA
6192:  MOVWF  FA7
6194:  BSF    FA6.1
6196:  MOVF   00,W
6198:  IORWF  FF2,F
....................  
.................... 			gTipoAccion = FALSE; 
619A:  MOVLB  1
619C:  BCF    x7F.2
.................... 		}			 
.................... } 
619E:  MOVLB  0
61A0:  GOTO   7240 (RETURN)
....................  
.................... #separate 
.................... void guardar_bufferRx() 
.................... { 
.................... 	int i; 
.................... 	 
.................... 	bRxSelect=bufferRxSelect; 
61A4:  MOVFF  1C6,1C5
.................... 	 
.................... 	for(i=0;i<buffer_size;i++) 
61A8:  MOVLB  1
61AA:  CLRF   xC9
61AC:  MOVF   xC9,W
61AE:  SUBLW  09
61B0:  BNC   61E4
.................... 		bRx[i]=bufferRx[i]; 
61B2:  CLRF   03
61B4:  MOVF   xC9,W
61B6:  ADDLW  A7
61B8:  MOVWF  01
61BA:  MOVLW  01
61BC:  ADDWFC 03,F
61BE:  MOVFF  03,1CB
61C2:  CLRF   03
61C4:  MOVF   xC9,W
61C6:  ADDLW  B2
61C8:  MOVWF  FE9
61CA:  MOVLW  01
61CC:  ADDWFC 03,W
61CE:  MOVWF  FEA
61D0:  MOVFF  FEF,1CC
61D4:  MOVFF  1CB,FEA
61D8:  MOVFF  01,FE9
61DC:  MOVFF  1CC,FEF
61E0:  INCF   xC9,F
61E2:  BRA    61AC
.................... } 
61E4:  MOVLB  0
61E6:  GOTO   724E (RETURN)
....................  
.................... void main() 
.................... {	 
*
7184:  CLRF   FF8
7186:  BCF    FF1.2
7188:  BCF    F9F.0
718A:  BSF    F9F.5
718C:  BSF    FD0.7
718E:  BSF    07.7
7190:  CLRF   FEA
7192:  CLRF   FE9
7194:  BSF    FB8.3
7196:  MOVLW  08
7198:  MOVWF  FAF
719A:  MOVLW  02
719C:  MOVWF  FB0
719E:  MOVLW  A6
71A0:  MOVWF  FAC
71A2:  MOVLW  90
71A4:  MOVWF  FAB
71A6:  MOVLB  1
71A8:  BCF    xC1.3
71AA:  BCF    xC1.4
71AC:  CLRF   xC7
71AE:  CLRF   xC8
71B0:  MOVF   FC1,W
71B2:  ANDLW  C0
71B4:  IORLW  0F
71B6:  MOVWF  FC1
71B8:  MOVLW  07
71BA:  MOVWF  FB4
71BC:  CLRF   2F
71BE:  CLRF   30
71C0:  CLRF   31
71C2:  CLRF   x83
71C4:  CLRF   x84
71C6:  CLRF   x85
71C8:  CLRF   x86
71CA:  CLRF   x87
71CC:  CLRF   x88
71CE:  CLRF   x89
71D0:  CLRF   x8A
71D2:  CLRF   x8B
71D4:  CLRF   x8C
71D6:  CLRF   x8D
71D8:  CLRF   x8E
71DA:  CLRF   x8F
71DC:  CLRF   x90
71DE:  CLRF   x91
71E0:  CLRF   x92
71E2:  CLRF   x93
71E4:  CLRF   x94
71E6:  CLRF   x95
71E8:  CLRF   x96
71EA:  CLRF   x97
71EC:  CLRF   x98
71EE:  CLRF   x99
71F0:  CLRF   x9A
71F2:  CLRF   x9B
71F4:  CLRF   x9C
71F6:  CLRF   x9D
71F8:  CLRF   x9E
71FA:  CLRF   x9F
71FC:  CLRF   xA0
71FE:  CLRF   xA1
7200:  CLRF   xA2
7202:  CLRF   xA7
7204:  CLRF   xA8
7206:  CLRF   xA9
7208:  CLRF   xAA
720A:  CLRF   xAB
720C:  CLRF   xAC
720E:  CLRF   xAD
7210:  CLRF   xAE
7212:  CLRF   xAF
7214:  CLRF   xB0
7216:  CLRF   xB1
7218:  CLRF   xB2
721A:  CLRF   xB3
721C:  CLRF   xB4
721E:  CLRF   xB5
7220:  CLRF   xB6
7222:  CLRF   xB7
7224:  CLRF   xB8
7226:  CLRF   xB9
7228:  CLRF   xBA
722A:  CLRF   xBB
722C:  CLRF   xBC
....................   setup(); 
722E:  MOVLB  0
7230:  GOTO   3776
....................   initialize(); 
7234:  GOTO   4F8A
....................  
....................   while(TRUE) 
....................   {		  
.................... 		printRS232(); 
7238:  GOTO   59D0
.................... 		saveToEEPROM(); 
723C:  GOTO   5E9A
....................  
.................... 		if(fRx) 
7240:  MOVLB  1
7242:  BTFSS  xC1.3
7244:  BRA    7254
.................... 		{ 
.................... 			fRx=FALSE; 
7246:  BCF    xC1.3
.................... 			 
.................... 			guardar_bufferRx(); 
7248:  MOVLB  0
724A:  GOTO   61A4
.................... 			 
....................   		analizar_Rx(bRxSelect); 
724E:  MOVFF  1C5,1C9
7252:  BRA    7028
.................... 		} 
....................   } 
7254:  MOVLB  0
7256:  BRA    7238
.................... } 
7258:  SLEEP 

Configuration Fuses:
   Word  1: CC24   IESO FCMEN HS PLL5 CPUDIV1 USBDIV
   Word  2: 1E39   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 87 7A 00 00 86 16 00 00 81 30 00 00 01 00 F4 01 
F00010: 03 00 00 00 07 00 03 00 7C 2E 14 7B 7C 00 00 00 
F00020: 7E 0C CC CD 58 02 14 00 06 00 87 16 00 00 82 20 
F00030: 00 00 7E 0C CC CD 00 00 00 00 00 00 
